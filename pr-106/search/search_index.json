{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chain-Aware ROS Evaluation Tool (CARET) # CARET is one of performance analysis tool dedicated with ROS 2 applications. It is able to measure not only callback latency and communication latency, but also path latency, in other words, chain of node or callback. As additional tracepoints are introduced by function hook, tracing resolution is improved. Features and capabilities are shown below. Features: Low overhead with LTTng-based tracepoints for sampling events in ROS/DDS layer Flexible tracepoints added by function hooking with LD_PRELOAD Python-based API for flexible data analysis and visualization Application-layer events tracing by cooperation with TILDE, runtime message tracer Capabilities: Performance measurement from several aspects Callback latency, frequency, and period Topic communication latency, frequency, and period Node latency Path latency End-to-end latency of software if path from input to output is selected Visualization of scheduling for callback execution Filtering function to ignore specific nodes and topics Search of target paths to trace Trace of application events like consumption of buffered topic message /tf (planned for v0.3.x release) message_filters (supported by TILDE) image_transport (supported by TILDE) Tracing flow with CARET # CARET gives you capability of tracing your application with introducing new tracepoints to ROS and DDS layer while it utilized original tracepoints for ros2_tracing . CARET is served as only source code, but not as apt package, so far. CARET hooks dedicated functions to those defined in dynamic library in order to add tracepoints. The fork of rclcpp which has CARET-dedicated tracepoints is delivered. You have to build CARET and your application if you want to use. After you run your application with CARET, you will get recorded data which includes events, metadata and timestamp. You have to write a configuration file, called architecture file, in which you defines node latency and target path, before you analyze the data set. You will visualize trace data with the architecture file and CARET_analyze package, including API for data analysis. CARET_analyze is designed on assumption that users analyze trace data on Jupyter Notebook. Contents list # Installation # Installation with Ansible is provided as the following page shows. Installation Tutorials # Refer to these page if you want to try. Recording Configuration Visualization Design # Index Software architecture Processing trace data Runtime processing Tracepoints Configuration Limits and constraints Details of each step for analysis # CARET serves helpful functions for you to analyze your application efficiently. Please refer to detailed explanation of each step for analysis. Recording Configuration Visualization API list # CARET serves powerful API to visualize and analyze performance. API list is located on the other repository, CARET_analyze . API list (external link) There are two types of APIs: for user and for developer . Related repositories # CARET is constructed of the following packages CARET_trace \uff5c Define tracepoints added by function hooking CARET_analyze \uff5c Library for scripts to analyze and visualize data CARET_analyze_cpp_impl \uff5c Efficient helper functions to analyze trace data written in C++ ros2caret \uff5c CLI commands like ros2 caret CARET_demos \uff5c Demo programs for CARET CARET_doc \uff5c Documentation rclcpp \uff5c the forked rclcpp including CARET-dedicated tracepoints ros2_tracing \uff5c the forked ros2_tracing including definition of CARET-dedicated tracepoints This software is based on results obtained from a project subsidized by the New Energy and Industrial Technology Development Organization (NEDO).","title":"Overview"},{"location":"#chain-aware-ros-evaluation-tool-caret","text":"CARET is one of performance analysis tool dedicated with ROS 2 applications. It is able to measure not only callback latency and communication latency, but also path latency, in other words, chain of node or callback. As additional tracepoints are introduced by function hook, tracing resolution is improved. Features and capabilities are shown below. Features: Low overhead with LTTng-based tracepoints for sampling events in ROS/DDS layer Flexible tracepoints added by function hooking with LD_PRELOAD Python-based API for flexible data analysis and visualization Application-layer events tracing by cooperation with TILDE, runtime message tracer Capabilities: Performance measurement from several aspects Callback latency, frequency, and period Topic communication latency, frequency, and period Node latency Path latency End-to-end latency of software if path from input to output is selected Visualization of scheduling for callback execution Filtering function to ignore specific nodes and topics Search of target paths to trace Trace of application events like consumption of buffered topic message /tf (planned for v0.3.x release) message_filters (supported by TILDE) image_transport (supported by TILDE)","title":"Chain-Aware ROS Evaluation Tool (CARET)"},{"location":"#tracing-flow-with-caret","text":"CARET gives you capability of tracing your application with introducing new tracepoints to ROS and DDS layer while it utilized original tracepoints for ros2_tracing . CARET is served as only source code, but not as apt package, so far. CARET hooks dedicated functions to those defined in dynamic library in order to add tracepoints. The fork of rclcpp which has CARET-dedicated tracepoints is delivered. You have to build CARET and your application if you want to use. After you run your application with CARET, you will get recorded data which includes events, metadata and timestamp. You have to write a configuration file, called architecture file, in which you defines node latency and target path, before you analyze the data set. You will visualize trace data with the architecture file and CARET_analyze package, including API for data analysis. CARET_analyze is designed on assumption that users analyze trace data on Jupyter Notebook.","title":"Tracing flow with CARET"},{"location":"#contents-list","text":"","title":"Contents list"},{"location":"#installation","text":"Installation with Ansible is provided as the following page shows. Installation","title":"Installation"},{"location":"#tutorials","text":"Refer to these page if you want to try. Recording Configuration Visualization","title":"Tutorials"},{"location":"#design","text":"Index Software architecture Processing trace data Runtime processing Tracepoints Configuration Limits and constraints","title":"Design"},{"location":"#details-of-each-step-for-analysis","text":"CARET serves helpful functions for you to analyze your application efficiently. Please refer to detailed explanation of each step for analysis. Recording Configuration Visualization","title":"Details of each step for analysis"},{"location":"#api-list","text":"CARET serves powerful API to visualize and analyze performance. API list is located on the other repository, CARET_analyze . API list (external link) There are two types of APIs: for user and for developer .","title":"API list"},{"location":"#related-repositories","text":"CARET is constructed of the following packages CARET_trace \uff5c Define tracepoints added by function hooking CARET_analyze \uff5c Library for scripts to analyze and visualize data CARET_analyze_cpp_impl \uff5c Efficient helper functions to analyze trace data written in C++ ros2caret \uff5c CLI commands like ros2 caret CARET_demos \uff5c Demo programs for CARET CARET_doc \uff5c Documentation rclcpp \uff5c the forked rclcpp including CARET-dedicated tracepoints ros2_tracing \uff5c the forked ros2_tracing including definition of CARET-dedicated tracepoints This software is based on results obtained from a project subsidized by the New Energy and Industrial Technology Development Organization (NEDO).","title":"Related repositories"},{"location":"changelog/","text":"Changelog # CARET # v0.3.0 _ Sept 26, 2022 # Supported OS: Ubuntu 22.04 Supported ROS Dist.: ROS Humble Imported to Ubuntu 22.04 and ROS Humble Added new feature to show response time ( CARET_analyze #96 ) Added new APIs to visualize frequency, period, and latency of publishes, subscriptions, and communications ( CARET_analyze #124 , #130 , #133 , #134 , #136 , #140 ) Reduced memory consumption wasted for recorded data ( CARET_analyze #100 ) Launched CARET_analyze API document Added small fixes CARET_analyze #107 CARET_analyze #107 CARET_analyze #108 CARET_analyze #109 CARET_analyze #112 CARET_analyze #115 v0.2.3 _ July 14, 2022 # Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Improved output message from path.verify() method Improved view of graphs Added wildcard support for Architecture.callbacks() method Added command line function to check trace data Fixed specification of Architecture.search_paths() method Added function to extract duplicated timer callback v0.2.2 _ May 2, 2022 # Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Added feature to measure complicated node path Added feature to choose optional trace points Added Architecture.search_paths() method Improved trace filtering function","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#caret","text":"","title":"CARET"},{"location":"changelog/#id","text":"Supported OS: Ubuntu 22.04 Supported ROS Dist.: ROS Humble Imported to Ubuntu 22.04 and ROS Humble Added new feature to show response time ( CARET_analyze #96 ) Added new APIs to visualize frequency, period, and latency of publishes, subscriptions, and communications ( CARET_analyze #124 , #130 , #133 , #134 , #136 , #140 ) Reduced memory consumption wasted for recorded data ( CARET_analyze #100 ) Launched CARET_analyze API document Added small fixes CARET_analyze #107 CARET_analyze #107 CARET_analyze #108 CARET_analyze #109 CARET_analyze #112 CARET_analyze #115","title":"v0.3.0 _ Sept 26, 2022"},{"location":"changelog/#id","text":"Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Improved output message from path.verify() method Improved view of graphs Added wildcard support for Architecture.callbacks() method Added command line function to check trace data Fixed specification of Architecture.search_paths() method Added function to extract duplicated timer callback","title":"v0.3.0 _ Sept 26, 2022"},{"location":"changelog/#id","text":"Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Added feature to measure complicated node path Added feature to choose optional trace points Added Architecture.search_paths() method Improved trace filtering function","title":"v0.3.0 _ Sept 26, 2022"},{"location":"gallery/","text":"Gallery # This page shows examples of figures that can be visualized in CARET. CARET visualizes these figures on jupyter-notebook. Message flow # Detail : Message flow Chain latency # Detail : Chain latency Latency timeseries # Detail : Latency timeseries Latency histogram # Detail : Latency histogram Execution frequency # Detail : Execution frequency Period # Detail : Period Latency # Detail : Latency Callback Scheduling Visualization # Detail : Callback Scheduling Visualization","title":"Gallery"},{"location":"gallery/#gallery","text":"This page shows examples of figures that can be visualized in CARET. CARET visualizes these figures on jupyter-notebook.","title":"Gallery"},{"location":"gallery/#message-flow","text":"Detail : Message flow","title":"Message flow"},{"location":"gallery/#chain-latency","text":"Detail : Chain latency","title":"Chain latency"},{"location":"gallery/#latency-timeseries","text":"Detail : Latency timeseries","title":"Latency timeseries"},{"location":"gallery/#latency-histogram","text":"Detail : Latency histogram","title":"Latency histogram"},{"location":"gallery/#execution-frequency","text":"Detail : Execution frequency","title":"Execution frequency"},{"location":"gallery/#period","text":"Detail : Period","title":"Period"},{"location":"gallery/#latency","text":"Detail : Latency","title":"Latency"},{"location":"gallery/#callback-scheduling-visualization","text":"Detail : Callback Scheduling Visualization","title":"Callback Scheduling Visualization"},{"location":"configuration/","text":"Configuration # Introduction # Configuration is a phase where users tell CARET which data path is targeted for visualization. CARET is capable of recording enormous numbers of events even when a large application runs. The large application may have lots of data paths, but most users must not want to observe all of data paths. If CARET kindly shows analysis results for all of possible data paths, users will be overwhelmed and exhausted to deal with large amount of results. For delivering efficient analysis, CARET is designed to show analysis results on demand. CARET serves user functions to select target data paths to fulfill their interests. In addition to defining targeted path, CARET will ask users to define node latency before users analyze their application with visualization. The rest of this chapter will explain the following two types of sections; The detailed background of configuration The basic procedure for preparing desired configuration In detail, the following sections are listed as below. Background of configuration section will explain detailed background of configuration phase How to load and save section will tell you how to load and save configuration How to define inter-node data path section will tell you how to use architecture.search_paths() How to define intra-node data path will let you know what message_context is. This is advanced topic than others Practical example with CARET_sample will be available in the near future, but it is available in tutorial page Visualization of application structure will be prepared as an appendix which shows another usage of an architecture object. CARET can show structure of a targeted application while it is a performance analysis tool. This appendix will be disclosed in the near future also.","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#introduction","text":"Configuration is a phase where users tell CARET which data path is targeted for visualization. CARET is capable of recording enormous numbers of events even when a large application runs. The large application may have lots of data paths, but most users must not want to observe all of data paths. If CARET kindly shows analysis results for all of possible data paths, users will be overwhelmed and exhausted to deal with large amount of results. For delivering efficient analysis, CARET is designed to show analysis results on demand. CARET serves user functions to select target data paths to fulfill their interests. In addition to defining targeted path, CARET will ask users to define node latency before users analyze their application with visualization. The rest of this chapter will explain the following two types of sections; The detailed background of configuration The basic procedure for preparing desired configuration In detail, the following sections are listed as below. Background of configuration section will explain detailed background of configuration phase How to load and save section will tell you how to load and save configuration How to define inter-node data path section will tell you how to use architecture.search_paths() How to define intra-node data path will let you know what message_context is. This is advanced topic than others Practical example with CARET_sample will be available in the near future, but it is available in tutorial page Visualization of application structure will be prepared as an appendix which shows another usage of an architecture object. CARET can show structure of a targeted application while it is a performance analysis tool. This appendix will be disclosed in the near future also.","title":"Introduction"},{"location":"configuration/background/","text":"Background # CARET is mainly capable of showing the following 4 latency: callback latency communication latency (inter-node) node latency (intra-node) path latency (intra-node & inter-node) The following figure shows definition of node latency and path latency. Callback latency is defined as execution time of a callback function, and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in an application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configurable object , called \" architecture object \". Architecture object # An architecture object has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can load an architecture object including only application structure section from CTF -based recorded data. The application structure section remains same unless the structure is changed or component is renamed. On the other hand, latency definition section in the original architecture object is empty just before users add any definition. Users are expected to add definitions of node latency and path latency to the original architecture object. CARET helps users to add definition of node and path latency. The following sections explain how to load an architecture object and add latency definition.","title":"Background of configuration"},{"location":"configuration/background/#background","text":"CARET is mainly capable of showing the following 4 latency: callback latency communication latency (inter-node) node latency (intra-node) path latency (intra-node & inter-node) The following figure shows definition of node latency and path latency. Callback latency is defined as execution time of a callback function, and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in an application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configurable object , called \" architecture object \".","title":"Background"},{"location":"configuration/background/#architecture-object","text":"An architecture object has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can load an architecture object including only application structure section from CTF -based recorded data. The application structure section remains same unless the structure is changed or component is renamed. On the other hand, latency definition section in the original architecture object is empty just before users add any definition. Users are expected to add definitions of node latency and path latency to the original architecture object. CARET helps users to add definition of node and path latency. The following sections explain how to load an architecture object and add latency definition.","title":"Architecture object"},{"location":"configuration/inter_node_data_path/","text":"How to define inter-nodes data path # Latency definition section is empty just after an architecture object is loaded from a set of CTF-based recorded data. If you want to observe data flow on targeted paths, you should add the target paths to the architecture object. As a path is combination of multiple nodes and topics, it may be laborious to list their names. To mitigate such burden, CARET serves a function to search the targeted path. The targeted path is added to the architecture object via Python API. Basic usage to find and add target path # Listing nodes and topics by their names is laborious. CARET serve a helpful method, arch.search_paths , to search candidates that you want to observe. The following sample code shows usage of arch.search_paths method. # Architecture object is loaded to variable of arch paths = arch . search_paths ( 'source_node' , 'destination_node' ) type ( paths ) # list of multiple paths paths [ 0 ] . summary . pprint () # shows nodes and topics in paths[0] In the sample, paths is a list including all possible paths between source_node and destination_node , whose type is PathStructValue . If you are satisfied with output from paths[0].summary.pprint() , you have to add paths[0] to the arch object as below. arch . add_path ( 'target_path' , paths [ 0 ]) arch . export ( 'new_architecture_with_path.yaml' ) In the above sample, paths[0] is named as target_path and registered to the arch object. arch object is exported to a new architecture file for reuse. If you want to restore the paths[0] object with new_architecture_with_path.yaml file, arch.get_path() method will help you to do so. arch = Architecture ( 'yaml' , 'new_architecture_with_path.yaml' ) path = arch . get_path ( 'target_path' ) # path object is same as paths[0] in the previous sample Efficient target path search # As explained above, Architecture.search_paths() returns list of multiple paths. The list size will be too large to find target path if application has large numbers of nodes and distance between source and destination node is long. In worse case, Architecture.search_paths() keep searching and does not return paths variable after hours passes. Architecture.search_paths() method serves four options to narrow down possible paths as below. Additional nodes as variable length arguments Limiting maximum number of nodes between given nodes with max_node_depth Node filter which excludes paths including specific nodes Communication filter which excludes paths including specific topics In short, Architecture.search_paths is defined as follows. search_paths ( * node_names : 'str' , max_node_depth : 'Optional[int]' = None , node_filter : 'Optional[Callable[[str], bool]]' = None , communication_filter : 'Optional[Callable[[str], bool]]' = None ) -> 'List[PathStructValue]' The following sub-sections will explain their roles and usages in details. Additional nodes # In the previous example, Architecture.search_paths() had two arguments source_node and destination_node . However, the number of nodes given to Architecture.search_paths() is variable and not always two. You can add other nodes to Architecture.search_paths() as below, and you will get a list including multiple paths which passes all given nodes. # Architecture object is loaded to variable of arch paths = arch . search_paths ( 'source_node' , 'intermediate_node_1' , 'intermediate_node_2' , 'destination_node' ) paths is a list including multiple paths which pass source_node , intermediate_node_1 , intermediate_node_2 , and destination_node . They are allowed to pass another node, but all chosen nodes are passed in order. Limiting maximum number of nodes # Architecture.search_paths() will scan all paths as possible if you don't give max_node_depth argument. max_node_depth means maximum number between given nodes. The number of candidate paths will be suppressed by this argument. This argument will be helpful When you waste much time for Architecture.search_paths() . The usage is shown as below. This can be used with another approach to filter candidates. # Architecture object is loaded to variable of arch paths = arch . search_paths ( 'source_node' , 'intermediate_node_1' , 'destination_node' , max_node_depth = 10 ) max_node_depth does not always limit the maximum number of nodes between source and destination. If you give 3 nodes to arch.search_paths as shown above, max_node_depth does not limits the maximum number of nodes between source_node and destination_node . In this example, max_node_depth limits the number of nodes between source_node and intermediate_node_1 , and that between intermediate_node_1 and destination_node . Node and topic filter # As node filter is similar to communication filter, they are explained together in this section. With node filter and communication filter, Architecture.search_paths() excludes paths which includes selected nodes or topics. They support regular expression. The following sample code shows usage. import re # name list of nodes to be excluded node_filters = [ re . compile ( r '/_ros2cli_/*' ), re . compile ( r '/launch_ros_*' ), ] # name list of topics to be excluded comm_filters = [ re . compile ( r '/tf/*' ), ] def comm_filter ( topic_name : str ) -> bool : can_pass = True for comm_filter in comm_filters : can_pass &= not bool ( comm_filter . search ( topic_name )) return can_pass def node_filter ( node_name : str ) -> bool : can_pass = True for node_filter in node_filters : can_pass &= not bool ( node_filter . search ( node_name )) return can_pass paths = arch . search_paths ( '/start_node' , '/intermediate_node' '/end_node' , max_node_depth = 30 , node_filter = node_filter , communication_filter = comm_filter )","title":"Define inter-node data path"},{"location":"configuration/inter_node_data_path/#how-to-define-inter-nodes-data-path","text":"Latency definition section is empty just after an architecture object is loaded from a set of CTF-based recorded data. If you want to observe data flow on targeted paths, you should add the target paths to the architecture object. As a path is combination of multiple nodes and topics, it may be laborious to list their names. To mitigate such burden, CARET serves a function to search the targeted path. The targeted path is added to the architecture object via Python API.","title":"How to define inter-nodes data path"},{"location":"configuration/inter_node_data_path/#basic-usage-to-find-and-add-target-path","text":"Listing nodes and topics by their names is laborious. CARET serve a helpful method, arch.search_paths , to search candidates that you want to observe. The following sample code shows usage of arch.search_paths method. # Architecture object is loaded to variable of arch paths = arch . search_paths ( 'source_node' , 'destination_node' ) type ( paths ) # list of multiple paths paths [ 0 ] . summary . pprint () # shows nodes and topics in paths[0] In the sample, paths is a list including all possible paths between source_node and destination_node , whose type is PathStructValue . If you are satisfied with output from paths[0].summary.pprint() , you have to add paths[0] to the arch object as below. arch . add_path ( 'target_path' , paths [ 0 ]) arch . export ( 'new_architecture_with_path.yaml' ) In the above sample, paths[0] is named as target_path and registered to the arch object. arch object is exported to a new architecture file for reuse. If you want to restore the paths[0] object with new_architecture_with_path.yaml file, arch.get_path() method will help you to do so. arch = Architecture ( 'yaml' , 'new_architecture_with_path.yaml' ) path = arch . get_path ( 'target_path' ) # path object is same as paths[0] in the previous sample","title":"Basic usage to find and add target path"},{"location":"configuration/inter_node_data_path/#efficient-target-path-search","text":"As explained above, Architecture.search_paths() returns list of multiple paths. The list size will be too large to find target path if application has large numbers of nodes and distance between source and destination node is long. In worse case, Architecture.search_paths() keep searching and does not return paths variable after hours passes. Architecture.search_paths() method serves four options to narrow down possible paths as below. Additional nodes as variable length arguments Limiting maximum number of nodes between given nodes with max_node_depth Node filter which excludes paths including specific nodes Communication filter which excludes paths including specific topics In short, Architecture.search_paths is defined as follows. search_paths ( * node_names : 'str' , max_node_depth : 'Optional[int]' = None , node_filter : 'Optional[Callable[[str], bool]]' = None , communication_filter : 'Optional[Callable[[str], bool]]' = None ) -> 'List[PathStructValue]' The following sub-sections will explain their roles and usages in details.","title":"Efficient target path search"},{"location":"configuration/inter_node_data_path/#additional-nodes","text":"In the previous example, Architecture.search_paths() had two arguments source_node and destination_node . However, the number of nodes given to Architecture.search_paths() is variable and not always two. You can add other nodes to Architecture.search_paths() as below, and you will get a list including multiple paths which passes all given nodes. # Architecture object is loaded to variable of arch paths = arch . search_paths ( 'source_node' , 'intermediate_node_1' , 'intermediate_node_2' , 'destination_node' ) paths is a list including multiple paths which pass source_node , intermediate_node_1 , intermediate_node_2 , and destination_node . They are allowed to pass another node, but all chosen nodes are passed in order.","title":"Additional nodes"},{"location":"configuration/inter_node_data_path/#limiting-maximum-number-of-nodes","text":"Architecture.search_paths() will scan all paths as possible if you don't give max_node_depth argument. max_node_depth means maximum number between given nodes. The number of candidate paths will be suppressed by this argument. This argument will be helpful When you waste much time for Architecture.search_paths() . The usage is shown as below. This can be used with another approach to filter candidates. # Architecture object is loaded to variable of arch paths = arch . search_paths ( 'source_node' , 'intermediate_node_1' , 'destination_node' , max_node_depth = 10 ) max_node_depth does not always limit the maximum number of nodes between source and destination. If you give 3 nodes to arch.search_paths as shown above, max_node_depth does not limits the maximum number of nodes between source_node and destination_node . In this example, max_node_depth limits the number of nodes between source_node and intermediate_node_1 , and that between intermediate_node_1 and destination_node .","title":"Limiting maximum number of nodes"},{"location":"configuration/inter_node_data_path/#node-and-topic-filter","text":"As node filter is similar to communication filter, they are explained together in this section. With node filter and communication filter, Architecture.search_paths() excludes paths which includes selected nodes or topics. They support regular expression. The following sample code shows usage. import re # name list of nodes to be excluded node_filters = [ re . compile ( r '/_ros2cli_/*' ), re . compile ( r '/launch_ros_*' ), ] # name list of topics to be excluded comm_filters = [ re . compile ( r '/tf/*' ), ] def comm_filter ( topic_name : str ) -> bool : can_pass = True for comm_filter in comm_filters : can_pass &= not bool ( comm_filter . search ( topic_name )) return can_pass def node_filter ( node_name : str ) -> bool : can_pass = True for node_filter in node_filters : can_pass &= not bool ( node_filter . search ( node_name )) return can_pass paths = arch . search_paths ( '/start_node' , '/intermediate_node' '/end_node' , max_node_depth = 30 , node_filter = node_filter , communication_filter = comm_filter )","title":"Node and topic filter"},{"location":"configuration/intra_node_data_path/","text":"How to define intra-node data path # In the previous section, you learned how to define inter-node data path. CARET can calculate response time for a simple path using only inter-node data path definition. However, when a target application or path becomes complicated, intra-node-data path needs to be defined as well as inter-node data path. CARET assume that intra-node data path is mapping of topic subscription and publish in a node. This is not defined simply because the definition depends on implementation. This section will explain how to find which intra-node data path you have to define, and how to define it. Find which intra-node data path to define # Before defining intra-node data path, you have to check whether latency of the target path is calculable. This can be checked with Path.verify() method as the following sample code shows. arch = Architecture ( 'yaml' , '/path/to/architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () Here, path.verify() returns True if path latency for path is calculable. Otherwise, you will confront with warning messages as shown below. WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 On the sample warning message, /message_driven_node and /timer_driven_node have undefined intra-node data path. You will add the intra-node data path in next step. Message Context # CARET assumes that node latency is defined as duration from subscription time to publish time. The definition looks simple, but node latency is difficult to define mechanically because some nodes have multiple inputs or multiple outputs. CARET require users to define message_context to calculate node latency. One of the following policies is acceptable for message_context . use_latest_message callback_chain They have different capability to measure node latency, and the selected message_context policy decides how to calculate node latency. However, message_context is a little difficult for CARET beginners without any example. The subsequence section introduces an example issue before explaining the policies. These two policies are not enough to cover the arbitrary node latency, and some implementations have node latency that cannot be measured. For example, message filter is currently unable to measure. Example issue # An example issue on /ping_node and /pong_node is given as the below figure shows. Next items are explaining /ping_node and /pong_node . /ping_node it transmit messages of /ping topic to /pong_node it is composed of a single callback function /pong_node it transmits message of /pong topic to another node it is composed of two callback functions; subscription_callback_0 and timer_callback_1 it receives messages of /ping topic from /pong_node via subscription_callback_0 subscription_callback_0 shares messages /ping topic with timer_callback_1 via shared variable timer_callback_1 produces /pong with the shared messages timer_callback_1 runs about 8/5 as frequent as timer_callback_0 CARET is concerned which input topic message is mapped to an output message. message_context is provided to map input messages to output messages. use_latest_message # With use_latest_message policy, CARET will map a most recent input message to output message. CARET focuses on input and output,but is not concerned structure of node structure. The next figure shows how CARET defines node latency with use_latest_message in the example issue. In the figure, latest messages of ping topic is mapped to messages of /pong topic mechanically by CARET. It is not still easy to understand with only the block figure, but the provided timing chart below help you to understand what use_latest_message is. In the timing chart, colored boxes represent duration of callback running, and bold lines are message flow of topic message. Dotted lines indicates mapping between input messages and outputs. With use_latest_message , CARET assumes that output message is made from the most recent input message. use_latest_message is fairly simple and works well in most cases. In the timing chart, red dotted lines explains a pitfall of use_latest_message . Using use_latest_message policy, CARET believes that input message, which is not even processed completely, is mapped to output message. For example, CARET interprets that /pong[4] is made from /ping[2] because /ping[2] is the recent input message for /pong[4] . However, subscription_callback_0 is processing /ping[2] and does not share it with timer_callback_1 before publishing /pong[4] . You have to tell CARET the node structure when you find such pitfall. callback_chain # callback_chain is introduced for CARET to map input messages to outputs based on inter-operation of multiple callback functions. Input messages are consumed in subscription callbacks and propagated to other nodes. It looks as if input messages passes chains of multiple callbacks to make output messages. With callback_chain , CARET take care of input propagation on callbacks and it is helpful to escape the limitation of use_latest_message as mentioned above. Next figure shows how CARET interprets intra-node data path using callback_chain . Intra-communication between subscription_callback_0 and timer_callback_1 is taken into account for defining intra-node data path. variable_passings is a tag used in CARET, and represents such intra-communication. The following timing chart shows how input messages are mapped to output messages. CARET maps mechanically messages of /pong topic to messages of /ping which finish being processed on subscription_callback_0 . The unexpected behavior of use_latest_message is improved by callback_chain . callback_chain looks the best choice. However, it has several drawbacks. It is not designed for node which have multiple callbacks running at parallel, and response time might be longer than actual It is not able to detect actual time when buffered data are consumed because only CARET does not trace user code on ROS 2 Users are expected to know node structure beforehand Info use_latest_message and callback_chain do not cover all of use cases for CARET. We, CARET development team, continue improvements of intra-node data path definition. Python API # Python API is not implemented so far. Python API support is planned in 2023. Architecture file editing # This section explain how to add intra-node data path definition with editing an architecture file. The example issue above is used for explanation. use_latest_message # Next sample description is required for using use_latest_message on an architecture file. use_latest_message is applied to /pong_node in the next sample description. Essential description is extracted in the following snippet, but you will confront with busy YAML file actually rather than the sample. You have to add use_latest_message as context_types between targeted subscription and publisher. - node_name: /pong_node callbacks: - callback_name: subscription_callback_0 - callback_name: timer_callback_1 publishes: - topic_name: /pong callback_names: - timer_callback_1 # manually added subscribes: - topic_name: /ping callback_name: subscription_callback_0 message_contexts: - context_type: use_latest_message # manually added subscription_topic_name: /ping publisher_topic_name: /pong callback_chain # On the other hand, CARET requires users to provide the following description if you apply callback_chain to /pong_node . - node_name: /pong_node callbacks: - callback_name: subscription_callback_0 - callback_name: timer_callback_1 variable_passings: - callback_name_write: subscription_callback_0 # manually added callback_name_read: timer_callback_1 # manually added publishes: - topic_name: /ping callback_names: - timer_callback_1 # manually added subscribes: - topic_name: /pong callback_name: timer_callback_1 message_contexts: - context_type: callback_chain # manually added subscription_topic_name: /pong publisher_topic_name: /ping User have to fill callback name in variable_passings , publishes 's callback_name . context_type must be set as callback_chain . After editing, use path.verify() described in the beginning of this section to verify that it has been set correctly.","title":"Define intra-node data path"},{"location":"configuration/intra_node_data_path/#how-to-define-intra-node-data-path","text":"In the previous section, you learned how to define inter-node data path. CARET can calculate response time for a simple path using only inter-node data path definition. However, when a target application or path becomes complicated, intra-node-data path needs to be defined as well as inter-node data path. CARET assume that intra-node data path is mapping of topic subscription and publish in a node. This is not defined simply because the definition depends on implementation. This section will explain how to find which intra-node data path you have to define, and how to define it.","title":"How to define intra-node data path"},{"location":"configuration/intra_node_data_path/#find-which-intra-node-data-path-to-define","text":"Before defining intra-node data path, you have to check whether latency of the target path is calculable. This can be checked with Path.verify() method as the following sample code shows. arch = Architecture ( 'yaml' , '/path/to/architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () Here, path.verify() returns True if path latency for path is calculable. Otherwise, you will confront with warning messages as shown below. WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 On the sample warning message, /message_driven_node and /timer_driven_node have undefined intra-node data path. You will add the intra-node data path in next step.","title":"Find which intra-node data path to define"},{"location":"configuration/intra_node_data_path/#message-context","text":"CARET assumes that node latency is defined as duration from subscription time to publish time. The definition looks simple, but node latency is difficult to define mechanically because some nodes have multiple inputs or multiple outputs. CARET require users to define message_context to calculate node latency. One of the following policies is acceptable for message_context . use_latest_message callback_chain They have different capability to measure node latency, and the selected message_context policy decides how to calculate node latency. However, message_context is a little difficult for CARET beginners without any example. The subsequence section introduces an example issue before explaining the policies. These two policies are not enough to cover the arbitrary node latency, and some implementations have node latency that cannot be measured. For example, message filter is currently unable to measure.","title":"Message Context"},{"location":"configuration/intra_node_data_path/#example-issue","text":"An example issue on /ping_node and /pong_node is given as the below figure shows. Next items are explaining /ping_node and /pong_node . /ping_node it transmit messages of /ping topic to /pong_node it is composed of a single callback function /pong_node it transmits message of /pong topic to another node it is composed of two callback functions; subscription_callback_0 and timer_callback_1 it receives messages of /ping topic from /pong_node via subscription_callback_0 subscription_callback_0 shares messages /ping topic with timer_callback_1 via shared variable timer_callback_1 produces /pong with the shared messages timer_callback_1 runs about 8/5 as frequent as timer_callback_0 CARET is concerned which input topic message is mapped to an output message. message_context is provided to map input messages to output messages.","title":"Example issue"},{"location":"configuration/intra_node_data_path/#use_latest_message","text":"With use_latest_message policy, CARET will map a most recent input message to output message. CARET focuses on input and output,but is not concerned structure of node structure. The next figure shows how CARET defines node latency with use_latest_message in the example issue. In the figure, latest messages of ping topic is mapped to messages of /pong topic mechanically by CARET. It is not still easy to understand with only the block figure, but the provided timing chart below help you to understand what use_latest_message is. In the timing chart, colored boxes represent duration of callback running, and bold lines are message flow of topic message. Dotted lines indicates mapping between input messages and outputs. With use_latest_message , CARET assumes that output message is made from the most recent input message. use_latest_message is fairly simple and works well in most cases. In the timing chart, red dotted lines explains a pitfall of use_latest_message . Using use_latest_message policy, CARET believes that input message, which is not even processed completely, is mapped to output message. For example, CARET interprets that /pong[4] is made from /ping[2] because /ping[2] is the recent input message for /pong[4] . However, subscription_callback_0 is processing /ping[2] and does not share it with timer_callback_1 before publishing /pong[4] . You have to tell CARET the node structure when you find such pitfall.","title":"use_latest_message"},{"location":"configuration/intra_node_data_path/#callback_chain","text":"callback_chain is introduced for CARET to map input messages to outputs based on inter-operation of multiple callback functions. Input messages are consumed in subscription callbacks and propagated to other nodes. It looks as if input messages passes chains of multiple callbacks to make output messages. With callback_chain , CARET take care of input propagation on callbacks and it is helpful to escape the limitation of use_latest_message as mentioned above. Next figure shows how CARET interprets intra-node data path using callback_chain . Intra-communication between subscription_callback_0 and timer_callback_1 is taken into account for defining intra-node data path. variable_passings is a tag used in CARET, and represents such intra-communication. The following timing chart shows how input messages are mapped to output messages. CARET maps mechanically messages of /pong topic to messages of /ping which finish being processed on subscription_callback_0 . The unexpected behavior of use_latest_message is improved by callback_chain . callback_chain looks the best choice. However, it has several drawbacks. It is not designed for node which have multiple callbacks running at parallel, and response time might be longer than actual It is not able to detect actual time when buffered data are consumed because only CARET does not trace user code on ROS 2 Users are expected to know node structure beforehand Info use_latest_message and callback_chain do not cover all of use cases for CARET. We, CARET development team, continue improvements of intra-node data path definition.","title":"callback_chain"},{"location":"configuration/intra_node_data_path/#python-api","text":"Python API is not implemented so far. Python API support is planned in 2023.","title":"Python API"},{"location":"configuration/intra_node_data_path/#architecture-file-editing","text":"This section explain how to add intra-node data path definition with editing an architecture file. The example issue above is used for explanation.","title":"Architecture file editing"},{"location":"configuration/intra_node_data_path/#use_latest_message_1","text":"Next sample description is required for using use_latest_message on an architecture file. use_latest_message is applied to /pong_node in the next sample description. Essential description is extracted in the following snippet, but you will confront with busy YAML file actually rather than the sample. You have to add use_latest_message as context_types between targeted subscription and publisher. - node_name: /pong_node callbacks: - callback_name: subscription_callback_0 - callback_name: timer_callback_1 publishes: - topic_name: /pong callback_names: - timer_callback_1 # manually added subscribes: - topic_name: /ping callback_name: subscription_callback_0 message_contexts: - context_type: use_latest_message # manually added subscription_topic_name: /ping publisher_topic_name: /pong","title":"use_latest_message"},{"location":"configuration/intra_node_data_path/#callback_chain_1","text":"On the other hand, CARET requires users to provide the following description if you apply callback_chain to /pong_node . - node_name: /pong_node callbacks: - callback_name: subscription_callback_0 - callback_name: timer_callback_1 variable_passings: - callback_name_write: subscription_callback_0 # manually added callback_name_read: timer_callback_1 # manually added publishes: - topic_name: /ping callback_names: - timer_callback_1 # manually added subscribes: - topic_name: /pong callback_name: timer_callback_1 message_contexts: - context_type: callback_chain # manually added subscription_topic_name: /pong publisher_topic_name: /ping User have to fill callback name in variable_passings , publishes 's callback_name . context_type must be set as callback_chain . After editing, use path.verify() described in the beginning of this section to verify that it has been set correctly.","title":"callback_chain"},{"location":"configuration/load_and_save/","text":"How to load and save an architecture object # The first step of configuration is to load an architecture object from a set of CTF-based recorded data onto memory. You can update the architecture object as the following section explains. After you finish updating it, you can save it to a yaml-based file, called \"architecture file\" to reuse the updated object. An architecture file has structure of a targeted application. dear_ros_node_viewer help you to comprehend structure of the application with the architecture file. Python API # CARET serves Python-based APIs to load and save an architecture object. All of the following code snippets can be executed after load environment variables with source /path/to/ros2_caret_ws/install/setup.bash . Load from a set of CTF-based recorded data # You can load an architecture object with Architecture constructor. from caret_analyze import Architecture arch = Architecture ( 'lttng' , '/path/to/ctf-based_recorded_data' ) You will find caret_analyze.architecture.Architecture -based object, named ' arch '. Loading an architecture object from CTF-based recorded data tends to be time-consuming task. Load from a YAML-based architecture file # As I mentioned, CARET serves a function to stored an architecture object into YAML-based architecture file for reusability. It can save loading time and preserve update of the object. You can load it from YAML-based file with only replacing ' lttng ' of the first argument of Architecture constructor by ' yaml '. from caret_analyze import Architecture arch = Architecture ( 'yaml' , '/path/to/architecture.yaml' ) It is recommended for you to use YAML-based file to benefit from reusability unless structure of targeted application is changed. Save # CARET provides Architecture.export method to save an architecture object as follow. # arch is caret_analyze.architecture.architecture.Architecture-based object arch . export ( '/path/to/destination/architecture.yaml' ) ! readlink - f / path / to / destination // architecture . yaml # /path/to/destination/architecture.yaml The argument of arch.export() is string type and means file path to store the arch object. In this sample, architecture.yaml will be created in /path/to/destination directory if the destination path is writable or another file of the same name does exist. arch.export() has the second argument, force , to allow you to overwrite the arch object into an existing file. The following sample shows how to overwrite. arch . export ( '/path/to/destination/architecture.yaml' , force = True ) ! readlink - f / path / to / destination // architecture . yaml # /path/to/destination/architecture.yaml force=True option erases the existing architecture object. CLI # Create an architecture file via CLI # With the functions I introduced above, you can create a YAML-based file including an architecture object. CARET serves CLI to create it as well. create_architecture_file command plays role of it. The following sample code shows how to use create_architecture_file command. source /path/to/ros2_caret_ws/install/setup.bash ros2 caret create_architecture_file /path/to/ctf-based_recorded_data -o /path/to/destination/architecture.yaml readlink -f /path/to/destination/architecture.yaml # /path/to/destination/architecture.yaml","title":"Load and save"},{"location":"configuration/load_and_save/#how-to-load-and-save-an-architecture-object","text":"The first step of configuration is to load an architecture object from a set of CTF-based recorded data onto memory. You can update the architecture object as the following section explains. After you finish updating it, you can save it to a yaml-based file, called \"architecture file\" to reuse the updated object. An architecture file has structure of a targeted application. dear_ros_node_viewer help you to comprehend structure of the application with the architecture file.","title":"How to load and save an architecture object"},{"location":"configuration/load_and_save/#python-api","text":"CARET serves Python-based APIs to load and save an architecture object. All of the following code snippets can be executed after load environment variables with source /path/to/ros2_caret_ws/install/setup.bash .","title":"Python API"},{"location":"configuration/load_and_save/#load-from-a-set-of-ctf-based-recorded-data","text":"You can load an architecture object with Architecture constructor. from caret_analyze import Architecture arch = Architecture ( 'lttng' , '/path/to/ctf-based_recorded_data' ) You will find caret_analyze.architecture.Architecture -based object, named ' arch '. Loading an architecture object from CTF-based recorded data tends to be time-consuming task.","title":"Load from a set of CTF-based recorded data"},{"location":"configuration/load_and_save/#load-from-a-yaml-based-architecture-file","text":"As I mentioned, CARET serves a function to stored an architecture object into YAML-based architecture file for reusability. It can save loading time and preserve update of the object. You can load it from YAML-based file with only replacing ' lttng ' of the first argument of Architecture constructor by ' yaml '. from caret_analyze import Architecture arch = Architecture ( 'yaml' , '/path/to/architecture.yaml' ) It is recommended for you to use YAML-based file to benefit from reusability unless structure of targeted application is changed.","title":"Load from a YAML-based architecture file"},{"location":"configuration/load_and_save/#save","text":"CARET provides Architecture.export method to save an architecture object as follow. # arch is caret_analyze.architecture.architecture.Architecture-based object arch . export ( '/path/to/destination/architecture.yaml' ) ! readlink - f / path / to / destination // architecture . yaml # /path/to/destination/architecture.yaml The argument of arch.export() is string type and means file path to store the arch object. In this sample, architecture.yaml will be created in /path/to/destination directory if the destination path is writable or another file of the same name does exist. arch.export() has the second argument, force , to allow you to overwrite the arch object into an existing file. The following sample shows how to overwrite. arch . export ( '/path/to/destination/architecture.yaml' , force = True ) ! readlink - f / path / to / destination // architecture . yaml # /path/to/destination/architecture.yaml force=True option erases the existing architecture object.","title":"Save"},{"location":"configuration/load_and_save/#cli","text":"","title":"CLI"},{"location":"configuration/load_and_save/#create-an-architecture-file-via-cli","text":"With the functions I introduced above, you can create a YAML-based file including an architecture object. CARET serves CLI to create it as well. create_architecture_file command plays role of it. The following sample code shows how to use create_architecture_file command. source /path/to/ros2_caret_ws/install/setup.bash ros2 caret create_architecture_file /path/to/ctf-based_recorded_data -o /path/to/destination/architecture.yaml readlink -f /path/to/destination/architecture.yaml # /path/to/destination/architecture.yaml","title":"Create an architecture file via CLI"},{"location":"configuration/visualize_application_structure/","text":"Visualize application structure # This section is not still available. dear_ros_node_viewer will be introduced.","title":"Visualize application structure"},{"location":"configuration/visualize_application_structure/#visualize-application-structure","text":"This section is not still available. dear_ros_node_viewer will be introduced.","title":"Visualize application structure"},{"location":"design/","text":"The design section describes the internals of CARET. The following figure shows the tracing flow with each package added. CARET records data, which include timestamps, from tracepoints embedded in user applications, ROS 2 and DDS. The data are stored as \"Trace Data\". CARET analyzes the Trace Data and provides the results to the developer. This design section describes policies and internal processes for each step listed below. Recording phase Runtime processing Tracepoints Configuration phase Configuration Analyzing phase Processing trace data Visualization In addition, the followings are explained. Software architecture Latency definition Limits and constraints See also CARET analyze API document","title":"Design"},{"location":"design/configuration/","text":"Configuration # CARET requires several kinds of information for visualization. Configuration set up the information needed for visualization. Some of the information can be configured via Python API and jupyter, but there are also items that require direct modification of the architecture file. For the format of the architecture file, see architecture file for the format of the architecture file.","title":"Configuration"},{"location":"design/configuration/#configuration","text":"CARET requires several kinds of information for visualization. Configuration set up the information needed for visualization. Some of the information can be configured via Python API and jupyter, but there are also items that require direct modification of the architecture file. For the format of the architecture file, see architecture file for the format of the architecture file.","title":"Configuration"},{"location":"design/configuration/architecture_file/","text":"Architecture file # An architecture file is a yaml file with the necessary information for visualization. An architecture file contains the following information Definition of the node-path to be measured Information about the structure of the software to be measured Executor information Node information (e.g. node latency definition) File format # A sample of the architecture file is as follows. Key Type Required? Auto generate? (Configuration method) Note / Description named_paths List Yes Yes Path definitions to evaluate. \u2003 path_name String Yes No (Edit via Python-API) \u2003 node_chain List Yes No (Edit via Python-API) \u2003 \u2003 node_name String Yes No (Edit via Python-API) \u2003 \u2003 publish_topic_name String Required if node is not end of the path. No (Edit via Python-API) \u2003 \u2003 subscribe_topic_name String Required if node is not start of the path. No (Edit via Python-API) executors List Yes Yes \u2003 executor_type String Yes Yes single_threaded_executor / multi_threaded_executor \u2003 executor_name String Yes Yes \u2003 callback_group_names List(String) Yes Yes nodes List Yes Yes \u2003 node_name String Yes Yes \u2003 callback_groups List Yes Yes \u2003 \u2003 callback_group_type String Yes Yes mutually_exclusive / reentrant \u2003 \u2003 callback_group_name String Yes Yes \u2003 callbacks List Yes Yes \u2003 \u2003 callback_type String Yes Yes timer_callback / subscription_callback \u2003 \u2003 symbol String Yes Yes symbol for callback function. \u2003 \u2003 period_ns int Required for timer_callback only. Yes \u2003 \u2003 topic_name String Required for subscription_callback only. Yes \u2003 variable_passings List No Yes \u2003 \u2003 callback_name_write String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 callback_name_read String No No (Edit architecture file) default value = UNDEFINED \u2003 publishes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_names List(String) No No (Edit architecture file) callbacks which publish the topic. \u2003 subscribes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_name String No Yes \u2003 message_contexts List No Yes Field to define node latency \u2003 \u2003 context_type String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 subscription_topic_name String No Yes \u2003 \u2003 publisher_topic_name String No Yes Sample # A sample of the architecture file is as follows. named_paths : - path_name : target_path node_chain : - node_name : /ping_node publish_topic_name : /chatter subscribe_topic_name : UNDEFINED - node_name : /pong_node publish_topic_name : UNDEFINED subscribe_topic_name : /chatter executors : - executor_type : single_threaded_executor executor_name : executor_0 callback_group_names : - /ping_node/callback_group_0 - /pong_node/callback_group_0 nodes : - node_name : /ping_node callback_groups : - callback_group_type : mutually_exclusive callback_group_name : /ping_node/callback_group_0 callback_names : - /ping_node/callback_0 callbacks : - callback_name : subscription_callback_0 type : subscription_callback topic_name : /topic3 symbol : Node::{lambda()} - callback_name : timer_callback_0 type : timer_callback period_ns : 100000000 symbol : Node::{lambda()} variable_passings : - callback_name_write : subscription_callback_0 callback_name_read : timer_callback_0 publishes : - topic_name : /ping callback_names : - timer_callback_0 subscribes : - topic_name : /pong callback_name : timer_callback_0 message_contexts : - context_type : use_latest_message subscription_topic_name : /pong publisher_topic_name : /ping","title":"Architecture file"},{"location":"design/configuration/architecture_file/#architecture-file","text":"An architecture file is a yaml file with the necessary information for visualization. An architecture file contains the following information Definition of the node-path to be measured Information about the structure of the software to be measured Executor information Node information (e.g. node latency definition)","title":"Architecture file"},{"location":"design/configuration/architecture_file/#file-format","text":"A sample of the architecture file is as follows. Key Type Required? Auto generate? (Configuration method) Note / Description named_paths List Yes Yes Path definitions to evaluate. \u2003 path_name String Yes No (Edit via Python-API) \u2003 node_chain List Yes No (Edit via Python-API) \u2003 \u2003 node_name String Yes No (Edit via Python-API) \u2003 \u2003 publish_topic_name String Required if node is not end of the path. No (Edit via Python-API) \u2003 \u2003 subscribe_topic_name String Required if node is not start of the path. No (Edit via Python-API) executors List Yes Yes \u2003 executor_type String Yes Yes single_threaded_executor / multi_threaded_executor \u2003 executor_name String Yes Yes \u2003 callback_group_names List(String) Yes Yes nodes List Yes Yes \u2003 node_name String Yes Yes \u2003 callback_groups List Yes Yes \u2003 \u2003 callback_group_type String Yes Yes mutually_exclusive / reentrant \u2003 \u2003 callback_group_name String Yes Yes \u2003 callbacks List Yes Yes \u2003 \u2003 callback_type String Yes Yes timer_callback / subscription_callback \u2003 \u2003 symbol String Yes Yes symbol for callback function. \u2003 \u2003 period_ns int Required for timer_callback only. Yes \u2003 \u2003 topic_name String Required for subscription_callback only. Yes \u2003 variable_passings List No Yes \u2003 \u2003 callback_name_write String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 callback_name_read String No No (Edit architecture file) default value = UNDEFINED \u2003 publishes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_names List(String) No No (Edit architecture file) callbacks which publish the topic. \u2003 subscribes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_name String No Yes \u2003 message_contexts List No Yes Field to define node latency \u2003 \u2003 context_type String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 subscription_topic_name String No Yes \u2003 \u2003 publisher_topic_name String No Yes","title":"File format"},{"location":"design/configuration/architecture_file/#sample","text":"A sample of the architecture file is as follows. named_paths : - path_name : target_path node_chain : - node_name : /ping_node publish_topic_name : /chatter subscribe_topic_name : UNDEFINED - node_name : /pong_node publish_topic_name : UNDEFINED subscribe_topic_name : /chatter executors : - executor_type : single_threaded_executor executor_name : executor_0 callback_group_names : - /ping_node/callback_group_0 - /pong_node/callback_group_0 nodes : - node_name : /ping_node callback_groups : - callback_group_type : mutually_exclusive callback_group_name : /ping_node/callback_group_0 callback_names : - /ping_node/callback_0 callbacks : - callback_name : subscription_callback_0 type : subscription_callback topic_name : /topic3 symbol : Node::{lambda()} - callback_name : timer_callback_0 type : timer_callback period_ns : 100000000 symbol : Node::{lambda()} variable_passings : - callback_name_write : subscription_callback_0 callback_name_read : timer_callback_0 publishes : - topic_name : /ping callback_names : - timer_callback_0 subscribes : - topic_name : /pong callback_name : timer_callback_0 message_contexts : - context_type : use_latest_message subscription_topic_name : /pong publisher_topic_name : /ping","title":"Sample"},{"location":"design/latency_definitions/","text":"Latency definition # CARET mainly measures the following Callback latency Communication latency Node latency Path latency The simplified sequence diagram shown below illustrates each definition. Here, the horizontal axis represents time and the vertical axis represents layers. The red line represents message flow. A message is received in the subscription callback and the processed data is published to the next node. In this way, information is propagated from the sensor node to the actuator node. CARET samples events for latency calculation. The following three items are main types of the events. Callback start Callback end Publish Difference of timestamp between two events are corresponded to latency. For a more detailed definition, see Callback Communication Node Path CARET provides time series data of events through Python objects. Time series data can be retrieved with the Python objects which have to_dataframe API. All objects capable of retrieving time-series data are listed below. Target Configuration required? Path Yes NodePath Yes Communication No Callback No Publisher No Subscription No Timer No Here, for Path and NodePath, definitions must be given manually. For details on setting the definitions, see Configuration . Detailed Sequence # Below is a detailed sequence diagram of the SingleThreadedExecutor, from publish in the callback to the execution of the subscription callback. Here, each element indicates the following UserCode is a callback ROS2 is rclcpp, rcl, and rmw DDS is FastDDS or CycloneDDS LTTng is the output destination for tracepoints Within the spin of Subscription, the executable callbacks are executed sequentially. In this way, the executor schedules callbacks. If there are multiple executable callbacks, they are executed sequentially, so other callbacks may have to wait. Info There have been many different proposals for schedulers, and the information provided above may not be up-to-date. Please keep in mind that system performance will vary depending on the scheduler you choose.","title":"Latency definition"},{"location":"design/latency_definitions/#latency-definition","text":"CARET mainly measures the following Callback latency Communication latency Node latency Path latency The simplified sequence diagram shown below illustrates each definition. Here, the horizontal axis represents time and the vertical axis represents layers. The red line represents message flow. A message is received in the subscription callback and the processed data is published to the next node. In this way, information is propagated from the sensor node to the actuator node. CARET samples events for latency calculation. The following three items are main types of the events. Callback start Callback end Publish Difference of timestamp between two events are corresponded to latency. For a more detailed definition, see Callback Communication Node Path CARET provides time series data of events through Python objects. Time series data can be retrieved with the Python objects which have to_dataframe API. All objects capable of retrieving time-series data are listed below. Target Configuration required? Path Yes NodePath Yes Communication No Callback No Publisher No Subscription No Timer No Here, for Path and NodePath, definitions must be given manually. For details on setting the definitions, see Configuration .","title":"Latency definition"},{"location":"design/latency_definitions/#detailed-sequence","text":"Below is a detailed sequence diagram of the SingleThreadedExecutor, from publish in the callback to the execution of the subscription callback. Here, each element indicates the following UserCode is a callback ROS2 is rclcpp, rcl, and rmw DDS is FastDDS or CycloneDDS LTTng is the output destination for tracepoints Within the spin of Subscription, the executable callbacks are executed sequentially. In this way, the executor schedules callbacks. If there are multiple executable callbacks, they are executed sequentially, so other callbacks may have to wait. Info There have been many different proposals for schedulers, and the information provided above may not be up-to-date. Please keep in mind that system performance will vary depending on the scheduler you choose.","title":"Detailed Sequence"},{"location":"design/latency_definitions/callback/","text":"Callback # Callback latency is defined as duration between beginning and end of callback execution. These events are represented as callback_start and callback_end , respectively. l_{\\rm{callback}} = t_{\\rm{callback\\ end}} - t_{\\rm{callback\\ start}} l_{\\rm{callback}} = t_{\\rm{callback\\ end}} - t_{\\rm{callback\\ start}} The sequence diagram shows how CARET rclcpp pick up two events; callback_start and callback_end. to_dataframe API returns following columns. Column Type Description callback_start System time Callback start time callback_end System time Callback end time See also Trace points | Callback Start Trace points | Callback End RuntimeDataProvider API","title":"Callback"},{"location":"design/latency_definitions/callback/#callback","text":"Callback latency is defined as duration between beginning and end of callback execution. These events are represented as callback_start and callback_end , respectively. l_{\\rm{callback}} = t_{\\rm{callback\\ end}} - t_{\\rm{callback\\ start}} l_{\\rm{callback}} = t_{\\rm{callback\\ end}} - t_{\\rm{callback\\ start}} The sequence diagram shows how CARET rclcpp pick up two events; callback_start and callback_end. to_dataframe API returns following columns. Column Type Description callback_start System time Callback start time callback_end System time Callback end time See also Trace points | Callback Start Trace points | Callback End RuntimeDataProvider API","title":"Callback"},{"location":"design/latency_definitions/communication/","text":"Communication # Communication latency is an expression of how much time it takes for a topic message to travel from source callback to next callback. l_{comm} = t_{sub} - t_{pub} l_{comm} = t_{sub} - t_{pub} Info In this definition, communication latency is affected by the scheduling of callbacks, and includes not only the communication latency of the DDS, but also the delay due to scheduling. For example, if multiple callbacks are dispatched simultaneously, the communication latency may include the execution time of other callbacks. For more information on scheduling, see latency_definitions | overview . Info You may think that the definition of communication latency is complicated. The reason for defining it based on callback ownership is that this same definition will apply to future latency calculations involving tf. Even when CARET supports latency where information is exchanged other than publish-subscribe, the responsibility of the node developer is the node and the callback is the implementation. In order to provide latency based on the scope of responsibility, CARET uses this definition. ROS communication is performed by the subscription side for intra-process communication and inter-process communication. Since ROS communication is capable of many-to-many communication, there are cases where both intra-process and inter-process communication are performed in a single publish. In CARET, communication is divided into 1:1 pairs and latency is calculated. Intra process communication # A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. callback_start_timestamp System time Callback start time See also Trace points | rclcpp_intra_publish Trace points | dispatch_intra_process_subscription_callback Trace points | callback start Trace points | message_construct RuntimeDataProvider API Inter process communication # A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. rcl_publish_timestamp System time Publish time in rcl. dds_write_timestamp System time Publish time in rmw. callback_start_timestamp System time Callback start time. See also Trace points | message_construct Trace points | rclcpp_publish Trace points | rcl_publish Trace points | dds_write Trace points | bind_addr_to_addr Trace points | bind_addr_to_stamp Trace points | callback start Trace points | dispatch_subscription_callback RuntimeDataProvider API","title":"Communication"},{"location":"design/latency_definitions/communication/#communication","text":"Communication latency is an expression of how much time it takes for a topic message to travel from source callback to next callback. l_{comm} = t_{sub} - t_{pub} l_{comm} = t_{sub} - t_{pub} Info In this definition, communication latency is affected by the scheduling of callbacks, and includes not only the communication latency of the DDS, but also the delay due to scheduling. For example, if multiple callbacks are dispatched simultaneously, the communication latency may include the execution time of other callbacks. For more information on scheduling, see latency_definitions | overview . Info You may think that the definition of communication latency is complicated. The reason for defining it based on callback ownership is that this same definition will apply to future latency calculations involving tf. Even when CARET supports latency where information is exchanged other than publish-subscribe, the responsibility of the node developer is the node and the callback is the implementation. In order to provide latency based on the scope of responsibility, CARET uses this definition. ROS communication is performed by the subscription side for intra-process communication and inter-process communication. Since ROS communication is capable of many-to-many communication, there are cases where both intra-process and inter-process communication are performed in a single publish. In CARET, communication is divided into 1:1 pairs and latency is calculated.","title":"Communication"},{"location":"design/latency_definitions/communication/#intra-process-communication","text":"A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. callback_start_timestamp System time Callback start time See also Trace points | rclcpp_intra_publish Trace points | dispatch_intra_process_subscription_callback Trace points | callback start Trace points | message_construct RuntimeDataProvider API","title":"Intra process communication"},{"location":"design/latency_definitions/communication/#inter-process-communication","text":"A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. rcl_publish_timestamp System time Publish time in rcl. dds_write_timestamp System time Publish time in rmw. callback_start_timestamp System time Callback start time. See also Trace points | message_construct Trace points | rclcpp_publish Trace points | rcl_publish Trace points | dds_write Trace points | bind_addr_to_addr Trace points | bind_addr_to_stamp Trace points | callback start Trace points | dispatch_subscription_callback RuntimeDataProvider API","title":"Inter process communication"},{"location":"design/latency_definitions/node/","text":"Node # Node latency is the time difference between when a callback takes ownership and when it abandons. l_{node} = t_{transfer} - t_{receive} l_{node} = t_{transfer} - t_{receive} In particular, if transfer of ownership is subscribe and receive of ownership is publish, it is defined as follows l_{node} = t_{pub} - t_{sub} l_{node} = t_{pub} - t_{sub} See Communication for the reason ownership is used to define latency. Message context # A node receives a message, processes it, and then publishes it to a subsequent node. The dependency between the subscribed and published messages is used to define node latency. In the following sections explain the message dependency (message context), which is the concept of node latency. For example, consider the following callback. auto subsription_callback = []( & msg ){ msg_ = f ( msg ); pub . publish ( msg_ ); } In this case, the received message is processed and published immediately. The dependency of the message at this time is described in chronological order and is expressed as follows. Here, the time difference between Subscribe and Publish can be calculated as node latency. In this way, node latency can be calculated when message dependencies are defined. 6 In the previous example, we presented a case where a node is subscribed and immediately published. In actuality, the Message context can be quite complex, because node processing can be defined by the developer. Each case is described below. Buffering, for example, is a buffer delay process. Multiple use is for moving average processing, for example. There are multiple candidates for node latency. Unused is a message that has not been published and has not been used. This is evaluated as a kind of message drop. Cross can occur in cases where messages are retrieved based on the timestamp of the message rather than the system time. In either case, it is difficult to automatically determine the message context. In some cases this can be covered by Configuration. For more information, see Configuration for details. If Configuration does not cover the situation, we are considering a mechanism to allow users to describe message dependencies as a future plan. For details, please refer to TILDE for details.","title":"Node"},{"location":"design/latency_definitions/node/#node","text":"Node latency is the time difference between when a callback takes ownership and when it abandons. l_{node} = t_{transfer} - t_{receive} l_{node} = t_{transfer} - t_{receive} In particular, if transfer of ownership is subscribe and receive of ownership is publish, it is defined as follows l_{node} = t_{pub} - t_{sub} l_{node} = t_{pub} - t_{sub} See Communication for the reason ownership is used to define latency.","title":"Node"},{"location":"design/latency_definitions/node/#message-context","text":"A node receives a message, processes it, and then publishes it to a subsequent node. The dependency between the subscribed and published messages is used to define node latency. In the following sections explain the message dependency (message context), which is the concept of node latency. For example, consider the following callback. auto subsription_callback = []( & msg ){ msg_ = f ( msg ); pub . publish ( msg_ ); } In this case, the received message is processed and published immediately. The dependency of the message at this time is described in chronological order and is expressed as follows. Here, the time difference between Subscribe and Publish can be calculated as node latency. In this way, node latency can be calculated when message dependencies are defined. 6 In the previous example, we presented a case where a node is subscribed and immediately published. In actuality, the Message context can be quite complex, because node processing can be defined by the developer. Each case is described below. Buffering, for example, is a buffer delay process. Multiple use is for moving average processing, for example. There are multiple candidates for node latency. Unused is a message that has not been published and has not been used. This is evaluated as a kind of message drop. Cross can occur in cases where messages are retrieved based on the timestamp of the message rather than the system time. In either case, it is difficult to automatically determine the message context. In some cases this can be covered by Configuration. For more information, see Configuration for details. If Configuration does not cover the situation, we are considering a mechanism to allow users to describe message dependencies as a future plan. For details, please refer to TILDE for details.","title":"Message context"},{"location":"design/latency_definitions/path/","text":"Path # Path latency is the sum of node latency and communication latency included in the path. l_{path} = \\sum_{\\in path} l_{node} + \\sum_{\\in path} l_{comm} \\\\ l_{node} = t_{pub} - t_{sub} \\\\ l_{comm} = t_{sub} - t_{pub} \\\\ l_{path} = \\sum_{\\in path} l_{node} + \\sum_{\\in path} l_{comm} \\\\ l_{node} = t_{pub} - t_{sub} \\\\ l_{comm} = t_{sub} - t_{pub} \\\\ Here, path is one of the paths chosen from the node graph. In CARET, the path is defined as [node_name]-[topic_name]-... -[topic_name]-[node_name] . For example, in the following case, the path definition is [A]-[/a]-[C]-[/e]-[E] . Info In the above definition, the start time of the latency is the start node's Publish and the end time of the latency measurement is the end node's Subscribe. When trying to measure a actual system, it is desirable to be able to define various start and end times depending on the implementation. For example, the start time might be more appropriately a stamp value in the sensor message. It's current issue to support for such more precise latency.","title":"Path"},{"location":"design/latency_definitions/path/#path","text":"Path latency is the sum of node latency and communication latency included in the path. l_{path} = \\sum_{\\in path} l_{node} + \\sum_{\\in path} l_{comm} \\\\ l_{node} = t_{pub} - t_{sub} \\\\ l_{comm} = t_{sub} - t_{pub} \\\\ l_{path} = \\sum_{\\in path} l_{node} + \\sum_{\\in path} l_{comm} \\\\ l_{node} = t_{pub} - t_{sub} \\\\ l_{comm} = t_{sub} - t_{pub} \\\\ Here, path is one of the paths chosen from the node graph. In CARET, the path is defined as [node_name]-[topic_name]-... -[topic_name]-[node_name] . For example, in the following case, the path definition is [A]-[/a]-[C]-[/e]-[E] . Info In the above definition, the start time of the latency is the start node's Publish and the end time of the latency measurement is the end node's Subscribe. When trying to measure a actual system, it is desirable to be able to define various start and end times depending on the implementation. For example, the start time might be more appropriately a stamp value in the sensor message. It's current issue to support for such more precise latency.","title":"Path"},{"location":"design/latency_definitions/publisher/","text":"Publisher # The Publisher provides the time and relevant information when publishing. A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description rclcpp_publish_timestamp System time min(rclcpp_intra_publish_timestamp, rclcpp_publish_timestamp) rclcpp_intra_publish_timestamp System time (Optional) Publish time of intra-process communication rclcpp_publish_timestamp System time (Optional) Publish time of inter-process communication in rclcpp rcl_publish_timestamp System time(Optional) Publish time of inter-process communication in rcl dds_write_timestamp System time(Optional) Publish time of inter-process communication in rmw message_timestamp Message data Time of header.stamp. Zero when header is not defined. source timestamp Depends on DDS (Optional) Timestamp to used for binding with subscription. See also Trace points | rclcpp_intra_publish Trace points | message_construct Trace points | rclcpp_publish Trace points | rcl_publish Trace points | dds_write Trace points | bind_addr_to_addr Trace points | bind_addr_to_stamp","title":"Publisher"},{"location":"design/latency_definitions/publisher/#publisher","text":"The Publisher provides the time and relevant information when publishing. A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description rclcpp_publish_timestamp System time min(rclcpp_intra_publish_timestamp, rclcpp_publish_timestamp) rclcpp_intra_publish_timestamp System time (Optional) Publish time of intra-process communication rclcpp_publish_timestamp System time (Optional) Publish time of inter-process communication in rclcpp rcl_publish_timestamp System time(Optional) Publish time of inter-process communication in rcl dds_write_timestamp System time(Optional) Publish time of inter-process communication in rmw message_timestamp Message data Time of header.stamp. Zero when header is not defined. source timestamp Depends on DDS (Optional) Timestamp to used for binding with subscription. See also Trace points | rclcpp_intra_publish Trace points | message_construct Trace points | rclcpp_publish Trace points | rcl_publish Trace points | dds_write Trace points | bind_addr_to_addr Trace points | bind_addr_to_stamp","title":"Publisher"},{"location":"design/latency_definitions/subscription/","text":"Subscription # Inter process communication # A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS Timestamp to used for binding with subscription. See also Subscription API Trace points | dispatch_subscription_callback Trace points | callback_start Intra process communication # to_dataframe API returns following columns. Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS (Optional) NaN. See also Subscription API Trace points | dispatch_intra_process_subscription_callback Trace points | callback_start","title":"Subscription"},{"location":"design/latency_definitions/subscription/#subscription","text":"","title":"Subscription"},{"location":"design/latency_definitions/subscription/#inter-process-communication","text":"A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS Timestamp to used for binding with subscription. See also Subscription API Trace points | dispatch_subscription_callback Trace points | callback_start","title":"Inter process communication"},{"location":"design/latency_definitions/subscription/#intra-process-communication","text":"to_dataframe API returns following columns. Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS (Optional) NaN. See also Subscription API Trace points | dispatch_intra_process_subscription_callback Trace points | callback_start","title":"Intra process communication"},{"location":"design/latency_definitions/timer/","text":"Timer # Timer provides the time at which the Timer callback timeout and related information. A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description timer_event_timestamp System time Timer timeout. callback_start_timestamp System time Callback start time callback_end_timestamp System time Callback end time Here, the timer firing time is calculated by the following, t_{timeout} = t_{init} + n \\times t_{period} t_{timeout} = t_{init} + n \\times t_{period} See also Timer API Trace point | callback_start Trace point | callback_end Trace point | rcl_timer_init","title":"Timer"},{"location":"design/latency_definitions/timer/#timer","text":"Timer provides the time at which the Timer callback timeout and related information. A simplified sequence diagram focusing only on the relevant data flow is shown below. to_dataframe API returns following columns. Column Type Description timer_event_timestamp System time Timer timeout. callback_start_timestamp System time Callback start time callback_end_timestamp System time Callback end time Here, the timer firing time is calculated by the following, t_{timeout} = t_{init} + n \\times t_{period} t_{timeout} = t_{init} + n \\times t_{period} See also Timer API Trace point | callback_start Trace point | callback_end Trace point | rcl_timer_init","title":"Timer"},{"location":"design/limits_and_constraints/","text":"Limits and constraints # Environment # CARET only supports environments as follows. Support single host. FastDDS or CycloneDDS. Support for Linux. Support for Galactic and Humble. Require rebuilding of an application. ROS 2 functions # CARET cannot support functions as follows. /rosout and /parameter_event topic Services Actions Implementation # CARET cannot support implementations as follows. There exist several nodes which have the same namespace and node name. wrapper for ROS layers. Reentrant callback group.","title":"Limits and constraints"},{"location":"design/limits_and_constraints/#limits-and-constraints","text":"","title":"Limits and constraints"},{"location":"design/limits_and_constraints/#environment","text":"CARET only supports environments as follows. Support single host. FastDDS or CycloneDDS. Support for Linux. Support for Galactic and Humble. Require rebuilding of an application.","title":"Environment"},{"location":"design/limits_and_constraints/#ros-2-functions","text":"CARET cannot support functions as follows. /rosout and /parameter_event topic Services Actions","title":"ROS 2 functions"},{"location":"design/limits_and_constraints/#implementation","text":"CARET cannot support implementations as follows. There exist several nodes which have the same namespace and node name. wrapper for ROS layers. Reentrant callback group.","title":"Implementation"},{"location":"design/processing_trace_data/","text":"Processing trace data # CARET processes Trace Data to provide latency to the user. This section describes the Trace Data processing process. The class that reads TraceData is the Records object. Records The following are processing using Records object. Period Frequency Latency Response time See also Latency definition caret_analyze Software architecture | caret_analyze","title":"Processing trace data"},{"location":"design/processing_trace_data/#processing-trace-data","text":"CARET processes Trace Data to provide latency to the user. This section describes the Trace Data processing process. The class that reads TraceData is the Records object. Records The following are processing using Records object. Period Frequency Latency Response time See also Latency definition caret_analyze Software architecture | caret_analyze","title":"Processing trace data"},{"location":"design/processing_trace_data/records/","text":"Records Object # CARET stores trace data as a table as shown below. callback_start_timestamp callback_end_timestamp 0 0.1 1 1.1 2 2.1 ... ... This table is processed to calculate latency, period, etc (See Records Service ). To create the above table, merging processes are performed with the traced results. In addition to general table join processing, CARET defines classes which has originally defined join processing for latency calculation. This sections describes the main APIs provided by the record object. merge merge_sequential merge_sequential_for_addr_track to_dataframe merge # This is an inner join and outer join of general tables. In particular, it is used to join initialization-related trace data that can be bound by address only. See also API:merge merge_sequential # This is a chronological merge. It is especially used to merge sequential processing by threads. CARET mainly performs this merging and calculates latency. See also API:merge Callback Latency Definition merge_sequential_for_addr_track # This merge is used when binding is done based on addresses and copying occurs in the middle of the process. See also API:merge_sequential_for_addr_track Warning This merge is slow and causes inconsistencies when nodes not using caret-rclcpp are published. As much as possible, trace points should be designed so that merge_sequential is sufficient. to_dataframe # Function to convert to a pandas.DataFrame. This is especially useful for unique visualization and evaluation by developers.","title":"Records Object"},{"location":"design/processing_trace_data/records/#records-object","text":"CARET stores trace data as a table as shown below. callback_start_timestamp callback_end_timestamp 0 0.1 1 1.1 2 2.1 ... ... This table is processed to calculate latency, period, etc (See Records Service ). To create the above table, merging processes are performed with the traced results. In addition to general table join processing, CARET defines classes which has originally defined join processing for latency calculation. This sections describes the main APIs provided by the record object. merge merge_sequential merge_sequential_for_addr_track to_dataframe","title":"Records Object"},{"location":"design/processing_trace_data/records/#merge","text":"This is an inner join and outer join of general tables. In particular, it is used to join initialization-related trace data that can be bound by address only. See also API:merge","title":"merge"},{"location":"design/processing_trace_data/records/#merge_sequential","text":"This is a chronological merge. It is especially used to merge sequential processing by threads. CARET mainly performs this merging and calculates latency. See also API:merge Callback Latency Definition","title":"merge_sequential"},{"location":"design/processing_trace_data/records/#merge_sequential_for_addr_track","text":"This merge is used when binding is done based on addresses and copying occurs in the middle of the process. See also API:merge_sequential_for_addr_track Warning This merge is slow and causes inconsistencies when nodes not using caret-rclcpp are published. As much as possible, trace points should be designed so that merge_sequential is sufficient.","title":"merge_sequential_for_addr_track"},{"location":"design/processing_trace_data/records/#to_dataframe","text":"Function to convert to a pandas.DataFrame. This is especially useful for unique visualization and evaluation by developers.","title":"to_dataframe"},{"location":"design/processing_trace_data/records_service/","text":"Records service # The Records object holds time-series data such as message flow in a table as shown below. Start timestamp ... End timestamp 0.0 ... 0.1 1.0 ... 1.1 2.0 ... NaN 3.0 ... 2.1 ... ... ... The start_timestamp column contains the system time at the starting point. The end_timestamp column contains the system time at the end point. Both columns indicate the system time, and if there is no corresponding value for start, the value is NaN. For the intermediate columns, the time at the intermediate point between start and end is represented. This table representation can be used for various measurement targets such as callbacks, nodes, and paths. The rows of the table are visualized as lines in a message flow diagram. This section describes the process o The class that reads TraceData is the Records object. Records The following are processing using Records object. Period Frequency Latency Response time See also Latency definition See also Records Period # The period is defined as the time difference between the columns of interest. period_n = t_{n} -t_{n-1} period_n = t_{n} -t_{n-1} Example # Input Start timestamp 0.0 1.0 2.0 3.0 ... Output Timestamp Period 0.0 1.0 1.0 1.0 2.0 1.0 ... ... See also API Reference | Period Frequency # Frequency is defined as the number of events that occur in one second. Example # Input Start timestamp 0.0 0.1 0.5 1.2 1.3 2.3 ... Output Timestamp Period 0.0 3.0 1.0 2.0 ... ... Latency # Latency is defined as the time difference between the two columns of interest. latency_n = t^{end}_{n} - t^{start}_{n} latency_n = t^{end}_{n} - t^{start}_{n} Example # Input Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.1 ... ... Output Start timestamp Latency 0.0 0.1 1.0 0.1 3.0 0.1 ... ... Response Time # Response time is the amount of time it takes for a system to respond to an input. As shown above, latency can be calculated if a table can be constructed. However, the calculated latency is not suitable for evaluating response time. For example, if a sensor is driven at 10 Hz, a latency of up to 100 ms should be considered. CARET defines latency as the best-case response time and worst-case response time as the value that includes the delay due to cycles, as a more comprehensive approach. Example # Input Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.2 4.0 4.3 ... ... Intermediate Create intermediate data for when the interval in Start timestamp [0.0, 4.0] maps to End timestamp. Start timestamp End timestamp [0.0, 1.0) 1.1 [1.0, 3.0) 3.2 [3.0, 4.0) 4.3 Output Start timestamp Best-case response time Worst-case response time 1.0 0.1 (1.1 - 1.0) 1.1 (1.1 - 0.0) 3.0 0.2 (3.2 - 3.0) 2.3 (3.2 - 1.0) ... ... ... Note that Best-case response time has the same definition as Latency. Worst-case response time also counts as response time in the case of a drop. Visualize response time # Cases like the one shown above include Cases where multiple latencies are defined for a single output Message dropping Crossing Branching Some of these can be pessimistically large when it comes to latency. The diagram above describes the table as follows Start timestamp End timestamp 0.0 2.0 0.5 2.5 2.0 3.5 3.0 3.5 4.0 5.0 4.5 7.0 5.5 6.0 5.5 6.5 After leaving only the best-case flows as shown in the figure below, the best-case is calculated as the latency of the line and the worst-case as the latency calculated from the previous input. The response time after processing is shown below. Start timestamp Min response time Max response time 0.0 2.0 2.5 0.5 0.5 3.0 3.0 1.0 2.0 4.0 0.5 2.0 See also FAQ | How response time is calculated?","title":"Records service"},{"location":"design/processing_trace_data/records_service/#records-service","text":"The Records object holds time-series data such as message flow in a table as shown below. Start timestamp ... End timestamp 0.0 ... 0.1 1.0 ... 1.1 2.0 ... NaN 3.0 ... 2.1 ... ... ... The start_timestamp column contains the system time at the starting point. The end_timestamp column contains the system time at the end point. Both columns indicate the system time, and if there is no corresponding value for start, the value is NaN. For the intermediate columns, the time at the intermediate point between start and end is represented. This table representation can be used for various measurement targets such as callbacks, nodes, and paths. The rows of the table are visualized as lines in a message flow diagram. This section describes the process o The class that reads TraceData is the Records object. Records The following are processing using Records object. Period Frequency Latency Response time See also Latency definition See also Records","title":"Records service"},{"location":"design/processing_trace_data/records_service/#period","text":"The period is defined as the time difference between the columns of interest. period_n = t_{n} -t_{n-1} period_n = t_{n} -t_{n-1}","title":"Period"},{"location":"design/processing_trace_data/records_service/#example","text":"Input Start timestamp 0.0 1.0 2.0 3.0 ... Output Timestamp Period 0.0 1.0 1.0 1.0 2.0 1.0 ... ... See also API Reference | Period","title":"Example"},{"location":"design/processing_trace_data/records_service/#frequency","text":"Frequency is defined as the number of events that occur in one second.","title":"Frequency"},{"location":"design/processing_trace_data/records_service/#example_1","text":"Input Start timestamp 0.0 0.1 0.5 1.2 1.3 2.3 ... Output Timestamp Period 0.0 3.0 1.0 2.0 ... ...","title":"Example"},{"location":"design/processing_trace_data/records_service/#latency","text":"Latency is defined as the time difference between the two columns of interest. latency_n = t^{end}_{n} - t^{start}_{n} latency_n = t^{end}_{n} - t^{start}_{n}","title":"Latency"},{"location":"design/processing_trace_data/records_service/#example_2","text":"Input Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.1 ... ... Output Start timestamp Latency 0.0 0.1 1.0 0.1 3.0 0.1 ... ...","title":"Example"},{"location":"design/processing_trace_data/records_service/#response-time","text":"Response time is the amount of time it takes for a system to respond to an input. As shown above, latency can be calculated if a table can be constructed. However, the calculated latency is not suitable for evaluating response time. For example, if a sensor is driven at 10 Hz, a latency of up to 100 ms should be considered. CARET defines latency as the best-case response time and worst-case response time as the value that includes the delay due to cycles, as a more comprehensive approach.","title":"Response Time"},{"location":"design/processing_trace_data/records_service/#example_3","text":"Input Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.2 4.0 4.3 ... ... Intermediate Create intermediate data for when the interval in Start timestamp [0.0, 4.0] maps to End timestamp. Start timestamp End timestamp [0.0, 1.0) 1.1 [1.0, 3.0) 3.2 [3.0, 4.0) 4.3 Output Start timestamp Best-case response time Worst-case response time 1.0 0.1 (1.1 - 1.0) 1.1 (1.1 - 0.0) 3.0 0.2 (3.2 - 3.0) 2.3 (3.2 - 1.0) ... ... ... Note that Best-case response time has the same definition as Latency. Worst-case response time also counts as response time in the case of a drop.","title":"Example"},{"location":"design/processing_trace_data/records_service/#visualize-response-time","text":"Cases like the one shown above include Cases where multiple latencies are defined for a single output Message dropping Crossing Branching Some of these can be pessimistically large when it comes to latency. The diagram above describes the table as follows Start timestamp End timestamp 0.0 2.0 0.5 2.5 2.0 3.5 3.0 3.5 4.0 5.0 4.5 7.0 5.5 6.0 5.5 6.5 After leaving only the best-case flows as shown in the figure below, the best-case is calculated as the latency of the line and the worst-case as the latency calculated from the previous input. The response time after processing is shown below. Start timestamp Min response time Max response time 0.0 2.0 2.5 0.5 0.5 3.0 3.0 1.0 2.0 4.0 0.5 2.0 See also FAQ | How response time is calculated?","title":"Visualize response time"},{"location":"design/runtime_processing/","text":"Runtime processing # CARET process followings at runtime. Adds trace points via hooks Filter unnecessary trace points Though LTTng provides a variety of functions, CARET specializes ROS-aware functionality. See also Tracepoint","title":"Runtime processing"},{"location":"design/runtime_processing/#runtime-processing","text":"CARET process followings at runtime. Adds trace points via hooks Filter unnecessary trace points Though LTTng provides a variety of functions, CARET specializes ROS-aware functionality. See also Tracepoint","title":"Runtime processing"},{"location":"design/runtime_processing/hook/","text":"Hook # Hooking is one of the key techniques performed by CARET. This section describes hooks from CARET's point of view. See also CARET_trace Advantage of Hook # ROS 2 is being developed separately from DDS thanks to RMW. On the other hand, each implementation may be developed for different purposes, which makes it difficult to achieve consistent evaluation of all layers, including DDS. CARET handles these layers across by hooks to add and manage trace points consistently. See also Tracepoints definition Info If possible, it is better to add tracepoints as built-in rather than hooks for users. However, CARET's priority is to evaluate software running on the current version of ROS rather than to gradually add trace points. For this reason, we have adopted a hook that allows users to add tracepoints in a flexible manner. Info The advantage of being able to handle all layers across the board is not well utilized in the current CARET. In the future, we plan to use thread local memory to reduce trace points. LD_PRELOAD # Advantage of LD_PRELOAD # LD_PRELOAD can be hooked even if the function is not exposed externally as an API. The trace points themselves, which are built into the ROS layer, can also be hooked. This enables trace filtering. Though you might come up with using eBPF to hook, eBPF requires a context switch from user space to kernel space. Hooking with LD_PRELOAD can be completed in user space, reducing the overhead. See also Tracepoint filtering Limits of LD_PRELOAD # There are some cases that cannot or are difficult to hook with LD_PRELOAD. Functions with many symbols by cpp template Hooks for functions that are expanded as inline code Hooks for functions implemented in headers Specifically, intra-process publish cannot be hooked by LD_PRELOAD. In CARET, trace points for intra-process communication are added in the forked rclcpp.","title":"Hook"},{"location":"design/runtime_processing/hook/#hook","text":"Hooking is one of the key techniques performed by CARET. This section describes hooks from CARET's point of view. See also CARET_trace","title":"Hook"},{"location":"design/runtime_processing/hook/#advantage-of-hook","text":"ROS 2 is being developed separately from DDS thanks to RMW. On the other hand, each implementation may be developed for different purposes, which makes it difficult to achieve consistent evaluation of all layers, including DDS. CARET handles these layers across by hooks to add and manage trace points consistently. See also Tracepoints definition Info If possible, it is better to add tracepoints as built-in rather than hooks for users. However, CARET's priority is to evaluate software running on the current version of ROS rather than to gradually add trace points. For this reason, we have adopted a hook that allows users to add tracepoints in a flexible manner. Info The advantage of being able to handle all layers across the board is not well utilized in the current CARET. In the future, we plan to use thread local memory to reduce trace points.","title":"Advantage of Hook"},{"location":"design/runtime_processing/hook/#ld_preload","text":"","title":"LD_PRELOAD"},{"location":"design/runtime_processing/hook/#advantage-of-ld_preload","text":"LD_PRELOAD can be hooked even if the function is not exposed externally as an API. The trace points themselves, which are built into the ROS layer, can also be hooked. This enables trace filtering. Though you might come up with using eBPF to hook, eBPF requires a context switch from user space to kernel space. Hooking with LD_PRELOAD can be completed in user space, reducing the overhead. See also Tracepoint filtering","title":"Advantage of LD_PRELOAD"},{"location":"design/runtime_processing/hook/#limits-of-ld_preload","text":"There are some cases that cannot or are difficult to hook with LD_PRELOAD. Functions with many symbols by cpp template Hooks for functions that are expanded as inline code Hooks for functions implemented in headers Specifically, intra-process publish cannot be hooked by LD_PRELOAD. In CARET, trace points for intra-process communication are added in the forked rclcpp.","title":"Limits of LD_PRELOAD"},{"location":"design/runtime_processing/tracepoint_filtering/","text":"Tracepoint filtering # When measuring a system composed of many nodes, such as Autoware, the amount of data from tracing can be very large. Trace data discarding occurs during a large amount of recording because Lttng is discard mode to minimize effect to the system. CARET provides the ability to disable trace points associated with specific topics or nodes. This makes it possible to exclude from recording only trace data related to rviz nodes or tf topics, allowing CARET measurements even on large systems. This filtering function looks at the instance addresses (e.g. callback or publisher) to see if they are included in the filter. This check is done in O1 order because it uses std::unordered_map. void ros_trace_callback_start ( const void * callback , bool is_intra_process ) { static auto & controller = Singleton < TracingController >:: get_instance (); // Record trace data only if current callback is allowed to record if ( controller . is_allowed_callback ( callback )) { ORIG_FUNC :: ros_trace_callback_start ( callback , is_intra_process ); } } See also caret_trace Tracepoint Recording trace filtering","title":"Tracepoint filtering"},{"location":"design/runtime_processing/tracepoint_filtering/#tracepoint-filtering","text":"When measuring a system composed of many nodes, such as Autoware, the amount of data from tracing can be very large. Trace data discarding occurs during a large amount of recording because Lttng is discard mode to minimize effect to the system. CARET provides the ability to disable trace points associated with specific topics or nodes. This makes it possible to exclude from recording only trace data related to rviz nodes or tf topics, allowing CARET measurements even on large systems. This filtering function looks at the instance addresses (e.g. callback or publisher) to see if they are included in the filter. This check is done in O1 order because it uses std::unordered_map. void ros_trace_callback_start ( const void * callback , bool is_intra_process ) { static auto & controller = Singleton < TracingController >:: get_instance (); // Record trace data only if current callback is allowed to record if ( controller . is_allowed_callback ( callback )) { ORIG_FUNC :: ros_trace_callback_start ( callback , is_intra_process ); } } See also caret_trace Tracepoint Recording trace filtering","title":"Tracepoint filtering"},{"location":"design/software_architecture/","text":"Software architecture # This section explains an overview of software architecture. CARET is divided into three phases; recording phase, configuration phase and analyzing phase. Recording Phase # In the recording phase, CARET records system execution data from tracepoints. In addition to the tracepoints built into ROS2, CARET adds tracepoints by several methods; CARET_trace CARET_rclcpp and TILDE. For flexibility in adding tracepoints, tracepoints are added by hooks as possible. Only if it is not possible to add tracepoints by hooks, tracepoints are added by other methods as a supplementary method. All recorded data is stored as TraceData and used in the analyzing phase. CARET utilizes LTTng as a trace mechanism. In CARET, packages related to recording phase are followings. caret_trace TILDE See also Tracepoints Runtime Processing The LTTng Documentation Configuration Phase # In the configuration phase, CARET needs configurations to calculate latency. Some of the configurations can be defined via the Python API. Configuration can be saved as a YAML file (Architecture file) and edited. The architecture file is used repeatedly in the analyzing phase. In CARET, packages related to configuration phase are followings. caret_analyze See also Configuration Analyzing Phase # In analyzing phase, CARET analyzes trace data to provide system execution information. CARET_analyze provides a Python class that can access a variety of time series information. Developers can get the necessary information for evaluation from this class and perform evaluation according to their objectives. CARET_analyze also provides visualizations for the evaluation of Jupyter. In CARET, packages related to configuration phase are followings. caret_analyze See also Processing trace data Latency definitions Bokeh ROS 2 Packages # The followings are CARET-related packages. Package Role Repository CARET_trace Add trace points via hooks. Control tracepoints. https://github.com/tier4/CARET_trace/ CARET_rclcpp Add trace points by fork https://github.com/tier4/rclcpp ros2caret Provide CARET CLI https://github.com/tier4/ros2caret/ CARET_analyze Analyze trace data https://github.com/tier4/CARET_analyze/ CARET_analyze_cpp_impl Accelerate CARET_analyze https://github.com/tier4/CARET_analyze_cpp_impl/ TILDE Add tracepoints within the system to be measure https://github.com/tier4/TILDE","title":"Software architecture"},{"location":"design/software_architecture/#software-architecture","text":"This section explains an overview of software architecture. CARET is divided into three phases; recording phase, configuration phase and analyzing phase.","title":"Software architecture"},{"location":"design/software_architecture/#recording-phase","text":"In the recording phase, CARET records system execution data from tracepoints. In addition to the tracepoints built into ROS2, CARET adds tracepoints by several methods; CARET_trace CARET_rclcpp and TILDE. For flexibility in adding tracepoints, tracepoints are added by hooks as possible. Only if it is not possible to add tracepoints by hooks, tracepoints are added by other methods as a supplementary method. All recorded data is stored as TraceData and used in the analyzing phase. CARET utilizes LTTng as a trace mechanism. In CARET, packages related to recording phase are followings. caret_trace TILDE See also Tracepoints Runtime Processing The LTTng Documentation","title":"Recording Phase"},{"location":"design/software_architecture/#configuration-phase","text":"In the configuration phase, CARET needs configurations to calculate latency. Some of the configurations can be defined via the Python API. Configuration can be saved as a YAML file (Architecture file) and edited. The architecture file is used repeatedly in the analyzing phase. In CARET, packages related to configuration phase are followings. caret_analyze See also Configuration","title":"Configuration Phase"},{"location":"design/software_architecture/#analyzing-phase","text":"In analyzing phase, CARET analyzes trace data to provide system execution information. CARET_analyze provides a Python class that can access a variety of time series information. Developers can get the necessary information for evaluation from this class and perform evaluation according to their objectives. CARET_analyze also provides visualizations for the evaluation of Jupyter. In CARET, packages related to configuration phase are followings. caret_analyze See also Processing trace data Latency definitions Bokeh","title":"Analyzing Phase"},{"location":"design/software_architecture/#ros-2-packages","text":"The followings are CARET-related packages. Package Role Repository CARET_trace Add trace points via hooks. Control tracepoints. https://github.com/tier4/CARET_trace/ CARET_rclcpp Add trace points by fork https://github.com/tier4/rclcpp ros2caret Provide CARET CLI https://github.com/tier4/ros2caret/ CARET_analyze Analyze trace data https://github.com/tier4/CARET_analyze/ CARET_analyze_cpp_impl Accelerate CARET_analyze https://github.com/tier4/CARET_analyze_cpp_impl/ TILDE Add tracepoints within the system to be measure https://github.com/tier4/TILDE","title":"ROS 2 Packages"},{"location":"design/software_architecture/caret_analyze/","text":"CARET_analyze # caret_analyze is a package that loads trace data and architecture files and provides Python APIs for configuration and evaluation. See CARET analyze API document for the API of each class. The following figure shows data flow in CARET_analyze. Trace data is divided into two sections by CARET_analyze after loading trace data; Architecture and Runtime Data. The architecture object includes descriptions of the target application's structure. This object can be reused unless the structure of the target application or names of the components is changed. Runtime Data object has data sampled during the execution of the target application. The sampled data includes timestamps, whose values are different per execution, obtained from tracepoints. Runtime data is combined with architecture and provided to developers via Python-API which is easy to evaluate. Architecture object and Runtime Data object are implemented as Python classes. The structure of their classes is designed based on the structure of ROS applications which are constructed of executors, nodes, callback functions, and topic messages. ROS-based structure makes CARET's API friendly for ROS users. CARET_analyze is composed of several python packages. Each python packages are as follows. python package role architecture Load and configure Architecture runtime Provide execution data value_objects collection of value objects plot Visualization helpers records implement records common common procedure infra import outer files Role for each component is as follows. Architecture object provides APIs to search node paths and define node latency as mentioned in configuration chapter . The architecture object is reusable after it is saved as a YAML-based file called \"architecture file\". Runtime Data object provides APIs to retrieve pandas.DataFrame -based objects including callback latency or communication. Users can analyze temporal aspects of their applications, with visualization, as they expect. APIs for visualization are also served by CARET_analyze which plays the main role to analyze trace data. In the following sections, each package will be explained in more detail. architecture # In architecture, an instance is created with the following structure. This allows access to the necessary information from the top-level Architecture class. Purpose of Architecture: Define static information to be used in Analyze Info \"Model\" might be more appropriate than the name \"Architecture\". Architecture describes all the parameters related to scheduling, such as scheduling and core migration. Therefore, we're thinking that the architecture can be used for design based on scheduling theory. All information retrieved from the Architecture file is of type ValueObject, which is suitable for interfacing information between other packages. runtime # The runtime, which also includes trace results, follows the architecture structure and adds a function to calculate the measurement results. There are classes that can calculate latency and classes as collections. The following is a list of each class and the classes which can calculate latency. Class API has latency definition? Application API list No Executor API list No Node API list No Path API list Yes ( Definitions ) NodePath API list Yes ( Definitions ) Communication API list Yes ( Definitions ) Timer API list Yes ( Definitions ) Subscription API list Yes ( Definitions ) Callback API list Yes ( Definitions ) value_objects # ValueObjects define classes with equivalence. The Value class has the information for binding, and the StructValue class has the structure of multiple classes after binding. plot # There are classes associated with the display. The visualization provided by CARET_analyze is based on bokeh and graphviz. records # In CARET, latency is calculated by joining process of tables uniquely defined. The records package defines tables with their own join processing. See also Records common # Common package implements individual processes are described that can be handled as common in each package. infra # Infra package implements the process of reading from the outside. It contains YAML and Lttng which implement ArchitectureReader/RuntimeDataProvider respectively.","title":"CARET_analyze"},{"location":"design/software_architecture/caret_analyze/#caret_analyze","text":"caret_analyze is a package that loads trace data and architecture files and provides Python APIs for configuration and evaluation. See CARET analyze API document for the API of each class. The following figure shows data flow in CARET_analyze. Trace data is divided into two sections by CARET_analyze after loading trace data; Architecture and Runtime Data. The architecture object includes descriptions of the target application's structure. This object can be reused unless the structure of the target application or names of the components is changed. Runtime Data object has data sampled during the execution of the target application. The sampled data includes timestamps, whose values are different per execution, obtained from tracepoints. Runtime data is combined with architecture and provided to developers via Python-API which is easy to evaluate. Architecture object and Runtime Data object are implemented as Python classes. The structure of their classes is designed based on the structure of ROS applications which are constructed of executors, nodes, callback functions, and topic messages. ROS-based structure makes CARET's API friendly for ROS users. CARET_analyze is composed of several python packages. Each python packages are as follows. python package role architecture Load and configure Architecture runtime Provide execution data value_objects collection of value objects plot Visualization helpers records implement records common common procedure infra import outer files Role for each component is as follows. Architecture object provides APIs to search node paths and define node latency as mentioned in configuration chapter . The architecture object is reusable after it is saved as a YAML-based file called \"architecture file\". Runtime Data object provides APIs to retrieve pandas.DataFrame -based objects including callback latency or communication. Users can analyze temporal aspects of their applications, with visualization, as they expect. APIs for visualization are also served by CARET_analyze which plays the main role to analyze trace data. In the following sections, each package will be explained in more detail.","title":"CARET_analyze"},{"location":"design/software_architecture/caret_analyze/#architecture","text":"In architecture, an instance is created with the following structure. This allows access to the necessary information from the top-level Architecture class. Purpose of Architecture: Define static information to be used in Analyze Info \"Model\" might be more appropriate than the name \"Architecture\". Architecture describes all the parameters related to scheduling, such as scheduling and core migration. Therefore, we're thinking that the architecture can be used for design based on scheduling theory. All information retrieved from the Architecture file is of type ValueObject, which is suitable for interfacing information between other packages.","title":"architecture"},{"location":"design/software_architecture/caret_analyze/#runtime","text":"The runtime, which also includes trace results, follows the architecture structure and adds a function to calculate the measurement results. There are classes that can calculate latency and classes as collections. The following is a list of each class and the classes which can calculate latency. Class API has latency definition? Application API list No Executor API list No Node API list No Path API list Yes ( Definitions ) NodePath API list Yes ( Definitions ) Communication API list Yes ( Definitions ) Timer API list Yes ( Definitions ) Subscription API list Yes ( Definitions ) Callback API list Yes ( Definitions )","title":"runtime"},{"location":"design/software_architecture/caret_analyze/#value_objects","text":"ValueObjects define classes with equivalence. The Value class has the information for binding, and the StructValue class has the structure of multiple classes after binding.","title":"value_objects"},{"location":"design/software_architecture/caret_analyze/#plot","text":"There are classes associated with the display. The visualization provided by CARET_analyze is based on bokeh and graphviz.","title":"plot"},{"location":"design/software_architecture/caret_analyze/#records","text":"In CARET, latency is calculated by joining process of tables uniquely defined. The records package defines tables with their own join processing. See also Records","title":"records"},{"location":"design/software_architecture/caret_analyze/#common","text":"Common package implements individual processes are described that can be handled as common in each package.","title":"common"},{"location":"design/software_architecture/caret_analyze/#infra","text":"Infra package implements the process of reading from the outside. It contains YAML and Lttng which implement ArchitectureReader/RuntimeDataProvider respectively.","title":"infra"},{"location":"design/software_architecture/caret_trace/","text":"caret_trace # caret_trace is a package that handles recording such as adding trace points. The role of caret_trace is as follows Race Point Definition Adding Tracepoints with Hooks trace filtering simtime recording See also Tracepoints Hook Class Structure # Hook function implementation # In addition to hooking and for adding trace points, CARET also hooks trace points built into ROS2. Here is an example of a typical hook implementation. void ros_trace_rcl_node_init ( const void * node_handle , const void * rmw_handle , const char * node_name , const char * node_namespace ) { static auto & controller = Singleton < TracingController >:: get_instance (); // Bind node handle and node name controller . add_node ( node_handle , ns + node_name ); // Record trace data only if current node is allowed to record if ( controller . is_allowed_node ( node_handle )) { ORIG_FUNC :: ros_trace_rcl_node_init )( node_handle , rmw_handle , node_name , node_namespace ); } } void ros_trace_callback_start ( const void * callback , bool is_intra_process ) { static auto & controller = Singleton < TracingController >:: get_instance (); // Record trace data only if current callback is allowed to record if ( controller . is_allowed_callback ( callback )) { ORIG_FUNC :: ros_trace_callback_start ( callback , is_intra_process ); } } Here, debugging logs and other information are omitted. Information from callback addresses to node names, etc., can be obtained by binding them to other trace point information. See Initialization trace points for details. clock recorder # CARET can select simtime for visualization. The simtime can be recorded by running the simtime_recorder node, which adds trace points for simtime recording. ros2 run caret_trace clock_recorder ClockRecorder node wakes up every second and records simtime and system time. The recorded results are used to calculate simtime from system time.","title":"caret_trace"},{"location":"design/software_architecture/caret_trace/#caret_trace","text":"caret_trace is a package that handles recording such as adding trace points. The role of caret_trace is as follows Race Point Definition Adding Tracepoints with Hooks trace filtering simtime recording See also Tracepoints Hook","title":"caret_trace"},{"location":"design/software_architecture/caret_trace/#class-structure","text":"","title":"Class Structure"},{"location":"design/software_architecture/caret_trace/#hook-function-implementation","text":"In addition to hooking and for adding trace points, CARET also hooks trace points built into ROS2. Here is an example of a typical hook implementation. void ros_trace_rcl_node_init ( const void * node_handle , const void * rmw_handle , const char * node_name , const char * node_namespace ) { static auto & controller = Singleton < TracingController >:: get_instance (); // Bind node handle and node name controller . add_node ( node_handle , ns + node_name ); // Record trace data only if current node is allowed to record if ( controller . is_allowed_node ( node_handle )) { ORIG_FUNC :: ros_trace_rcl_node_init )( node_handle , rmw_handle , node_name , node_namespace ); } } void ros_trace_callback_start ( const void * callback , bool is_intra_process ) { static auto & controller = Singleton < TracingController >:: get_instance (); // Record trace data only if current callback is allowed to record if ( controller . is_allowed_callback ( callback )) { ORIG_FUNC :: ros_trace_callback_start ( callback , is_intra_process ); } } Here, debugging logs and other information are omitted. Information from callback addresses to node names, etc., can be obtained by binding them to other trace point information. See Initialization trace points for details.","title":"Hook function implementation"},{"location":"design/software_architecture/caret_trace/#clock-recorder","text":"CARET can select simtime for visualization. The simtime can be recorded by running the simtime_recorder node, which adds trace points for simtime recording. ros2 run caret_trace clock_recorder ClockRecorder node wakes up every second and records simtime and system time. The recorded results are used to calculate simtime from system time.","title":"clock recorder"},{"location":"design/software_architecture/tilde/","text":"TILDE, a framework tools to detect deadline overrun # CARET can cooperate with TILDE, a framework tool to detect deadline overrun. TILDE lets CARET trace events in user applications which cannot be traced from ROS/DDS layer. Notice TILDE is now under development. Since ROS nodes can implement arbitrary processing, some nodes are difficult to calculate node latency. Examples of implementations for which node latency is difficult to calculate are as follows. Message buffering case between subscribe and publish Using message filter case the latencies can be observed in only application layer, but CARET cannot observe the events. On the other hand, TILDE can trace application-layer events. It is able to trace execution of callback function to consume a certain buffered message since it annotate message consumption per single message. TILDE serves CARET this capability to trace consumption of buffered messages. See also TILDE official page Node latency definition","title":"TILDE, a framework tools to detect deadline overrun"},{"location":"design/software_architecture/tilde/#tilde-a-framework-tools-to-detect-deadline-overrun","text":"CARET can cooperate with TILDE, a framework tool to detect deadline overrun. TILDE lets CARET trace events in user applications which cannot be traced from ROS/DDS layer. Notice TILDE is now under development. Since ROS nodes can implement arbitrary processing, some nodes are difficult to calculate node latency. Examples of implementations for which node latency is difficult to calculate are as follows. Message buffering case between subscribe and publish Using message filter case the latencies can be observed in only application layer, but CARET cannot observe the events. On the other hand, TILDE can trace application-layer events. It is able to trace execution of callback function to consume a certain buffered message since it annotate message consumption per single message. TILDE serves CARET this capability to trace consumption of buffered messages. See also TILDE official page Node latency definition","title":"TILDE, a framework tools to detect deadline overrun"},{"location":"design/trace_points/","text":"Tracepoints definition # This section lists all tracepoints and their definition. Some tracepoints are used for collecting identification of executors, nodes, callbacks, and topics during application's initialization. They are called initialization tracepoints. The other tracepoints are embedded for sampling timestamps after completion of initialization, and called runtime tracepoints. Each tracepoint for CARET is added by followings method. Built-in tracepoints tracepoints embedded in original ROS 2 middleware which are utilized by ros2-tracing some of tracepoints, for service, action and lifecycle node, are not utilized by current CARET Hooked tracepoints CARET-dedicated tracepoints introduced by function hooking with LD_PRELOAD Extended tracepoints CARET-dedicated tracepoints added to the fork of rclcpp CARET utilizes some of the tracepoints built-in original ROS 2. Some of the tracepoints are added by hooking with LD_PRELOAD, and rest trace points are added to the fork of ROS 2's rclcpp. Info Please read this section if you are interested in CARET-dedicated tracepoints are extended by the forked rclcpp and LD_PRELOAD. CARET would like to add tracepoints by function hooking as possible. LD_PRELOAD is reasonable to hook functions defined in dynamic library, but it cannot be applied to functions by implemented with C++ template. Such template-based implementation is mapped into binary file after it is built or compiled. Builtin rclcpp uses C++ template for some functions like intra-process communication, for example. The forked rclcpp is introduced to add tracepoints to the functions.","title":"Tracepoints definition"},{"location":"design/trace_points/#tracepoints-definition","text":"This section lists all tracepoints and their definition. Some tracepoints are used for collecting identification of executors, nodes, callbacks, and topics during application's initialization. They are called initialization tracepoints. The other tracepoints are embedded for sampling timestamps after completion of initialization, and called runtime tracepoints. Each tracepoint for CARET is added by followings method. Built-in tracepoints tracepoints embedded in original ROS 2 middleware which are utilized by ros2-tracing some of tracepoints, for service, action and lifecycle node, are not utilized by current CARET Hooked tracepoints CARET-dedicated tracepoints introduced by function hooking with LD_PRELOAD Extended tracepoints CARET-dedicated tracepoints added to the fork of rclcpp CARET utilizes some of the tracepoints built-in original ROS 2. Some of the tracepoints are added by hooking with LD_PRELOAD, and rest trace points are added to the fork of ROS 2's rclcpp. Info Please read this section if you are interested in CARET-dedicated tracepoints are extended by the forked rclcpp and LD_PRELOAD. CARET would like to add tracepoints by function hooking as possible. LD_PRELOAD is reasonable to hook functions defined in dynamic library, but it cannot be applied to functions by implemented with C++ template. Such template-based implementation is mapped into binary file after it is built or compiled. Builtin rclcpp uses C++ template for some functions like intra-process communication, for example. The forked rclcpp is introduced to add tracepoints to the functions.","title":"Tracepoints definition"},{"location":"design/trace_points/diff/","text":"Differences from original ROS # v0.2 vs galactic # In addition to the caret repository, caret.repos contains the following repositories https://github.com/ros2/rcl.git https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added This section describes the differences between each repository. rcl # No source code changes. Cloning this package is for enabling built-in trace points by rebuilding. rclcpp # This cloning is for adding trace point which cannot added by LD_PRELOAD. See also Tracepoints It's needed to add include directory of ros2_tracing. Info Reason to add include files of ros2_tracing to rclcpp. LD_PRELOAD allows custom shared libraries to be loaded with priority immediately after the start of execution. On the other hand, tracepoints added to the header as described above require that the tracepoint-added version of the header be loaded first during header searching at build time. An include file is added to ensure that this priority is as expected. When the merging of tracepoints to the ros2 mainframe, the addition of the ros2_tracing include file to rclcpp is not necessary. ros2_tracing # This cloning is for defining tracepoints added to rclcpp. v0.3 vs humble # In v0.3, the trace points used in the galactic version of CARET have been ported. Some tracepoints have been added in humble, but they are not currently supported. These tracepoints will be supported in a future version.","title":"Differences from original ROS"},{"location":"design/trace_points/diff/#differences-from-original-ros","text":"","title":"Differences from original ROS"},{"location":"design/trace_points/diff/#v02-vs-galactic","text":"In addition to the caret repository, caret.repos contains the following repositories https://github.com/ros2/rcl.git https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added This section describes the differences between each repository.","title":"v0.2 vs galactic"},{"location":"design/trace_points/diff/#rcl","text":"No source code changes. Cloning this package is for enabling built-in trace points by rebuilding.","title":"rcl"},{"location":"design/trace_points/diff/#rclcpp","text":"This cloning is for adding trace point which cannot added by LD_PRELOAD. See also Tracepoints It's needed to add include directory of ros2_tracing. Info Reason to add include files of ros2_tracing to rclcpp. LD_PRELOAD allows custom shared libraries to be loaded with priority immediately after the start of execution. On the other hand, tracepoints added to the header as described above require that the tracepoint-added version of the header be loaded first during header searching at build time. An include file is added to ensure that this priority is as expected. When the merging of tracepoints to the ros2 mainframe, the addition of the ros2_tracing include file to rclcpp is not necessary.","title":"rclcpp"},{"location":"design/trace_points/diff/#ros2_tracing","text":"This cloning is for defining tracepoints added to rclcpp.","title":"ros2_tracing"},{"location":"design/trace_points/diff/#v03-vs-humble","text":"In v0.3, the trace points used in the galactic version of CARET have been ported. Some tracepoints have been added in humble, but they are not currently supported. These tracepoints will be supported in a future version.","title":"v0.3 vs humble"},{"location":"design/trace_points/initialization_trace_points/","text":"Some tracepoints share same addresses (e.g. node_handle and callback address). By binding these addresses, CARET constructs structures of each trace point relationship. Relationships for each initialization trace points # Relationships of each trace point related to a single node are shown as follows. erDiagram rcl_init{ address context_handle } rcl_node_init{ address node_handle address rmw_handle string node_name string node_namespace } rcl_publisher_init{ address publisher_handle address node_handle address rmw_publisher_handle string topic_name size_t queue_depth } rcl_subscription_init{ address subscription_handle address node_handle address rmw_subscription_handle string topic_name size_t queue_depth } rclcpp_subscription_init{ address subscription_handle address subscription } rclcpp_subscription_callback_added{ address subscription address callback } rcl_timer_init{ address timer_handle int64_t period } rclcpp_timer_callback_added{ address timer_handle address callback } rclcpp_timer_link_node{ address timer_handle address node_handle } rclcpp_callback_register{ address callback string function_symbol } rmw_implementation{ string rmw_impl } rcl_node_init ||--o{ rcl_publisher_init : node_handle rcl_node_init ||--o{ rcl_subscription_init : node_handle rcl_node_init ||--o{ rclcpp_timer_link_node : node_handle rcl_publisher_init ||--|| PUBLISHER_HANDLE : node_handle rcl_subscription_init ||--|| SUBSCRIPTION_HANDLE : node_handle rcl_timer_init ||--|| TIMER_HANDLE : node_handle rcl_subscription_init ||--|| rclcpp_subscription_init : subscription_handle rclcpp_subscription_init ||--|| rclcpp_subscription_callback_added: subscription rclcpp_timer_callback_added ||--|| rclcpp_callback_register: callback rclcpp_subscription_callback_added ||--|| rclcpp_callback_register: callback rclcpp_timer_callback_added ||--|| rcl_timer_init : timer_handle rclcpp_timer_link_node ||--|| rcl_timer_init: timer_handle Relationships of each trace point related to executors are shown as follows. erDiagram construct_executor{ address executor_addr string executor_type_name } construct_static_executor{ address executor_addr address entities_collector_addr string executor_type_name } add_callback_group{ address executor_addr address callback_group_addr string group_type_name } add_callback_group_static_executor{ address entities_collector_addr address callback_group_addr string group_type_name } callback_group_add_timer{ address callback_group_addr address timer_handle } callback_group_add_subscription{ address callback_group_addr address subscription_handle } callback_group_add_service{ address callback_group_addr address service_handle } callback_group_add_client{ address callback_group_addr address client_handle } construct_executor ||--o{ add_callback_group : executor_addr construct_static_executor ||--o{ add_callback_group_static_executor : entities_collector_addr add_callback_group_static_executor ||--o{ callback_group_add_timer : callback_group_addr add_callback_group_static_executor ||--o{ callback_group_add_subscription : callback_group_addr add_callback_group_static_executor ||--o{ callback_group_add_service : callback_group_addr add_callback_group_static_executor ||--o{ callback_group_add_client : callback_group_addr add_callback_group ||--o{ callback_group_add_timer : callback_group_addr add_callback_group ||--o{ callback_group_add_subscription : callback_group_addr add_callback_group ||--o{ callback_group_add_service : callback_group_addr add_callback_group ||--o{ callback_group_add_client : callback_group_addr callback_group_add_timer ||--|| TIMER_HANDLE : callback_group_addr callback_group_add_subscription ||--|| SUBSCRIPTION_HANDLE : callback_group_addr callback_group_add_service ||--|| SERVICE_HANDLE : callback_group_addr callback_group_add_client ||--|| CLIENT_HANDLE : callback_group_addr Tracepoints for representing structure of executor and callback group # A handler such as timer_handle and subscription_handle are assigned to a callback group. A callback group belongs to an executor. ros2:rcl_init # [Built-in tracepoints] Sampled items void * context_handle ros2:rcl_node_init # [Built-in tracepoints] Sampled items void * node_handle void * rmw_handle char * node_name char * node_namespace ros2:rcl_publisher_init # [Built-in tracepoints] Sampled items void * publisher_handle void * node_handle void * rmw_publisher_handle char * topic_name size_t queue_depth ros2:rcl_subscription_init # [Built-in tracepoints] Sampled items void * subscription_handle void * node_handle void * rmw_subscription_handle char * topic_name size_t queue_depth ros2:rclcpp_subscription_init # [Built-in tracepoints] Sampled items void * subscription_handle void * subscription ros2:rclcpp_subscription_callback_added # [Built-in tracepoints] Sampled items void * subscription void * callback ros2:rcl_timer_init # [Built-in tracepoints] Sampled items void * timer_handle int64_t period ros2:rclcpp_timer_callback_added # [Built-in tracepoints] Sampled items void * timer_handle void * callback ros2:rclcpp_timer_link_node # [Built-in tracepoints] Sampled items void * timer_handle void * node_handle ros2:rclcpp_callback_register # [Built-in tracepoints] Sampled items void * callback char * function_symbol ros2_caret:rmw_implementation # [Hooked tracepoints] Sampled items char * rmw_impl ros2_caret:construct_executor # [Hooked tracepoints] Sampled items void * executor_addr char * executor_type_name ros2_caret:construct_static_executor # [Hooked tracepoints] Sampled items void * executor_addr void * entities_collector_addr char * executor_type_name ros2_caret:add_callback_group # [Hooked tracepoints] Sampled items void * executor_addr void * callback_group_addr char * group_type_name ros2_caret:add_callback_group_static_executor # [Hooked tracepoints] Sampled items void * entities_collector_addr void * callback_group_addr char * group_type_name ros2_caret:callback_group_add_timer # [Hooked tracepoints] Sampled items void * callback_group_addr void * timer_handle ros2_caret:callback_group_add_subscription # [Hooked tracepoints] Sampled items void * callback_group_addr void * subscription_handle ros2_caret:callback_group_add_service # [Hooked tracepoints] Sampled items void * callback_group_addr void * service_handle ros2_caret:callback_group_add_client # [Hooked tracepoints] Sampled items void * callback_group_addr void * client_handle","title":"Initialization trace points"},{"location":"design/trace_points/initialization_trace_points/#relationships-for-each-initialization-trace-points","text":"Relationships of each trace point related to a single node are shown as follows. erDiagram rcl_init{ address context_handle } rcl_node_init{ address node_handle address rmw_handle string node_name string node_namespace } rcl_publisher_init{ address publisher_handle address node_handle address rmw_publisher_handle string topic_name size_t queue_depth } rcl_subscription_init{ address subscription_handle address node_handle address rmw_subscription_handle string topic_name size_t queue_depth } rclcpp_subscription_init{ address subscription_handle address subscription } rclcpp_subscription_callback_added{ address subscription address callback } rcl_timer_init{ address timer_handle int64_t period } rclcpp_timer_callback_added{ address timer_handle address callback } rclcpp_timer_link_node{ address timer_handle address node_handle } rclcpp_callback_register{ address callback string function_symbol } rmw_implementation{ string rmw_impl } rcl_node_init ||--o{ rcl_publisher_init : node_handle rcl_node_init ||--o{ rcl_subscription_init : node_handle rcl_node_init ||--o{ rclcpp_timer_link_node : node_handle rcl_publisher_init ||--|| PUBLISHER_HANDLE : node_handle rcl_subscription_init ||--|| SUBSCRIPTION_HANDLE : node_handle rcl_timer_init ||--|| TIMER_HANDLE : node_handle rcl_subscription_init ||--|| rclcpp_subscription_init : subscription_handle rclcpp_subscription_init ||--|| rclcpp_subscription_callback_added: subscription rclcpp_timer_callback_added ||--|| rclcpp_callback_register: callback rclcpp_subscription_callback_added ||--|| rclcpp_callback_register: callback rclcpp_timer_callback_added ||--|| rcl_timer_init : timer_handle rclcpp_timer_link_node ||--|| rcl_timer_init: timer_handle Relationships of each trace point related to executors are shown as follows. erDiagram construct_executor{ address executor_addr string executor_type_name } construct_static_executor{ address executor_addr address entities_collector_addr string executor_type_name } add_callback_group{ address executor_addr address callback_group_addr string group_type_name } add_callback_group_static_executor{ address entities_collector_addr address callback_group_addr string group_type_name } callback_group_add_timer{ address callback_group_addr address timer_handle } callback_group_add_subscription{ address callback_group_addr address subscription_handle } callback_group_add_service{ address callback_group_addr address service_handle } callback_group_add_client{ address callback_group_addr address client_handle } construct_executor ||--o{ add_callback_group : executor_addr construct_static_executor ||--o{ add_callback_group_static_executor : entities_collector_addr add_callback_group_static_executor ||--o{ callback_group_add_timer : callback_group_addr add_callback_group_static_executor ||--o{ callback_group_add_subscription : callback_group_addr add_callback_group_static_executor ||--o{ callback_group_add_service : callback_group_addr add_callback_group_static_executor ||--o{ callback_group_add_client : callback_group_addr add_callback_group ||--o{ callback_group_add_timer : callback_group_addr add_callback_group ||--o{ callback_group_add_subscription : callback_group_addr add_callback_group ||--o{ callback_group_add_service : callback_group_addr add_callback_group ||--o{ callback_group_add_client : callback_group_addr callback_group_add_timer ||--|| TIMER_HANDLE : callback_group_addr callback_group_add_subscription ||--|| SUBSCRIPTION_HANDLE : callback_group_addr callback_group_add_service ||--|| SERVICE_HANDLE : callback_group_addr callback_group_add_client ||--|| CLIENT_HANDLE : callback_group_addr","title":"Relationships for each initialization trace points"},{"location":"design/trace_points/initialization_trace_points/#tracepoints-for-representing-structure-of-executor-and-callback-group","text":"A handler such as timer_handle and subscription_handle are assigned to a callback group. A callback group belongs to an executor.","title":"Tracepoints for representing structure of executor and callback group"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_init","text":"[Built-in tracepoints] Sampled items void * context_handle","title":"ros2:rcl_init"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_node_init","text":"[Built-in tracepoints] Sampled items void * node_handle void * rmw_handle char * node_name char * node_namespace","title":"ros2:rcl_node_init"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_publisher_init","text":"[Built-in tracepoints] Sampled items void * publisher_handle void * node_handle void * rmw_publisher_handle char * topic_name size_t queue_depth","title":"ros2:rcl_publisher_init"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_subscription_init","text":"[Built-in tracepoints] Sampled items void * subscription_handle void * node_handle void * rmw_subscription_handle char * topic_name size_t queue_depth","title":"ros2:rcl_subscription_init"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_subscription_init","text":"[Built-in tracepoints] Sampled items void * subscription_handle void * subscription","title":"ros2:rclcpp_subscription_init"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_subscription_callback_added","text":"[Built-in tracepoints] Sampled items void * subscription void * callback","title":"ros2:rclcpp_subscription_callback_added"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_timer_init","text":"[Built-in tracepoints] Sampled items void * timer_handle int64_t period","title":"ros2:rcl_timer_init"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_timer_callback_added","text":"[Built-in tracepoints] Sampled items void * timer_handle void * callback","title":"ros2:rclcpp_timer_callback_added"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_timer_link_node","text":"[Built-in tracepoints] Sampled items void * timer_handle void * node_handle","title":"ros2:rclcpp_timer_link_node"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_callback_register","text":"[Built-in tracepoints] Sampled items void * callback char * function_symbol","title":"ros2:rclcpp_callback_register"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretrmw_implementation","text":"[Hooked tracepoints] Sampled items char * rmw_impl","title":"ros2_caret:rmw_implementation"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretconstruct_executor","text":"[Hooked tracepoints] Sampled items void * executor_addr char * executor_type_name","title":"ros2_caret:construct_executor"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretconstruct_static_executor","text":"[Hooked tracepoints] Sampled items void * executor_addr void * entities_collector_addr char * executor_type_name","title":"ros2_caret:construct_static_executor"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretadd_callback_group","text":"[Hooked tracepoints] Sampled items void * executor_addr void * callback_group_addr char * group_type_name","title":"ros2_caret:add_callback_group"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretadd_callback_group_static_executor","text":"[Hooked tracepoints] Sampled items void * entities_collector_addr void * callback_group_addr char * group_type_name","title":"ros2_caret:add_callback_group_static_executor"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_timer","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * timer_handle","title":"ros2_caret:callback_group_add_timer"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_subscription","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * subscription_handle","title":"ros2_caret:callback_group_add_subscription"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_service","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * service_handle","title":"ros2_caret:callback_group_add_service"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_client","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * client_handle","title":"ros2_caret:callback_group_add_client"},{"location":"design/trace_points/runtime_trace_points/","text":"Relationships for each runtime trace points # erDiagram callback_start{ address callback bool is_intra_process } callback_end{ address callback } message_construct{ address original_message address constructed_message } dds_bind_addr_to_addr{ address addr_from address addr_to } rclcpp_intra_publish{ address publisher_handle address message uint64_t message_timestamp } dispatch_subscription_callback{ address message address callback uint64_t source_timestamp uint64_t message_timestamp } dispatch_intra_process_subscription_callback{ address message address callback uint64_t message_timestamp } rcl_publish{ address publisher_handle address message } rclcpp_publish{ address publisher_handle address message uint64_t message_timestamp } dds_write{ address message } dds_bind_addr_to_stamp{ address addr uint64_t source_stamp } rclcpp_intra_publish ||--|| dispatch_intra_process_subscription_callback: message_addr rclcpp_publish ||--|| rcl_publish: message_addr rcl_publish ||--|| dds_write: message_addr dds_write ||--|| dds_bind_addr_to_stamp: message_addr dds_bind_addr_to_stamp ||--|| dispatch_subscription_callback: source_timestamp dispatch_intra_process_subscription_callback ||--|| callback_start: callback dispatch_subscription_callback ||--|| callback_start: callback callback_start ||--|| callback_end: callback Using addresses, tid and source timestamp, it is possible to uniquely identify and bind from the rclcpp publish to the end of subscription node callback. On the other hand, callback start and publish cannot be automatically bound. This is because the relationship between callback and publish is highly implementation-dependent. message_construct and dds_bind_addr_to_addr are trace points to adapt to copying and converting instances for binding. ros2:callback_start # [Original tracepoints] Sampled items void * callback bool is_intra_process ros2:callback_end # [Original tracepoints] Sampled items void * callback ros2:message_construct # [Extended tracepoints] Sampled items void * original_message void * constructed_message ros2:rclcpp_intra_publish # [Extended tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp ros2:dispatch_subscription_callback # [Extended tracepoints] Sampled items void * message void * callback uint64_t source_timestamp uint64_t message_timestamp ros2:dispatch_intra_process_subscription_callback # [Extended tracepoints] Sampled items void * message void * callback uint64_t message_timestamp ros2:rcl_publish # [Original tracepoints] Sampled items void * publisher_handle void * message ros2:rclcpp_publish # [Original tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp ros2_caret:dds_write # [Hooked tracepoints] Sampled items void * message ros2_caret:dds_bind_addr_to_stamp # [Hooked tracepoints] Sampled items void * addr uint64_t source_stamp ros2_caret:dds_bind_addr_to_addr # [Hooked tracepoints] Sampled items void * addr_from void * addr_to","title":"Runtime trace points"},{"location":"design/trace_points/runtime_trace_points/#relationships-for-each-runtime-trace-points","text":"erDiagram callback_start{ address callback bool is_intra_process } callback_end{ address callback } message_construct{ address original_message address constructed_message } dds_bind_addr_to_addr{ address addr_from address addr_to } rclcpp_intra_publish{ address publisher_handle address message uint64_t message_timestamp } dispatch_subscription_callback{ address message address callback uint64_t source_timestamp uint64_t message_timestamp } dispatch_intra_process_subscription_callback{ address message address callback uint64_t message_timestamp } rcl_publish{ address publisher_handle address message } rclcpp_publish{ address publisher_handle address message uint64_t message_timestamp } dds_write{ address message } dds_bind_addr_to_stamp{ address addr uint64_t source_stamp } rclcpp_intra_publish ||--|| dispatch_intra_process_subscription_callback: message_addr rclcpp_publish ||--|| rcl_publish: message_addr rcl_publish ||--|| dds_write: message_addr dds_write ||--|| dds_bind_addr_to_stamp: message_addr dds_bind_addr_to_stamp ||--|| dispatch_subscription_callback: source_timestamp dispatch_intra_process_subscription_callback ||--|| callback_start: callback dispatch_subscription_callback ||--|| callback_start: callback callback_start ||--|| callback_end: callback Using addresses, tid and source timestamp, it is possible to uniquely identify and bind from the rclcpp publish to the end of subscription node callback. On the other hand, callback start and publish cannot be automatically bound. This is because the relationship between callback and publish is highly implementation-dependent. message_construct and dds_bind_addr_to_addr are trace points to adapt to copying and converting instances for binding.","title":"Relationships for each runtime trace points"},{"location":"design/trace_points/runtime_trace_points/#ros2callback_start","text":"[Original tracepoints] Sampled items void * callback bool is_intra_process","title":"ros2:callback_start"},{"location":"design/trace_points/runtime_trace_points/#ros2callback_end","text":"[Original tracepoints] Sampled items void * callback","title":"ros2:callback_end"},{"location":"design/trace_points/runtime_trace_points/#ros2message_construct","text":"[Extended tracepoints] Sampled items void * original_message void * constructed_message","title":"ros2:message_construct"},{"location":"design/trace_points/runtime_trace_points/#ros2rclcpp_intra_publish","text":"[Extended tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp","title":"ros2:rclcpp_intra_publish"},{"location":"design/trace_points/runtime_trace_points/#ros2dispatch_subscription_callback","text":"[Extended tracepoints] Sampled items void * message void * callback uint64_t source_timestamp uint64_t message_timestamp","title":"ros2:dispatch_subscription_callback"},{"location":"design/trace_points/runtime_trace_points/#ros2dispatch_intra_process_subscription_callback","text":"[Extended tracepoints] Sampled items void * message void * callback uint64_t message_timestamp","title":"ros2:dispatch_intra_process_subscription_callback"},{"location":"design/trace_points/runtime_trace_points/#ros2rcl_publish","text":"[Original tracepoints] Sampled items void * publisher_handle void * message","title":"ros2:rcl_publish"},{"location":"design/trace_points/runtime_trace_points/#ros2rclcpp_publish","text":"[Original tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp","title":"ros2:rclcpp_publish"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_write","text":"[Hooked tracepoints] Sampled items void * message","title":"ros2_caret:dds_write"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_bind_addr_to_stamp","text":"[Hooked tracepoints] Sampled items void * addr uint64_t source_stamp","title":"ros2_caret:dds_bind_addr_to_stamp"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_bind_addr_to_addr","text":"[Hooked tracepoints] Sampled items void * addr_from void * addr_to","title":"ros2_caret:dds_bind_addr_to_addr"},{"location":"design/visualizations/","text":"Visualizations # CARET is a tool for performance evaluation. For evaluation, quantification and visualization would be sufficient. For analysis, on the other hand, various factors are involved in behavior and performance, so it is necessary to investigate from multiple perspectives. CARET has multiple visualizations for evaluation and analysis APIs that are readily available. Also, it's also possible to directly acquire and evaluate the data on your own (see Processing trace data for detail). Policy # Evaluation flow # CARET has a large amount of information that can be obtained, and it is difficult to evaluate large-scale applications simply by displaying the recorded trace data in time series. So, it is important to focus on evaluation targets with appropriate granularity according to the purpose of evaluation. The following diagram shows the evaluation flow and analysis by adjusting the granularity. Here, the horizontal axis represents the visualization granularity and the vertical axis represents the processing granularity. CARET leads from issue detection to cause identification by changing the processing and visualization granularity from the rough granularity in the upper right to the fine granularity in the lower left. Detect issues: Detects performance issues on the target system. Identify issues: Identify the bottleneck that is causing the issue. Identify causes: Identifies the cause of the bottleneck. Processing granularity on the horizontal axis and visualization granularity on the vertical axis are explained in the following section. Visualization granularity # The granularity of visualization can be ordered in coarse order as follows Statistic Histogram Heatmap Bar graph / Line graph Time-series trace data The coarser granularity, the more time information is aggregated to evaluate the measurement as a whole. The most granular statistics are suitable for regression testing. On the other hand, the finer granularity, the more detailed information is expressed, so it is more suitable for analysis. evaluation Latency and response time are some of the indicators to evaluate performance. The most detailed information is a time-series graph of each trace data. Processing granularity # The processing granularity can be ordered in coarse order as follows. path node / communication callbackCurrent CARET does not support measurement of arbitrary functions or DDS enqueue/dequeue. function Path is suitable for evaluation of system performance, while node and callback are suitable for evaluation of functional performance. Notice Currently CARET does not support measurement of arbitrary functions or DDS enqueue/dequeue or system calls. See also Latency definition Time domain and Frequency domain # We described behavior and indicator in terms of visualization granularity, but there are multiple indicators, such as latency and frequency. When considering which indicator to use, it is useful to consider the time domain indicators and frequency domain indicators. Time Domain Indicators (ex: callback execution time [s]) Frequency Domain Indicators (ex: topic frequency [Hz]) Both have their pros and cons. Time Domain Indicators Frequency Domain Indicators Indicator Latency, Response time Frequency (, Period) Pros Easy to compare with system requirements No need to define latency or path Cons Need to define latency or path Difficult to compare with system requirements In the table above, period is an indicator that expresses the time interval between each time, so it is classified in the frequency domain. See also Records service","title":"Visualizations"},{"location":"design/visualizations/#visualizations","text":"CARET is a tool for performance evaluation. For evaluation, quantification and visualization would be sufficient. For analysis, on the other hand, various factors are involved in behavior and performance, so it is necessary to investigate from multiple perspectives. CARET has multiple visualizations for evaluation and analysis APIs that are readily available. Also, it's also possible to directly acquire and evaluate the data on your own (see Processing trace data for detail).","title":"Visualizations"},{"location":"design/visualizations/#policy","text":"","title":"Policy"},{"location":"design/visualizations/#evaluation-flow","text":"CARET has a large amount of information that can be obtained, and it is difficult to evaluate large-scale applications simply by displaying the recorded trace data in time series. So, it is important to focus on evaluation targets with appropriate granularity according to the purpose of evaluation. The following diagram shows the evaluation flow and analysis by adjusting the granularity. Here, the horizontal axis represents the visualization granularity and the vertical axis represents the processing granularity. CARET leads from issue detection to cause identification by changing the processing and visualization granularity from the rough granularity in the upper right to the fine granularity in the lower left. Detect issues: Detects performance issues on the target system. Identify issues: Identify the bottleneck that is causing the issue. Identify causes: Identifies the cause of the bottleneck. Processing granularity on the horizontal axis and visualization granularity on the vertical axis are explained in the following section.","title":"Evaluation flow"},{"location":"design/visualizations/#visualization-granularity","text":"The granularity of visualization can be ordered in coarse order as follows Statistic Histogram Heatmap Bar graph / Line graph Time-series trace data The coarser granularity, the more time information is aggregated to evaluate the measurement as a whole. The most granular statistics are suitable for regression testing. On the other hand, the finer granularity, the more detailed information is expressed, so it is more suitable for analysis. evaluation Latency and response time are some of the indicators to evaluate performance. The most detailed information is a time-series graph of each trace data.","title":"Visualization granularity"},{"location":"design/visualizations/#processing-granularity","text":"The processing granularity can be ordered in coarse order as follows. path node / communication callbackCurrent CARET does not support measurement of arbitrary functions or DDS enqueue/dequeue. function Path is suitable for evaluation of system performance, while node and callback are suitable for evaluation of functional performance. Notice Currently CARET does not support measurement of arbitrary functions or DDS enqueue/dequeue or system calls. See also Latency definition","title":"Processing granularity"},{"location":"design/visualizations/#time-domain-and-frequency-domain","text":"We described behavior and indicator in terms of visualization granularity, but there are multiple indicators, such as latency and frequency. When considering which indicator to use, it is useful to consider the time domain indicators and frequency domain indicators. Time Domain Indicators (ex: callback execution time [s]) Frequency Domain Indicators (ex: topic frequency [Hz]) Both have their pros and cons. Time Domain Indicators Frequency Domain Indicators Indicator Latency, Response time Frequency (, Period) Pros Easy to compare with system requirements No need to define latency or path Cons Need to define latency or path Difficult to compare with system requirements In the table above, period is an indicator that expresses the time interval between each time, so it is classified in the frequency domain. See also Records service","title":"Time domain and Frequency domain"},{"location":"faq/","text":"FAQ # Installation # Setup fails # In case you encounter errors during setup or build process, please make sure to use an appropriate branch for your environment ROS 2 Galactic, Ubuntu 20.04: galactic branch ROS 2 Humble, Ubuntu 22.04: main branch It's also important to delete ./build ./install and ./src directory before rebuilding CARET if you have built CARET using wrong settings CLI tool doesn't work # In case CLI tool execution fails, please make sure to perform CARET environment settings source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Warning CARET CLI tool doesn't work properly in Anaconda environment. Please use pure Python. Visualization # Result (plot, message_flow, etc.) is not outputted, or there seems something wrong with the result # Please use the following commands for verification ros2 caret check_caret_rclcpp to check if a target application is built with CARET/rclcpp ros2 caret check_ctf to check if tracing data is recorded properly Please make sure the followings: A target application is built with CARET/rclcpp CARET environment is set properly before running a target application export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so) source ~/ros2_caret_ws/install/local_setup.bash LTTng trace is started before running a target application ros2 trace -s e2e_sample -k -u \"ros2*\" or consider to use launch file Trace data is not discarded In case trace data is discarded, use Trace filter The size of trace data is proper If the size of trace data is extremely small (e.g. only few KByte) and a target application has lots of nodes, the maximum number of file descriptors may not be enough. It can be increased by ulimit -n 65536 See Recording for more details Parts of results are not outputted # If certain nodes are not traced but some nodes are traced, some packages may be built without CARET/rclcpp. Please make sure <depend>rclcpp</depend> is described in package.xml Another possibility is that some nodes can't be analyzed due to CARET's limitations: CARET cannot analyze a node which has two or more timer callbacks with the same period time setting CARET cannot analyze a node which has two or more subscription callbacks with the same topic name Callback information in such nodes are not outputted. Also, message flow will be discontinued at such nodes TraceResultAnalyzeError: Failed to find error occurs # The error occurs if information in an architecture file and trace data are inconsistent with each other Please modify the architecture file or check recording process e.g. TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)() Visualization (callback) # Callback frequency is smaller than expected value # Plot.create_callback_frequency_plot calculates frequency from one second to one second. It counts how many times a callback function is called for a second, and just uses the count as frequency. Therefore, the frequency on the last term tends to small because the last term is usually shorter than one second Another possibility is that the frequency of a subscription callback will be small if it receives topics not periodically but infrequently. Also, the frequency of a timer callback will be small if the timer dynamically stops/starts Callback latency is bigger than expected value # Some nodes may run initialization process. In this case, the latency time calculated by Plot.create_callback_latency_plot is huge on the first execution Visualization (message flow) # Message flow is discontinued # If parts of nodes/communications don't run at all during recording, message flow stops on the way and such nodes/communications are not displayed on y-axis Please make sure that all nodes/communications in a target path run during recording, or modify a target path to analyze actually working path Another possibility is that a target path includes a node which CARET cannot analyze due to its limitations as explained above What is a gray color rectangle in a message flow diagram? # A rectangle in a message flow diagram indicates a period from the entry to the exit of a callback function, while a line shows a flow of topics Note: a rectangle is not always illustrated Huge delay between topic publication and callback start # In a message flow diagram, term from ooo/rclcpp_publish to ooo/callback_start means latency from when a topic is published to when the following callback starts It includes the following time: Communication (topic) latency Wait by ROS scheduler Wait by OS scheduler In most cases, it doesn't take so much time. In case the time is huge, the followings are possible causes: There is a problem in communication An executor cannot wake up because other processes occupy CPU A callback cannot wake up because other callbacks in the same callback group occupy the executor Processing time of a callback is longer than topic subscription period Message flow looks split # Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 50 Hz, while Node_B publishes a topic at 10 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks split at Node_C . It's because Node_C publishes 5 topics while receiving 1 topic from Node_B Note: A similar phenomenon will happen even if Callback c0 is a timer callback Message flow looks dropped # Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 10 Hz, while Node_B publishes a topic at 50 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks disconnected at Node_C four times every five messages. It's because Node_C publishes 1 topic while receiving 5 topics from Node_B . So 4 topics don't have a corresponding topic to be published to Node_D Note: A similar phenomenon will happen even if Callback c0 is a timer callback How response time is calculated? # In general, response time is the time a system or functional unit takes to react to a given input ( reference ). Response time calculated by CARET is the time it takes for input data to arrive at the last node. It doesn't include processing time at the first/last node nor latency of an actuator. It's calculated as the sum of communication latency time (from the time when a node publishes a topic to the time when the following node subscribes the topic) and node latency time (from the time when a node subscribes a topic to the time when it publishes another topic) in a path In the following diagram, input data at point A is first reflected with output at point X ( ResponseTime_Best ) ResponseTime_Best can be considered as a path (dataflow) latency time ResponseTime_Best can be considered as a happy case, which is contrary to the following worst case scenario Assuming that input information is created by a sensor such as an object detection sensor, delay in a sensor should be considered. For instance, if a new object appears at point B, the time from point B to point A should added to the response time. The worst case scenario is that a new object appears just after the previous flow (point C). Response time for the worst case is shown as ResponseTime_Worst CARET can calculate both ResponseTime_Best and ResponseTime_Worst using the following APIs: response_time.to_best_case_timeseries() , response_time.to_best_case_histogram() response_time.to_worst_case_timeseries() , response_time.to_best_worst_histogram() CARET also provides response_time.to_histogram() API. It creates histogram assuming a new object appears from point C to point A at intervals of histogram bin size","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#installation","text":"","title":"Installation"},{"location":"faq/#setup-fails","text":"In case you encounter errors during setup or build process, please make sure to use an appropriate branch for your environment ROS 2 Galactic, Ubuntu 20.04: galactic branch ROS 2 Humble, Ubuntu 22.04: main branch It's also important to delete ./build ./install and ./src directory before rebuilding CARET if you have built CARET using wrong settings","title":"Setup fails"},{"location":"faq/#cli-tool-doesnt-work","text":"In case CLI tool execution fails, please make sure to perform CARET environment settings source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Warning CARET CLI tool doesn't work properly in Anaconda environment. Please use pure Python.","title":"CLI tool doesn't work"},{"location":"faq/#visualization","text":"","title":"Visualization"},{"location":"faq/#result-plot-message_flow-etc-is-not-outputted-or-there-seems-something-wrong-with-the-result","text":"Please use the following commands for verification ros2 caret check_caret_rclcpp to check if a target application is built with CARET/rclcpp ros2 caret check_ctf to check if tracing data is recorded properly Please make sure the followings: A target application is built with CARET/rclcpp CARET environment is set properly before running a target application export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so) source ~/ros2_caret_ws/install/local_setup.bash LTTng trace is started before running a target application ros2 trace -s e2e_sample -k -u \"ros2*\" or consider to use launch file Trace data is not discarded In case trace data is discarded, use Trace filter The size of trace data is proper If the size of trace data is extremely small (e.g. only few KByte) and a target application has lots of nodes, the maximum number of file descriptors may not be enough. It can be increased by ulimit -n 65536 See Recording for more details","title":"Result (plot, message_flow, etc.) is not outputted, or there seems something wrong with the result"},{"location":"faq/#parts-of-results-are-not-outputted","text":"If certain nodes are not traced but some nodes are traced, some packages may be built without CARET/rclcpp. Please make sure <depend>rclcpp</depend> is described in package.xml Another possibility is that some nodes can't be analyzed due to CARET's limitations: CARET cannot analyze a node which has two or more timer callbacks with the same period time setting CARET cannot analyze a node which has two or more subscription callbacks with the same topic name Callback information in such nodes are not outputted. Also, message flow will be discontinued at such nodes","title":"Parts of results are not outputted"},{"location":"faq/#traceresultanalyzeerror-failed-to-find-error-occurs","text":"The error occurs if information in an architecture file and trace data are inconsistent with each other Please modify the architecture file or check recording process e.g. TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)()","title":"TraceResultAnalyzeError: Failed to find error occurs"},{"location":"faq/#visualization-callback","text":"","title":"Visualization (callback)"},{"location":"faq/#callback-frequency-is-smaller-than-expected-value","text":"Plot.create_callback_frequency_plot calculates frequency from one second to one second. It counts how many times a callback function is called for a second, and just uses the count as frequency. Therefore, the frequency on the last term tends to small because the last term is usually shorter than one second Another possibility is that the frequency of a subscription callback will be small if it receives topics not periodically but infrequently. Also, the frequency of a timer callback will be small if the timer dynamically stops/starts","title":"Callback frequency is smaller than expected value"},{"location":"faq/#callback-latency-is-bigger-than-expected-value","text":"Some nodes may run initialization process. In this case, the latency time calculated by Plot.create_callback_latency_plot is huge on the first execution","title":"Callback latency is bigger than expected value"},{"location":"faq/#visualization-message-flow","text":"","title":"Visualization (message flow)"},{"location":"faq/#message-flow-is-discontinued","text":"If parts of nodes/communications don't run at all during recording, message flow stops on the way and such nodes/communications are not displayed on y-axis Please make sure that all nodes/communications in a target path run during recording, or modify a target path to analyze actually working path Another possibility is that a target path includes a node which CARET cannot analyze due to its limitations as explained above","title":"Message flow is discontinued"},{"location":"faq/#what-is-a-gray-color-rectangle-in-a-message-flow-diagram","text":"A rectangle in a message flow diagram indicates a period from the entry to the exit of a callback function, while a line shows a flow of topics Note: a rectangle is not always illustrated","title":"What is a gray color rectangle in a message flow diagram?"},{"location":"faq/#huge-delay-between-topic-publication-and-callback-start","text":"In a message flow diagram, term from ooo/rclcpp_publish to ooo/callback_start means latency from when a topic is published to when the following callback starts It includes the following time: Communication (topic) latency Wait by ROS scheduler Wait by OS scheduler In most cases, it doesn't take so much time. In case the time is huge, the followings are possible causes: There is a problem in communication An executor cannot wake up because other processes occupy CPU A callback cannot wake up because other callbacks in the same callback group occupy the executor Processing time of a callback is longer than topic subscription period","title":"Huge delay between topic publication and callback start"},{"location":"faq/#message-flow-looks-split","text":"Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 50 Hz, while Node_B publishes a topic at 10 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks split at Node_C . It's because Node_C publishes 5 topics while receiving 1 topic from Node_B Note: A similar phenomenon will happen even if Callback c0 is a timer callback","title":"Message flow looks split"},{"location":"faq/#message-flow-looks-dropped","text":"Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 10 Hz, while Node_B publishes a topic at 50 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks disconnected at Node_C four times every five messages. It's because Node_C publishes 1 topic while receiving 5 topics from Node_B . So 4 topics don't have a corresponding topic to be published to Node_D Note: A similar phenomenon will happen even if Callback c0 is a timer callback","title":"Message flow looks dropped"},{"location":"faq/#how-response-time-is-calculated","text":"In general, response time is the time a system or functional unit takes to react to a given input ( reference ). Response time calculated by CARET is the time it takes for input data to arrive at the last node. It doesn't include processing time at the first/last node nor latency of an actuator. It's calculated as the sum of communication latency time (from the time when a node publishes a topic to the time when the following node subscribes the topic) and node latency time (from the time when a node subscribes a topic to the time when it publishes another topic) in a path In the following diagram, input data at point A is first reflected with output at point X ( ResponseTime_Best ) ResponseTime_Best can be considered as a path (dataflow) latency time ResponseTime_Best can be considered as a happy case, which is contrary to the following worst case scenario Assuming that input information is created by a sensor such as an object detection sensor, delay in a sensor should be considered. For instance, if a new object appears at point B, the time from point B to point A should added to the response time. The worst case scenario is that a new object appears just after the previous flow (point C). Response time for the worst case is shown as ResponseTime_Worst CARET can calculate both ResponseTime_Best and ResponseTime_Worst using the following APIs: response_time.to_best_case_timeseries() , response_time.to_best_case_histogram() response_time.to_worst_case_timeseries() , response_time.to_best_worst_histogram() CARET also provides response_time.to_histogram() API. It creates histogram assuming a new object appears from point C to point A at intervals of histogram bin size","title":"How response time is calculated?"},{"location":"installation/installation/","text":"Installation # Requirements # CARET is confirmed to run on the platforms shown in the following table with supported version. dependent platform supported version ROS Humble Ubuntu 22.04 LTTng stable-2.13 Linux Kernel 5.15.x Python3 3.10.x The recent version, after v0.3.0, of CARET supports only the combination of ROS 2 Humble and Ubuntu 22.04. If you want to run CARET on ROS 2 Galactic and Ubuntu 20.04, please refer to documents for v0.2.3 Installation # Installation using meta repository is the least time-consuming way to install CARET. With meta repository and Ansible, you can skip the laborious manual setup which is explained in manual installation(./manual_installation.md) section (written in Japanese). Please execute the following steps on Ubuntu 20.04. The order is important so that you have to follow the steps in order. Clone caret and enter the directory. git clone https://github.com/tier4/caret.git ros2_caret_ws cd ros2_caret_ws main branch is dedicated for ROS 2 Humble. If you want to use CARET for ROS 2 Galactic, please execute git checkout galactic in ros2_caret_ws directory. Create the src directory and clone repositories into it. CARET uses vcstool to construct workspaces. mkdir src vcs import src < caret.repos Run setup_caret.sh . ./setup_caret.sh Build the workspace. source /opt/ros/humble/setup.bash colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release Check whether CARET (ros2-tracing) is enabled. CARET inherits some functions from ros2-tracing . source ~/ros2_caret_ws/install/local_setup.bash ros2 run tracetools status # return Tracing enabled If you see Tracing enabled , you can continue to apply CARET to your application.","title":"Installation"},{"location":"installation/installation/#installation","text":"","title":"Installation"},{"location":"installation/installation/#requirements","text":"CARET is confirmed to run on the platforms shown in the following table with supported version. dependent platform supported version ROS Humble Ubuntu 22.04 LTTng stable-2.13 Linux Kernel 5.15.x Python3 3.10.x The recent version, after v0.3.0, of CARET supports only the combination of ROS 2 Humble and Ubuntu 22.04. If you want to run CARET on ROS 2 Galactic and Ubuntu 20.04, please refer to documents for v0.2.3","title":"Requirements"},{"location":"installation/installation/#installation_1","text":"Installation using meta repository is the least time-consuming way to install CARET. With meta repository and Ansible, you can skip the laborious manual setup which is explained in manual installation(./manual_installation.md) section (written in Japanese). Please execute the following steps on Ubuntu 20.04. The order is important so that you have to follow the steps in order. Clone caret and enter the directory. git clone https://github.com/tier4/caret.git ros2_caret_ws cd ros2_caret_ws main branch is dedicated for ROS 2 Humble. If you want to use CARET for ROS 2 Galactic, please execute git checkout galactic in ros2_caret_ws directory. Create the src directory and clone repositories into it. CARET uses vcstool to construct workspaces. mkdir src vcs import src < caret.repos Run setup_caret.sh . ./setup_caret.sh Build the workspace. source /opt/ros/humble/setup.bash colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release Check whether CARET (ros2-tracing) is enabled. CARET inherits some functions from ros2-tracing . source ~/ros2_caret_ws/install/local_setup.bash ros2 run tracetools status # return Tracing enabled If you see Tracing enabled , you can continue to apply CARET to your application.","title":"Installation"},{"location":"installation/manual_installation/","text":"Manual installation # \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb # LTTng \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb \u8a73\u7d30\u306f LTTng \u306e\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt-add-repository ppa:lttng/stable-2.12 sudo apt-get update sudo apt-get install lttng-tools liblttng-ust-dev sudo apt-get install python3-babeltrace python3-lttng ROS 2 Humble \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3001\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3002 \u8a73\u7d30\u306f ROS2 \u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt update && sudo apt install -y \\ build-essential \\ cmake \\ git \\ python3-colcon-common-extensions \\ python3-flake8 \\ python3-pip \\ python3-pytest-cov \\ python3-rosdep \\ python3-setuptools \\ python3-vcstool \\ python3-bt2 \\ wget python3 -m pip install -U \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest \\ setuptools \\ colorcet sudo apt install ros-humble-desktop ros2 trace \u95a2\u9023\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt install -y \\ ros-humble-ros2trace \\ ros-humble-ros2trace-analysis \\ ros-humble-tracetools \\ ros-humble-tracetools-analysis \\ ros-humble-tracetools-launch \\ ros-humble-tracetools-read \\ ros-humble-tracetools-test \\ ros-humble-tracetools-trace caret \u306e\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt update && sudo apt install -y \\ graphviz \\ graphviz-dev python3 -m pip install -U \\ pytest-mock \\ pybind11 \\ 'pandas>=1.4.0' \\ bokeh \\ pandas-bokeh \\ jupyterlab \\ graphviz # julyterlab\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u6642\u306b[ImportError: The Jupyter Server requires tornado >=6.1.0]\u3068\u51fa\u308b\u5834\u5408\u306f\u4ee5\u4e0b\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068 # pip install tornado --upgrade CARET \u306e\u30d3\u30eb\u30c9 # mkdir -p ~/ros2_caret_ws/src cd ~/ros2_caret_ws wget https://raw.githubusercontent.com/tier4/caret/main/caret.repos vcs import src < caret.repos rosdep install \\ --from-paths src --ignore-src \\ --rosdistro humble -y \\ --skip-keys \"console_bridge fastcdr fastrtps rti-connext-dds-5.3.1 urdfdom_headers\" # [ERROR: the following packages/stacks could not have their rosdep keys resolved] \u3068\u51fa\u308b\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u3092\u8a66\u3059\u3053\u3068 # rosdep init # rosdep update source /opt/ros/humble/setup.bash # \u30d5\u30a9\u30fc\u30af\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30d8\u30c3\u30c0\u30fc\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u7528\u3055\u305b\u308b\u305f\u3081\u306e\u30b7\u30f3\u30dc\u30ea\u30c3\u30af\u30ea\u30f3\u30af\u3092\u4f5c\u6210 ln -sf ~/ros2_caret_ws/src/ros-tracing/ros2_tracing/tracetools/include/tracetools ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_action/include/rclcpp_action ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_components/include/rclcpp_components/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_lifecycle/include/rclcpp_lifecycle/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ # CARET\u306e\u30d3\u30eb\u30c9 colcon build --cmake-args -DCMAKE_BUILD_TYPE = Release -DBUILD_TESTING = off --symlink-install ros2 tracing \u304c\u6709\u52b9\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d $ source ~/ros2_caret_ws/install/local_setup.bash $ ros2 run tracetools status Tracing enabled","title":"Manual Installation"},{"location":"installation/manual_installation/#manual-installation","text":"","title":"Manual installation"},{"location":"installation/manual_installation/#_1","text":"LTTng \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb \u8a73\u7d30\u306f LTTng \u306e\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt-add-repository ppa:lttng/stable-2.12 sudo apt-get update sudo apt-get install lttng-tools liblttng-ust-dev sudo apt-get install python3-babeltrace python3-lttng ROS 2 Humble \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3001\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3002 \u8a73\u7d30\u306f ROS2 \u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt update && sudo apt install -y \\ build-essential \\ cmake \\ git \\ python3-colcon-common-extensions \\ python3-flake8 \\ python3-pip \\ python3-pytest-cov \\ python3-rosdep \\ python3-setuptools \\ python3-vcstool \\ python3-bt2 \\ wget python3 -m pip install -U \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest \\ setuptools \\ colorcet sudo apt install ros-humble-desktop ros2 trace \u95a2\u9023\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt install -y \\ ros-humble-ros2trace \\ ros-humble-ros2trace-analysis \\ ros-humble-tracetools \\ ros-humble-tracetools-analysis \\ ros-humble-tracetools-launch \\ ros-humble-tracetools-read \\ ros-humble-tracetools-test \\ ros-humble-tracetools-trace caret \u306e\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt update && sudo apt install -y \\ graphviz \\ graphviz-dev python3 -m pip install -U \\ pytest-mock \\ pybind11 \\ 'pandas>=1.4.0' \\ bokeh \\ pandas-bokeh \\ jupyterlab \\ graphviz # julyterlab\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u6642\u306b[ImportError: The Jupyter Server requires tornado >=6.1.0]\u3068\u51fa\u308b\u5834\u5408\u306f\u4ee5\u4e0b\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068 # pip install tornado --upgrade","title":"\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb"},{"location":"installation/manual_installation/#caret","text":"mkdir -p ~/ros2_caret_ws/src cd ~/ros2_caret_ws wget https://raw.githubusercontent.com/tier4/caret/main/caret.repos vcs import src < caret.repos rosdep install \\ --from-paths src --ignore-src \\ --rosdistro humble -y \\ --skip-keys \"console_bridge fastcdr fastrtps rti-connext-dds-5.3.1 urdfdom_headers\" # [ERROR: the following packages/stacks could not have their rosdep keys resolved] \u3068\u51fa\u308b\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u3092\u8a66\u3059\u3053\u3068 # rosdep init # rosdep update source /opt/ros/humble/setup.bash # \u30d5\u30a9\u30fc\u30af\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30d8\u30c3\u30c0\u30fc\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u7528\u3055\u305b\u308b\u305f\u3081\u306e\u30b7\u30f3\u30dc\u30ea\u30c3\u30af\u30ea\u30f3\u30af\u3092\u4f5c\u6210 ln -sf ~/ros2_caret_ws/src/ros-tracing/ros2_tracing/tracetools/include/tracetools ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_action/include/rclcpp_action ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_components/include/rclcpp_components/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_lifecycle/include/rclcpp_lifecycle/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ # CARET\u306e\u30d3\u30eb\u30c9 colcon build --cmake-args -DCMAKE_BUILD_TYPE = Release -DBUILD_TESTING = off --symlink-install ros2 tracing \u304c\u6709\u52b9\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d $ source ~/ros2_caret_ws/install/local_setup.bash $ ros2 run tracetools status Tracing enabled","title":"CARET \u306e\u30d3\u30eb\u30c9"},{"location":"recording/","text":"Recording with CARET # Steps to record trace data with CARET # Build a target application with CARET and check it ( See details ) (Optional) Configure trace filter ( See details ) Record the application ( See details ) Validate trace data ( See details ) Other tips # CLI tools ROS time (sim_time) support","title":"Recording"},{"location":"recording/#recording-with-caret","text":"","title":"Recording with CARET"},{"location":"recording/#steps-to-record-trace-data-with-caret","text":"Build a target application with CARET and check it ( See details ) (Optional) Configure trace filter ( See details ) Record the application ( See details ) Validate trace data ( See details )","title":"Steps to record trace data with CARET"},{"location":"recording/#other-tips","text":"CLI tools ROS time (sim_time) support","title":"Other tips"},{"location":"recording/build_check/","text":"Build with CARET # Build a target application with CARET # A target application should be built with CARET/rclcpp to record trace data. If you have already built the application without CARET/rclcpp, you have to build the application with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. Also, -DBUILD_TESTING=OFF should be given to build option. cd <path-to-workspace> source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after ROS 2's setup.bash colcon build --symlink-install --cmake-args -DBUILD_TESTING = OFF Reason for building a target application with CARET/rclcpp CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET. Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application. In order to apply rclcpp which has the additional tracepoints, the application have to be built with CARET/rclcpp again. Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as demo_nodes_cpp . If you want to trace such pre-build packages, please build them again from source code. Reason for giving -DBUILD_TESTING=OFF To use CARET, you need to use forked shared libraries and headers such as CARET/rclcpp. In the test codes, CARET/rclcpp is not available due to loading priority issues for headers. Depending on the version of CARET, conflicts may occur between the shared libraries of ros-rclcpp and the headers of CARET/rclcpp, resulting in compile errors. Therefore, test codes have to be excluded from building. Check whether CARET/rclcpp is applied to each package # You can check whether a target application is successfully built with CARET/rclcpp using ros2 caret check_caret_rclcpp command. ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Output Message Description All packages are built using caret-rclcpp There is no problem The following packages have not been built using caret-rclcpp CARET/rclcpp is not applied to the listed packages (Please read the next section to fix it) How to fix # In case CARET/rclcpp is not applied to the package you want to analyze, you need to fix it. The followings show possible causes and solutions. Case 1: All packages are listed as CARET/rclcpp is not applied Make sure you applied CARET's local_setup.bash after ROS2's setup.bash (keep the order) Case 2: Some, but not all, packages are listed as CARET/rclcpp is not applied Make sure you have the following line in package.xml in the listed package <depend>rclcpp</depend> Info The listed packages are not traced while other packages built with CARET/rclcpp are properly traced. Therefore, you can ignore this message if you don't need to trace/analyze the listed packages.","title":"Build and check"},{"location":"recording/build_check/#build-with-caret","text":"","title":"Build with CARET"},{"location":"recording/build_check/#build-a-target-application-with-caret","text":"A target application should be built with CARET/rclcpp to record trace data. If you have already built the application without CARET/rclcpp, you have to build the application with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. Also, -DBUILD_TESTING=OFF should be given to build option. cd <path-to-workspace> source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after ROS 2's setup.bash colcon build --symlink-install --cmake-args -DBUILD_TESTING = OFF Reason for building a target application with CARET/rclcpp CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET. Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application. In order to apply rclcpp which has the additional tracepoints, the application have to be built with CARET/rclcpp again. Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as demo_nodes_cpp . If you want to trace such pre-build packages, please build them again from source code. Reason for giving -DBUILD_TESTING=OFF To use CARET, you need to use forked shared libraries and headers such as CARET/rclcpp. In the test codes, CARET/rclcpp is not available due to loading priority issues for headers. Depending on the version of CARET, conflicts may occur between the shared libraries of ros-rclcpp and the headers of CARET/rclcpp, resulting in compile errors. Therefore, test codes have to be excluded from building.","title":"Build a target application with CARET"},{"location":"recording/build_check/#check-whether-caretrclcpp-is-applied-to-each-package","text":"You can check whether a target application is successfully built with CARET/rclcpp using ros2 caret check_caret_rclcpp command. ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Output Message Description All packages are built using caret-rclcpp There is no problem The following packages have not been built using caret-rclcpp CARET/rclcpp is not applied to the listed packages (Please read the next section to fix it)","title":"Check whether CARET/rclcpp is applied to each package"},{"location":"recording/build_check/#how-to-fix","text":"In case CARET/rclcpp is not applied to the package you want to analyze, you need to fix it. The followings show possible causes and solutions. Case 1: All packages are listed as CARET/rclcpp is not applied Make sure you applied CARET's local_setup.bash after ROS2's setup.bash (keep the order) Case 2: Some, but not all, packages are listed as CARET/rclcpp is not applied Make sure you have the following line in package.xml in the listed package <depend>rclcpp</depend> Info The listed packages are not traced while other packages built with CARET/rclcpp are properly traced. Therefore, you can ignore this message if you don't need to trace/analyze the listed packages.","title":"How to fix"},{"location":"recording/cli_tool/","text":"CLI tools for recording # CARET provides CLI tools which can be utilized at recording process. Info CARET environment settings need to be performed to use these CLI tools by the following commands. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash Build results validation # This command checks whether a target application is successfully built with CARET/rclcpp. ( See details ) ros2 caret check_caret_rclcpp --workspace <path-to-workspace> ---Output text as below--- INFO : 2022 -09-29 20 :18:43 | All packages are built using caret-rclcpp. Trace data validation # This command checks whether a recording is successful. ( See details ) If there are problems with the recorded data, warning messages will be displayed ros2 caret check_ctf --trace_dir <path-to-trace-data> Node summary # This command displays the number of events per node. ros2 caret node_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= node_name | number_of_trace_points ----------------------+-------------------------- /message_driven_node | 4207 /timer_driven_node | 3630 /filter_node | 2680 /drive_node | 2146 /sensor_dummy_node | 2144 /actuator_dummy_node | 1609 Topic summary # This command displays the number of events per topic. ros2 caret topic_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= topic_name | number_of_trace_points -------------------+-------------------------- /drive | 2668 /topic1 | 2668 /topic2 | 2668 /topic4 | 2658 /topic3 | 2478 /parameter_events | 66 /rosout | 6 Info If the number of events is too huge to handle, trace filtering is a reasonable choice to exclude unnecessary nodes/topics based on the output result. Tracepoint summary # This command displays all tracepoints included in the trace data and the number of events collected by tracepoints. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 4216 ros2:callback_start | 4216 ros2_caret:dds_write | 2790 ros2_caret:dds_bind_addr_to_stamp | 2790 ros2:rcl_publish | 2650 ros2:rclcpp_publish | 2650 ros2:dispatch_subscription_callback | 2620 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0 Filtering for summary commands # Executing a summary command for huge trace data (e.g., more than 10 minutes) takes time. The following two options allow you to filter the load range of trace data used for summary output. In both options, the argument type is float and the unit of time is second. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --duration_filter <DURATION> <OFFSET> ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --strip_filter <LSTRIP> <RSTRIP> --duration_filter [DURATION] [OFFSET] Load only this [DURATION] from [OFFSET]. --strip_filter [LSTRIP] [RSTRIP] Ignore trace data for specified seconds from start/end. ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 Filtered trace range | 17 :34:15 ~ 17 :34:45 Filtered trace duration | 0 :00:29 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 2385 ros2:callback_start | 2385 ros2:dispatch_subscription_callback | 1485 ros2:rcl_publish | 1484 ros2_caret:dds_write | 1484 ros2_caret:dds_bind_addr_to_stamp | 1484 ros2:rclcpp_publish | 1484 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0","title":"CLI tools"},{"location":"recording/cli_tool/#cli-tools-for-recording","text":"CARET provides CLI tools which can be utilized at recording process. Info CARET environment settings need to be performed to use these CLI tools by the following commands. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash","title":"CLI tools for recording"},{"location":"recording/cli_tool/#build-results-validation","text":"This command checks whether a target application is successfully built with CARET/rclcpp. ( See details ) ros2 caret check_caret_rclcpp --workspace <path-to-workspace> ---Output text as below--- INFO : 2022 -09-29 20 :18:43 | All packages are built using caret-rclcpp.","title":"Build results validation"},{"location":"recording/cli_tool/#trace-data-validation","text":"This command checks whether a recording is successful. ( See details ) If there are problems with the recorded data, warning messages will be displayed ros2 caret check_ctf --trace_dir <path-to-trace-data>","title":"Trace data validation"},{"location":"recording/cli_tool/#node-summary","text":"This command displays the number of events per node. ros2 caret node_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= node_name | number_of_trace_points ----------------------+-------------------------- /message_driven_node | 4207 /timer_driven_node | 3630 /filter_node | 2680 /drive_node | 2146 /sensor_dummy_node | 2144 /actuator_dummy_node | 1609","title":"Node summary"},{"location":"recording/cli_tool/#topic-summary","text":"This command displays the number of events per topic. ros2 caret topic_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= topic_name | number_of_trace_points -------------------+-------------------------- /drive | 2668 /topic1 | 2668 /topic2 | 2668 /topic4 | 2658 /topic3 | 2478 /parameter_events | 66 /rosout | 6 Info If the number of events is too huge to handle, trace filtering is a reasonable choice to exclude unnecessary nodes/topics based on the output result.","title":"Topic summary"},{"location":"recording/cli_tool/#tracepoint-summary","text":"This command displays all tracepoints included in the trace data and the number of events collected by tracepoints. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 4216 ros2:callback_start | 4216 ros2_caret:dds_write | 2790 ros2_caret:dds_bind_addr_to_stamp | 2790 ros2:rcl_publish | 2650 ros2:rclcpp_publish | 2650 ros2:dispatch_subscription_callback | 2620 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0","title":"Tracepoint summary"},{"location":"recording/cli_tool/#filtering-for-summary-commands","text":"Executing a summary command for huge trace data (e.g., more than 10 minutes) takes time. The following two options allow you to filter the load range of trace data used for summary output. In both options, the argument type is float and the unit of time is second. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --duration_filter <DURATION> <OFFSET> ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --strip_filter <LSTRIP> <RSTRIP> --duration_filter [DURATION] [OFFSET] Load only this [DURATION] from [OFFSET]. --strip_filter [LSTRIP] [RSTRIP] Ignore trace data for specified seconds from start/end. ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 Filtered trace range | 17 :34:15 ~ 17 :34:45 Filtered trace duration | 0 :00:29 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 2385 ros2:callback_start | 2385 ros2:dispatch_subscription_callback | 1485 ros2:rcl_publish | 1484 ros2_caret:dds_write | 1484 ros2_caret:dds_bind_addr_to_stamp | 1484 ros2:rclcpp_publish | 1484 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0","title":"Filtering for summary commands"},{"location":"recording/recording/","text":"Recording # Recording with CARET # CARET uses LTTng for tracing a target application. A LTTng session has to be started before running the application. This page explains two different ways for it: Starting LTTng session manually and Starting LTTng session using ROS launch system. Explanation in this page assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws . Starting LTTng session manually # Two terminals are needed for this method: One for starting a LTTng session, another for running a target application. Open a terminal and start a LTTng session with the following commands (Optional) ROS_TRACE_DIR variable is a destination directory where recorded trace data will be stored. Default is ~/.ros/tracing With \" -s \" option, you can give session name. The recorded trace data will be stored into ~/ros_ws/evaluate/e2e_sample in this sample Press \"Enter\" key to start a session source /opt/ros/humble/setup.bash # (Optional) Set a destination directory mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key Open another terminal and launch a target application Perform environment settings in the same order as below. CARET's local_setup.bash should be applied along with ROS 2's setup.bash as the target application refers to CARET/rclcpp # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash Set LD_PRELOAD to enable tracepoints provided by function hook export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) (Optional) Apply trace filtering . With configuration of trace filtering, CARET can ignore unnecessary nodes/topics. This function is useful for a large application # Apply filter directly export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Apply filter using a setting file source ./caret_topic_filter.bash Launch the target application ros2 run caret_demos end_to_end_sample Stop the target application Press \"Enter\" key to stop the LTTng session in the terminal where the LTTng session runs Info A LTTng session needs to be started before running a target application. Otherwise, some trace points won't be recorded and analysis will fail later. Info You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with ulimit -n command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; ulimit -n 65536 . Starting LTTng session via ROS launch # You can start LTTng session using ROS launch system. When you start a LTTng session in one terminal, you have to open another terminal for executing a target application as explained above. Operating multiple terminals is laborious for users. Launching LTTng session along with application by ROS launch is a reasonable way to apply CARET repeatedly. Create a launch file for a target application in ROS general manner if you haven't made it # launch/end_to_end_sample.launch.py import launch import launch_ros.actions def generate_launch_description (): return launch . LaunchDescription ([ launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Add description to start a LTTng session # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace def generate_launch_description (): return launch . LaunchDescription ([ Trace ( session_name = 'e2e_sample' , events_kernel = [], events_ust = [ 'ros2*' ] ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Launch a target application and a LTTng session via the launch file Environment settings are still needed, but all operations are performed in just one terminal source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) source ./caret_topic_filter.bash ros2 launch caret_demos end_to_end_sample_with_lttng_session.launch.py Advanced: Useful settings for launch file # The following script shows advanced settings for a launch file caret_session option is used to set a session name. If not assigned, datetime (YYYYMMDD-HHMMSS) is used caret_light option is used to add another event filter. Only events specified in caret_event variable are recorded. In this example, high level events, such as ros2:rclcpp layer, are recorded if caret_light is set to \"true\". This setting will be helpful to record a huge application. Please refer to tracepoint summary to find which events are recorded, and modify caret_event as you want. # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace import sys import datetime from distutils.util import strtobool def generate_launch_description (): caret_session = \"\" caret_event = [ \"ros2*\" ] caret_light = True for arg in sys . argv : if arg . startswith ( \"caret_session:=\" ): caret_session = arg . split ( \":=\" )[ 1 ] elif arg . startswith ( \"caret_light:=\" ): try : caret_light = strtobool ( arg . split ( \":=\" )[ 1 ]) # 0 or 1 except : print ( \"Invalid arguments 'caret_light'.\" ) print ( \"Start tracing with 'ros2*'.\" ) if caret_light : caret_event = [ \"ros2:*callback*\" , \"ros2:dispatch*\" , \"ros2:rclcpp*\" , \"ros2_caret:rmw*\" , \"*callback_group*\" , \"ros2_caret:*executor\" , \"ros2_caret:dds_bind*\" , \"ros2:rcl_*init\" ] if caret_session == \"\" : dt_now = datetime . datetime . now () caret_session = \"autoware_launch_trace_\" + dt_now . strftime ( \"%Y%m %d -%H%M%S\" ) return launch . LaunchDescription ([ Trace ( session_name = caret_session , events_kernel = [], events_ust = caret_event ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ])","title":"Recording"},{"location":"recording/recording/#recording","text":"","title":"Recording"},{"location":"recording/recording/#recording-with-caret","text":"CARET uses LTTng for tracing a target application. A LTTng session has to be started before running the application. This page explains two different ways for it: Starting LTTng session manually and Starting LTTng session using ROS launch system. Explanation in this page assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws .","title":"Recording with CARET"},{"location":"recording/recording/#starting-lttng-session-manually","text":"Two terminals are needed for this method: One for starting a LTTng session, another for running a target application. Open a terminal and start a LTTng session with the following commands (Optional) ROS_TRACE_DIR variable is a destination directory where recorded trace data will be stored. Default is ~/.ros/tracing With \" -s \" option, you can give session name. The recorded trace data will be stored into ~/ros_ws/evaluate/e2e_sample in this sample Press \"Enter\" key to start a session source /opt/ros/humble/setup.bash # (Optional) Set a destination directory mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key Open another terminal and launch a target application Perform environment settings in the same order as below. CARET's local_setup.bash should be applied along with ROS 2's setup.bash as the target application refers to CARET/rclcpp # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash Set LD_PRELOAD to enable tracepoints provided by function hook export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) (Optional) Apply trace filtering . With configuration of trace filtering, CARET can ignore unnecessary nodes/topics. This function is useful for a large application # Apply filter directly export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Apply filter using a setting file source ./caret_topic_filter.bash Launch the target application ros2 run caret_demos end_to_end_sample Stop the target application Press \"Enter\" key to stop the LTTng session in the terminal where the LTTng session runs Info A LTTng session needs to be started before running a target application. Otherwise, some trace points won't be recorded and analysis will fail later. Info You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with ulimit -n command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; ulimit -n 65536 .","title":"Starting LTTng session manually"},{"location":"recording/recording/#starting-lttng-session-via-ros-launch","text":"You can start LTTng session using ROS launch system. When you start a LTTng session in one terminal, you have to open another terminal for executing a target application as explained above. Operating multiple terminals is laborious for users. Launching LTTng session along with application by ROS launch is a reasonable way to apply CARET repeatedly. Create a launch file for a target application in ROS general manner if you haven't made it # launch/end_to_end_sample.launch.py import launch import launch_ros.actions def generate_launch_description (): return launch . LaunchDescription ([ launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Add description to start a LTTng session # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace def generate_launch_description (): return launch . LaunchDescription ([ Trace ( session_name = 'e2e_sample' , events_kernel = [], events_ust = [ 'ros2*' ] ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Launch a target application and a LTTng session via the launch file Environment settings are still needed, but all operations are performed in just one terminal source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) source ./caret_topic_filter.bash ros2 launch caret_demos end_to_end_sample_with_lttng_session.launch.py","title":"Starting LTTng session via ROS launch"},{"location":"recording/recording/#advanced-useful-settings-for-launch-file","text":"The following script shows advanced settings for a launch file caret_session option is used to set a session name. If not assigned, datetime (YYYYMMDD-HHMMSS) is used caret_light option is used to add another event filter. Only events specified in caret_event variable are recorded. In this example, high level events, such as ros2:rclcpp layer, are recorded if caret_light is set to \"true\". This setting will be helpful to record a huge application. Please refer to tracepoint summary to find which events are recorded, and modify caret_event as you want. # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace import sys import datetime from distutils.util import strtobool def generate_launch_description (): caret_session = \"\" caret_event = [ \"ros2*\" ] caret_light = True for arg in sys . argv : if arg . startswith ( \"caret_session:=\" ): caret_session = arg . split ( \":=\" )[ 1 ] elif arg . startswith ( \"caret_light:=\" ): try : caret_light = strtobool ( arg . split ( \":=\" )[ 1 ]) # 0 or 1 except : print ( \"Invalid arguments 'caret_light'.\" ) print ( \"Start tracing with 'ros2*'.\" ) if caret_light : caret_event = [ \"ros2:*callback*\" , \"ros2:dispatch*\" , \"ros2:rclcpp*\" , \"ros2_caret:rmw*\" , \"*callback_group*\" , \"ros2_caret:*executor\" , \"ros2_caret:dds_bind*\" , \"ros2:rcl_*init\" ] if caret_session == \"\" : dt_now = datetime . datetime . now () caret_session = \"autoware_launch_trace_\" + dt_now . strftime ( \"%Y%m %d -%H%M%S\" ) return launch . LaunchDescription ([ Trace ( session_name = caret_session , events_kernel = [], events_ust = caret_event ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ])","title":"Advanced: Useful settings for launch file"},{"location":"recording/sim_time/","text":"ROS time (sim_time) support # Introduction # CARET uses system time to analyze trace data by default. It may be inconvenient, especially when treating trace data recorded with rosbag. These are examples: The flow of time in analysis results (e.g., time series graph) is different from that of ROS when playing rosbag with [-r RATE] option. For instance, 10 Hz becomes 2 Hz when rosbag was played with [-r 0.2] but analysis uses system time Time becomes different at every recording even if you use the same rosbag file, which makes comparing experimental results difficult This page explains how to use sim_time. Recording /clock topic # /clock topic needs to be recorded in trace data. /clock topis is recorded as ros2_caret:sim_time event in trace data. Open a new terminal and run the following commands before recording and running a target application. Info Remember to set use_sim_time=true for each node when launching a target application Remember to add --clock option when playing rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder You can check whether /clock is successfully recorded by the following command. babeltrace <path-to-trace-data> | cut -d ' ' -f 4 | sort -u | grep sim_time ---Expected output text as below--- ros2_caret:sim_time: Visualization using sim_time # By setting use_sim_time=True or xaxis_type='sim_time' , sim_time is used instead of system time for the following APIs. def callback_sched ( target : CallbackGroupTypes , lstrip_s : float = 0 , rstrip_s : float = 0 , coloring_rule : str = 'callback' , use_sim_time : bool = False , export_path : Optional [ str ] = None ) -> Figure : def message_flow ( path : Path , export_path : Optional [ str ] = None , granularity : Optional [ str ] = None , treat_drop_as_delay = False , lstrip_s : float = 0 , rstrip_s : float = 0 , use_sim_time : bool = False ) -> Figure : def show ( self , xaxis_type : str = 'system_time' , ywheel_zoom : bool = True , full_legends : bool = False , export_path : Optional [ str ] = None ) -> Figure : In case /clock topic is not recorded in trace data, the following error will occur. InvalidArgumentError : Failed to load sim_time . Please measure again with clock_recorder running . Sample to use sim_time # Explanation below assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws . Record rosbag # The following steps can be performed either with or without CARET. If you have built a target application without CARET, you don't need to set environment for CARET and LD_PRELOAD. Open a terminal to run a target application to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 run caret_demos end_to_end_sample Open another terminal to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag record /topic1 /drive Here, /topic1 and /drive are source topics of the sample application. You can check if rosbag is successfully recorded. ros2 bag info rosbag2_2022_09_30-10_57_06 Files: rosbag2_2022_09_30-10_57_06_0.db3 Bag size: 29 .3 KiB Storage id: sqlite3 Duration: 9 .601s Start: Sep 30 2022 10 :57:08.952 ( 1664503028 .952 ) End: Sep 30 2022 10 :57:18.554 ( 1664503038 .554 ) Messages: 194 Topic information: Topic: /drive | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr Topic: /topic1 | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr Record trace data # Open another terminal and run the following commands source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder Open another terminal to run a target application to record trace data with CARET In the launch file, use_sim_time is set to true and source nodes are disabled. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 launch caret_demos end_to_end_sample_with_lttng_session_use_sim.launch.py use_sim_time: = true use_rosbag: = true Open another terminal to play the rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag play rosbag2_2022_09_30-10_57_06 --clock -r 0 .2 Stop the application and the rosbag Check if /clock topic is recorded in trace data as sim_time babeltrace ~/ros2_ws/evaluate/e2e_sample | cut -d ' ' -f 4 | sort -u | grep sim_time ros2_caret:sim_time: Visualize results using sim_time # Launch Jupyter Notebook in ~/ros2_ws/evaluate and run the following scripts Reference: the tutorial from bokeh.plotting import output_notebook output_notebook () from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import Plot , message_flow # Read trace data arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) # Search and add path paths = arch . search_paths ( '/filter_node' , '/message_driven_node' ) arch . add_path ( 'target_path' , paths [ 0 ]) app = Application ( arch , lttng ) # Draw message_flow path = app . get_path ( 'target_path' ) message_flow ( path , use_sim_time = True ) # Draw node info node = app . get_node ( '/filter_node' ) plot = Plot . create_callback_period_plot ( node ) plot . show ( 'sim_time' )","title":"ROS time (sim_time) support"},{"location":"recording/sim_time/#ros-time-sim_time-support","text":"","title":"ROS time (sim_time) support"},{"location":"recording/sim_time/#introduction","text":"CARET uses system time to analyze trace data by default. It may be inconvenient, especially when treating trace data recorded with rosbag. These are examples: The flow of time in analysis results (e.g., time series graph) is different from that of ROS when playing rosbag with [-r RATE] option. For instance, 10 Hz becomes 2 Hz when rosbag was played with [-r 0.2] but analysis uses system time Time becomes different at every recording even if you use the same rosbag file, which makes comparing experimental results difficult This page explains how to use sim_time.","title":"Introduction"},{"location":"recording/sim_time/#recording-clock-topic","text":"/clock topic needs to be recorded in trace data. /clock topis is recorded as ros2_caret:sim_time event in trace data. Open a new terminal and run the following commands before recording and running a target application. Info Remember to set use_sim_time=true for each node when launching a target application Remember to add --clock option when playing rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder You can check whether /clock is successfully recorded by the following command. babeltrace <path-to-trace-data> | cut -d ' ' -f 4 | sort -u | grep sim_time ---Expected output text as below--- ros2_caret:sim_time:","title":"Recording /clock topic"},{"location":"recording/sim_time/#visualization-using-sim_time","text":"By setting use_sim_time=True or xaxis_type='sim_time' , sim_time is used instead of system time for the following APIs. def callback_sched ( target : CallbackGroupTypes , lstrip_s : float = 0 , rstrip_s : float = 0 , coloring_rule : str = 'callback' , use_sim_time : bool = False , export_path : Optional [ str ] = None ) -> Figure : def message_flow ( path : Path , export_path : Optional [ str ] = None , granularity : Optional [ str ] = None , treat_drop_as_delay = False , lstrip_s : float = 0 , rstrip_s : float = 0 , use_sim_time : bool = False ) -> Figure : def show ( self , xaxis_type : str = 'system_time' , ywheel_zoom : bool = True , full_legends : bool = False , export_path : Optional [ str ] = None ) -> Figure : In case /clock topic is not recorded in trace data, the following error will occur. InvalidArgumentError : Failed to load sim_time . Please measure again with clock_recorder running .","title":"Visualization using sim_time"},{"location":"recording/sim_time/#sample-to-use-sim_time","text":"Explanation below assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws .","title":"Sample to use sim_time"},{"location":"recording/sim_time/#record-rosbag","text":"The following steps can be performed either with or without CARET. If you have built a target application without CARET, you don't need to set environment for CARET and LD_PRELOAD. Open a terminal to run a target application to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 run caret_demos end_to_end_sample Open another terminal to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag record /topic1 /drive Here, /topic1 and /drive are source topics of the sample application. You can check if rosbag is successfully recorded. ros2 bag info rosbag2_2022_09_30-10_57_06 Files: rosbag2_2022_09_30-10_57_06_0.db3 Bag size: 29 .3 KiB Storage id: sqlite3 Duration: 9 .601s Start: Sep 30 2022 10 :57:08.952 ( 1664503028 .952 ) End: Sep 30 2022 10 :57:18.554 ( 1664503038 .554 ) Messages: 194 Topic information: Topic: /drive | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr Topic: /topic1 | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr","title":"Record rosbag"},{"location":"recording/sim_time/#record-trace-data","text":"Open another terminal and run the following commands source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder Open another terminal to run a target application to record trace data with CARET In the launch file, use_sim_time is set to true and source nodes are disabled. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 launch caret_demos end_to_end_sample_with_lttng_session_use_sim.launch.py use_sim_time: = true use_rosbag: = true Open another terminal to play the rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag play rosbag2_2022_09_30-10_57_06 --clock -r 0 .2 Stop the application and the rosbag Check if /clock topic is recorded in trace data as sim_time babeltrace ~/ros2_ws/evaluate/e2e_sample | cut -d ' ' -f 4 | sort -u | grep sim_time ros2_caret:sim_time:","title":"Record trace data"},{"location":"recording/sim_time/#visualize-results-using-sim_time","text":"Launch Jupyter Notebook in ~/ros2_ws/evaluate and run the following scripts Reference: the tutorial from bokeh.plotting import output_notebook output_notebook () from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import Plot , message_flow # Read trace data arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) # Search and add path paths = arch . search_paths ( '/filter_node' , '/message_driven_node' ) arch . add_path ( 'target_path' , paths [ 0 ]) app = Application ( arch , lttng ) # Draw message_flow path = app . get_path ( 'target_path' ) message_flow ( path , use_sim_time = True ) # Draw node info node = app . get_node ( '/filter_node' ) plot = Plot . create_callback_period_plot ( node ) plot . show ( 'sim_time' )","title":"Visualize results using sim_time"},{"location":"recording/trace_filtering/","text":"Trace filtering # Trace filtering # CARET provides a trace filtering function to exclude specific nodes and topics. Trace data may be discarded when recording a large application like Autoware due to too many data to be recorded, and a warning will occur when validating/analyzing the recorded trace data (See validating ). By applying trace filter, unconcerned events like /tf are ignored and the size of recorded data decreases. Trace filter configuration # Trace filter configuration is performed by setting the following environment variables CARET_SELECT_NODES : node names to be recorded CARET_IGNORE_NODES : node names to be ignored CARET_SELECT_TOPICS : topic names to be recorded CARET_IGNORE_TOPICS : topic names to be ignored \"SELECT\" settings override \"IGNORE\" settings if both are used Colon \" : \" is used to set more than one nodes/topics Regular expressions are supported These variables need to be set in the same terminal as a target application running In most cases, nodes related to /rviz , /clock topic and /parameter_events topic are unnecessary to analyze an application. It's recommended to ignore these nodes/topics The following shows sample settings export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" Info Trace filter doesn't exclude all events of the specified nodes/topics. Events in certain layers, especially DDS layer, won't be ignored.It is one of limitations with current implementation. Trace filter setting file # It will be handy to prepare a trace filter setting file like the following. # caret_topic_filter.bash #!/bin/bash export CARET_IGNORE_NODES = \\ \"\\ /rviz*\\ \" export CARET_IGNORE_TOPICS = \\ \"\\ /clock:\\ /parameter_events\\ \" # if you want to select nodes or topics, # please remove comment out of the followings. # export CARET_SELECT_NODES=\\ # \"\\ # /rviz*\\ # \" # export CARET_SELECT_TOPICS=\\ # \"\\ # /clock:\\ # /parameter_events\\ # \"","title":"Trace filtering"},{"location":"recording/trace_filtering/#trace-filtering","text":"","title":"Trace filtering"},{"location":"recording/trace_filtering/#trace-filtering_1","text":"CARET provides a trace filtering function to exclude specific nodes and topics. Trace data may be discarded when recording a large application like Autoware due to too many data to be recorded, and a warning will occur when validating/analyzing the recorded trace data (See validating ). By applying trace filter, unconcerned events like /tf are ignored and the size of recorded data decreases.","title":"Trace filtering"},{"location":"recording/trace_filtering/#trace-filter-configuration","text":"Trace filter configuration is performed by setting the following environment variables CARET_SELECT_NODES : node names to be recorded CARET_IGNORE_NODES : node names to be ignored CARET_SELECT_TOPICS : topic names to be recorded CARET_IGNORE_TOPICS : topic names to be ignored \"SELECT\" settings override \"IGNORE\" settings if both are used Colon \" : \" is used to set more than one nodes/topics Regular expressions are supported These variables need to be set in the same terminal as a target application running In most cases, nodes related to /rviz , /clock topic and /parameter_events topic are unnecessary to analyze an application. It's recommended to ignore these nodes/topics The following shows sample settings export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" Info Trace filter doesn't exclude all events of the specified nodes/topics. Events in certain layers, especially DDS layer, won't be ignored.It is one of limitations with current implementation.","title":"Trace filter configuration"},{"location":"recording/trace_filtering/#trace-filter-setting-file","text":"It will be handy to prepare a trace filter setting file like the following. # caret_topic_filter.bash #!/bin/bash export CARET_IGNORE_NODES = \\ \"\\ /rviz*\\ \" export CARET_IGNORE_TOPICS = \\ \"\\ /clock:\\ /parameter_events\\ \" # if you want to select nodes or topics, # please remove comment out of the followings. # export CARET_SELECT_NODES=\\ # \"\\ # /rviz*\\ # \" # export CARET_SELECT_TOPICS=\\ # \"\\ # /clock:\\ # /parameter_events\\ # \"","title":"Trace filter setting file"},{"location":"recording/validating/","text":"Validating trace data # Validating trace data # You can check whether a recording is successful with ros2 caret check_ctf command. ros2 caret check_ctf -d <path-to-trace-data> Info Executing the ros2 caret check_ctf command for long recorded data or recorded data of a large application takes a long time. Therefore, it is recommended to execute the ros2 caret check_ctf command on a short duration of recorded data before long-time recording. Also, It's recommended to record and validate trace data when you build a target application, so that you can modify code to avoid the following warnings. Info You can ignore warnings caused by Python and libraries Warnings due to wrong procedure # Failed to find trace point added by caret-rclcpp # Cause CARET/rclcpp is not applied when you built a target application Solution Build the application with CARET (See build section ) Failed to find trace point added by LD_PRELOAD # Cause Hooked tracepoints were not found. LD_PRELOAD may be missed Solution Set LD_PRELOAD before running the application (See recording section ) Tracer discarded # Cause Trace data lost occurred while recording due to too many trace data This warning will be observed in some case, especially when applying CARET to a large application Details LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents . After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded. Solution Apply trace filter, or modify trace filter setting to ignore more topics/nodes (See trace filtering section ) especially, filtering highly-frequent nodes and topics is effective highly-frequent nodes/topics can be identified by checking the summary of trace data Increase size of ring-buffer in CARET if a target device has enough memory example Warnings due to CARET limitations # CARET identifies callback functions using the following parameters. In case a node has several callback functions whose parameters are identical, such node is ignored because CARET cannot analyze it. Timer callback functions: timer period Subscription callback functions: topic name Duplicate parameter callback found # Cause Several timer callback functions which have the same timer period exist in a node In other words, rclcpp::create_timer() with the same timer period is called more than once Solution (workaround) Modify code to avoid using the same timer period (You can slightly change timer period value) Or, this warning can be ignored unless the node needs to be analyzed Failed to identify subscription. Several candidates were found # Cause Several subscription callback functions which have the same topic name exist in a node In other words, rclcpp::create_subscription() with the same topic name is called more than once Solution (workaround) Modify code to avoid creating more than one subscription callback function with the same topic name Multiple executors using the same callback group were detected # Cause A callback group is added to several executors Solution There is no solution at the moment. CARET uses the last executor to analyze. This warning can be ignored in most cases Failed to find callback group # Cause CARET failed to bind callback groups, callbacks and executors. It mainly because of ROS 2 \"service\". \"Service\" is not supported by CARET Solution There is no solution at the moment. This warning can be ignored in most cases","title":"Validating"},{"location":"recording/validating/#validating-trace-data","text":"","title":"Validating trace data"},{"location":"recording/validating/#validating-trace-data_1","text":"You can check whether a recording is successful with ros2 caret check_ctf command. ros2 caret check_ctf -d <path-to-trace-data> Info Executing the ros2 caret check_ctf command for long recorded data or recorded data of a large application takes a long time. Therefore, it is recommended to execute the ros2 caret check_ctf command on a short duration of recorded data before long-time recording. Also, It's recommended to record and validate trace data when you build a target application, so that you can modify code to avoid the following warnings. Info You can ignore warnings caused by Python and libraries","title":"Validating trace data"},{"location":"recording/validating/#warnings-due-to-wrong-procedure","text":"","title":"Warnings due to wrong procedure"},{"location":"recording/validating/#failed-to-find-trace-point-added-by-caret-rclcpp","text":"Cause CARET/rclcpp is not applied when you built a target application Solution Build the application with CARET (See build section )","title":"Failed to find trace point added by caret-rclcpp"},{"location":"recording/validating/#failed-to-find-trace-point-added-by-ld_preload","text":"Cause Hooked tracepoints were not found. LD_PRELOAD may be missed Solution Set LD_PRELOAD before running the application (See recording section )","title":"Failed to find trace point added by LD_PRELOAD"},{"location":"recording/validating/#tracer-discarded","text":"Cause Trace data lost occurred while recording due to too many trace data This warning will be observed in some case, especially when applying CARET to a large application Details LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents . After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded. Solution Apply trace filter, or modify trace filter setting to ignore more topics/nodes (See trace filtering section ) especially, filtering highly-frequent nodes and topics is effective highly-frequent nodes/topics can be identified by checking the summary of trace data Increase size of ring-buffer in CARET if a target device has enough memory example","title":"Tracer discarded"},{"location":"recording/validating/#warnings-due-to-caret-limitations","text":"CARET identifies callback functions using the following parameters. In case a node has several callback functions whose parameters are identical, such node is ignored because CARET cannot analyze it. Timer callback functions: timer period Subscription callback functions: topic name","title":"Warnings due to CARET limitations"},{"location":"recording/validating/#duplicate-parameter-callback-found","text":"Cause Several timer callback functions which have the same timer period exist in a node In other words, rclcpp::create_timer() with the same timer period is called more than once Solution (workaround) Modify code to avoid using the same timer period (You can slightly change timer period value) Or, this warning can be ignored unless the node needs to be analyzed","title":"Duplicate parameter callback found"},{"location":"recording/validating/#failed-to-identify-subscription-several-candidates-were-found","text":"Cause Several subscription callback functions which have the same topic name exist in a node In other words, rclcpp::create_subscription() with the same topic name is called more than once Solution (workaround) Modify code to avoid creating more than one subscription callback function with the same topic name","title":"Failed to identify subscription. Several candidates were found"},{"location":"recording/validating/#multiple-executors-using-the-same-callback-group-were-detected","text":"Cause A callback group is added to several executors Solution There is no solution at the moment. CARET uses the last executor to analyze. This warning can be ignored in most cases","title":"Multiple executors using the same callback group were detected"},{"location":"recording/validating/#failed-to-find-callback-group","text":"Cause CARET failed to bind callback groups, callbacks and executors. It mainly because of ROS 2 \"service\". \"Service\" is not supported by CARET Solution There is no solution at the moment. This warning can be ignored in most cases","title":"Failed to find callback group"},{"location":"tutorials/configuration/","text":"Configuration for measuring node and path latency # CARET can observe as following: callback latency communication latency (inter-node) node latency (intra-node) path latency (intra-node & inter-node) The following figure shows definition of node latency and path latency. Callback latency can be defined as execution time of a callback function and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in a application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configuration file, called \" architecture file \". Overview of an architecture file # An architecture file has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can create a template architecture file including only application structure section. The application structure section remains same unless the structure is changed or component is renamed. On the other hand, latency definition section in the template architecture file is empty just before users add any definition. Users are expected to add definitions of node latency and path latency in the template file. CARET helps users to add definition of path latency with Python API. However, users have to add definition of node latency manually with editing the architecture file. The following sections explains how to create an architecture file and add latency definition. How to generate an architecture file # This section explains how to generate an architecture file which has minimum description. Launch Jupyter Notebook (Jupyter Lab) mkdir -p ~/ros2_ws/evaluate && cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab Generate an architecture file from recorded data as below from caret_analyze import Architecture # Read description of application's architecture from recorded data arch = Architecture ( 'lttng' , './e2e_sample' ) # Save description as an architecture file arch . export ( 'architecture.yaml' ) # Check if the architecture file is created ! readlink - f ./ architecture . yaml # /home/user/ros2_caret_ws/eval/architecture.yaml How to define a target path # Load the yaml-based architecture file as below from caret_analyze import Architecture , check_procedure arch = Architecture ( 'yaml' , './architecture.yaml' ) Choose source node and destination node in a path arch.search_paths extract all candidates of the path paths = arch . search_paths ( '/sensor_dummy_node' , # source node '/actuator_dummy_node' ) # destination node If a target application is large and complicated, arch.search_paths method may consume time more than 1 minute. For decreasing consumed time, you can ignore nodes and topics and specify depth of search. Refer to \u30d1\u30b9\u306e\u63a2\u7d22\u65b9\u6cd5 for more details. Check the path as you expected You will find multiple candidates of the path. You can check which candidate is expected as target. The following code is an example for users to check path = paths [ 0 ] path . summary . pprint () --- Output text as below --- path : - message_context : null # for definition of node latency node : / sensor_dummy_node - topic : / topic1 - message_context : publisher_topic_name : / topic2 subscription_topic_name : / topic1 type : callback_chain node : / filter_node - topic : / topic2 - message_context : null node : / message_driven_node - topic : / topic3 - message_context : null node : / timer_driven_node - topic : / topic4 - message_context : null node : / actuator_dummy_node Give a name to selected path and update architecture file arch . add_path ( 'target_path' , path ) arch . export ( './architecture.yaml' , force = True ) The updated architecture file describes the path named as target_path . named_paths : - path_name : target_path node_chain : - node_name : /sensor_dummy_node publish_topic_name : /topic1 subscribe_topic_name : UNDEFINED - node_name : /filter_node publish_topic_name : /topic2 subscribe_topic_name : /topic1 - node_name : /message_driven_node publish_topic_name : /topic3 subscribe_topic_name : /topic2 - node_name : /timer_driven_node publish_topic_name : /topic4 subscribe_topic_name : /topic3 - node_name : /actuator_dummy_node publish_topic_name : UNDEFINED subscribe_topic_name : /topic4 How to define latency of a single node # Latency of a single node, so called \"node latency\", is defined as elapsed time from 1. starting time to 2. publishing time as below. starting time when node subscribes topic message and invokes a corresponding callback function publishing time when node publishes topic message Definition of node latency depends on implementation pattern. Some nodes subscribe input messages and invoke callback function where they publish output messages. These nodes has direct relationship between input and output. Other nodes subscribe input messages and invoke callback functions where they buffer them, and invoke different callback functions consume input messages and publish output message. In the latter cases, relationship of input and output is indirect, and intra-node communication is performed with using multiple callback functions. message_filters is another cause to increase the number of implementation patterns. Therefore, CARET has to deal with several types of node implementation to measure node latency. CARET serve a function to define node latency with an architecture file. An architecture file has an item of message_context , which indicates relation between input message and output message. This item should be defined by users as below. Check which node latency should be configured path.verify() method, as shown in the following example, tells you which node latency should be defined. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () --- Output text as below --- WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 In the example, path.verify() tells you two nodes have undefined relationships of input and output. input /topic2 and output /topic3 in node /message_driven_node input /topic3 and output /topic4 in node /timer_driven_node Their relationships must be explicit with corresponding message_context items in the architecture file. Define relationship between input and output You have to change message_contexts items as below for the sample. # in /message_driven_node message_contexts : - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic2 publisher_topic_name : /topic3 # in /timer_driven_node message_contexts :\u3000 - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic3 publisher_topic_name : /topic4 Check if node latency is defined path.verify() tells you that there is no undefined node latency in the path. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () If path.verify() returns True , CARET can calculate latency of the path. Otherwise, there is any lack of definition to calculate latency. Todo We'll provide the sample architecture file here, but it's not ready. Sorry for inconvenience.","title":"Configuration"},{"location":"tutorials/configuration/#configuration-for-measuring-node-and-path-latency","text":"CARET can observe as following: callback latency communication latency (inter-node) node latency (intra-node) path latency (intra-node & inter-node) The following figure shows definition of node latency and path latency. Callback latency can be defined as execution time of a callback function and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in a application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configuration file, called \" architecture file \".","title":"Configuration for measuring node and path latency"},{"location":"tutorials/configuration/#overview-of-an-architecture-file","text":"An architecture file has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can create a template architecture file including only application structure section. The application structure section remains same unless the structure is changed or component is renamed. On the other hand, latency definition section in the template architecture file is empty just before users add any definition. Users are expected to add definitions of node latency and path latency in the template file. CARET helps users to add definition of path latency with Python API. However, users have to add definition of node latency manually with editing the architecture file. The following sections explains how to create an architecture file and add latency definition.","title":"Overview of an architecture file"},{"location":"tutorials/configuration/#how-to-generate-an-architecture-file","text":"This section explains how to generate an architecture file which has minimum description. Launch Jupyter Notebook (Jupyter Lab) mkdir -p ~/ros2_ws/evaluate && cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab Generate an architecture file from recorded data as below from caret_analyze import Architecture # Read description of application's architecture from recorded data arch = Architecture ( 'lttng' , './e2e_sample' ) # Save description as an architecture file arch . export ( 'architecture.yaml' ) # Check if the architecture file is created ! readlink - f ./ architecture . yaml # /home/user/ros2_caret_ws/eval/architecture.yaml","title":"How to generate an architecture file"},{"location":"tutorials/configuration/#how-to-define-a-target-path","text":"Load the yaml-based architecture file as below from caret_analyze import Architecture , check_procedure arch = Architecture ( 'yaml' , './architecture.yaml' ) Choose source node and destination node in a path arch.search_paths extract all candidates of the path paths = arch . search_paths ( '/sensor_dummy_node' , # source node '/actuator_dummy_node' ) # destination node If a target application is large and complicated, arch.search_paths method may consume time more than 1 minute. For decreasing consumed time, you can ignore nodes and topics and specify depth of search. Refer to \u30d1\u30b9\u306e\u63a2\u7d22\u65b9\u6cd5 for more details. Check the path as you expected You will find multiple candidates of the path. You can check which candidate is expected as target. The following code is an example for users to check path = paths [ 0 ] path . summary . pprint () --- Output text as below --- path : - message_context : null # for definition of node latency node : / sensor_dummy_node - topic : / topic1 - message_context : publisher_topic_name : / topic2 subscription_topic_name : / topic1 type : callback_chain node : / filter_node - topic : / topic2 - message_context : null node : / message_driven_node - topic : / topic3 - message_context : null node : / timer_driven_node - topic : / topic4 - message_context : null node : / actuator_dummy_node Give a name to selected path and update architecture file arch . add_path ( 'target_path' , path ) arch . export ( './architecture.yaml' , force = True ) The updated architecture file describes the path named as target_path . named_paths : - path_name : target_path node_chain : - node_name : /sensor_dummy_node publish_topic_name : /topic1 subscribe_topic_name : UNDEFINED - node_name : /filter_node publish_topic_name : /topic2 subscribe_topic_name : /topic1 - node_name : /message_driven_node publish_topic_name : /topic3 subscribe_topic_name : /topic2 - node_name : /timer_driven_node publish_topic_name : /topic4 subscribe_topic_name : /topic3 - node_name : /actuator_dummy_node publish_topic_name : UNDEFINED subscribe_topic_name : /topic4","title":"How to define a target path"},{"location":"tutorials/configuration/#how-to-define-latency-of-a-single-node","text":"Latency of a single node, so called \"node latency\", is defined as elapsed time from 1. starting time to 2. publishing time as below. starting time when node subscribes topic message and invokes a corresponding callback function publishing time when node publishes topic message Definition of node latency depends on implementation pattern. Some nodes subscribe input messages and invoke callback function where they publish output messages. These nodes has direct relationship between input and output. Other nodes subscribe input messages and invoke callback functions where they buffer them, and invoke different callback functions consume input messages and publish output message. In the latter cases, relationship of input and output is indirect, and intra-node communication is performed with using multiple callback functions. message_filters is another cause to increase the number of implementation patterns. Therefore, CARET has to deal with several types of node implementation to measure node latency. CARET serve a function to define node latency with an architecture file. An architecture file has an item of message_context , which indicates relation between input message and output message. This item should be defined by users as below. Check which node latency should be configured path.verify() method, as shown in the following example, tells you which node latency should be defined. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () --- Output text as below --- WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 In the example, path.verify() tells you two nodes have undefined relationships of input and output. input /topic2 and output /topic3 in node /message_driven_node input /topic3 and output /topic4 in node /timer_driven_node Their relationships must be explicit with corresponding message_context items in the architecture file. Define relationship between input and output You have to change message_contexts items as below for the sample. # in /message_driven_node message_contexts : - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic2 publisher_topic_name : /topic3 # in /timer_driven_node message_contexts :\u3000 - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic3 publisher_topic_name : /topic4 Check if node latency is defined path.verify() tells you that there is no undefined node latency in the path. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () If path.verify() returns True , CARET can calculate latency of the path. Otherwise, there is any lack of definition to calculate latency. Todo We'll provide the sample architecture file here, but it's not ready. Sorry for inconvenience.","title":"How to define latency of a single node"},{"location":"tutorials/recording/","text":"Recording with CARET # This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository. See Recording to find more details. Building application with CARET # To trace a target application, the target should be built with CARET/rclcpp. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash' colcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING = OFF The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables. ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ # Expected output. CARET/rclcpp is applied to all packages INFO : 2022 -06-12 12 :26:49 | All packages are built using caret-rclcpp. # In case there are packages to which CARET/rclcpp is not applied # The following message will be outputted WARNING : 2022 -06-12 12 :25:26 | The following packages have not been built using caret-rclcpp: demo_nodes_cpp caret_demos intra_process_demo Tracing the sample application with CARET # Starting LTTng session # CARET depends on LTTng for tracing applications. LTTng session has to be started before a target application runs. Note that if you execute the target application before starting LTTng session, it will result in a lack of trace points. You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing. source /opt/ros/humble/setup.bash # set a destination directory. ~/.ros/tracing is default. mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key Launching the target application # Open a new terminal and run the target as shown in the following # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash # Enable tracepoints which are defined hooked functions. export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) # (Optional) Exclude nodes and topics which you are not concerned with export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Launch the target application, demos_end_to_end_sample ros2 launch caret_demos end_to_end_sample.launch.py ^C # Finish with Ctrl+C after several seconds [ WARNING ] [ launch ] : user interrupted with ctrl-c ( SIGINT ) [ end_to_end_sample-1 ] [ INFO ] [ 1631481246 .160958444 ] [ rclcpp ] : signal_handler ( signal_value = 2 ) [ INFO ] [ end_to_end_sample-1 ] : process has finished cleanly [ pid 722356 ] You can finish the target application and LTTng session. LTTng session will be closed if you push Enter key on the terminal where the LTTng session runs. Validating recorded data briefly # You can check whether tracing is successful or not with ros2 caret check_ctf command before visualizing recorded data. ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/ # If there are problems with the recorded data, warning messages will be displayed.","title":"Recording"},{"location":"tutorials/recording/#recording-with-caret","text":"This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository. See Recording to find more details.","title":"Recording with CARET"},{"location":"tutorials/recording/#building-application-with-caret","text":"To trace a target application, the target should be built with CARET/rclcpp. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash' colcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING = OFF The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables. ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ # Expected output. CARET/rclcpp is applied to all packages INFO : 2022 -06-12 12 :26:49 | All packages are built using caret-rclcpp. # In case there are packages to which CARET/rclcpp is not applied # The following message will be outputted WARNING : 2022 -06-12 12 :25:26 | The following packages have not been built using caret-rclcpp: demo_nodes_cpp caret_demos intra_process_demo","title":"Building application with CARET"},{"location":"tutorials/recording/#tracing-the-sample-application-with-caret","text":"","title":"Tracing the sample application with CARET"},{"location":"tutorials/recording/#starting-lttng-session","text":"CARET depends on LTTng for tracing applications. LTTng session has to be started before a target application runs. Note that if you execute the target application before starting LTTng session, it will result in a lack of trace points. You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing. source /opt/ros/humble/setup.bash # set a destination directory. ~/.ros/tracing is default. mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key","title":"Starting LTTng session"},{"location":"tutorials/recording/#launching-the-target-application","text":"Open a new terminal and run the target as shown in the following # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash # Enable tracepoints which are defined hooked functions. export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) # (Optional) Exclude nodes and topics which you are not concerned with export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Launch the target application, demos_end_to_end_sample ros2 launch caret_demos end_to_end_sample.launch.py ^C # Finish with Ctrl+C after several seconds [ WARNING ] [ launch ] : user interrupted with ctrl-c ( SIGINT ) [ end_to_end_sample-1 ] [ INFO ] [ 1631481246 .160958444 ] [ rclcpp ] : signal_handler ( signal_value = 2 ) [ INFO ] [ end_to_end_sample-1 ] : process has finished cleanly [ pid 722356 ] You can finish the target application and LTTng session. LTTng session will be closed if you push Enter key on the terminal where the LTTng session runs.","title":"Launching the target application"},{"location":"tutorials/recording/#validating-recorded-data-briefly","text":"You can check whether tracing is successful or not with ros2 caret check_ctf command before visualizing recorded data. ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/ # If there are problems with the recorded data, warning messages will be displayed.","title":"Validating recorded data briefly"},{"location":"tutorials/visualization/","text":"Performance visualization # CARET serves Python APIs to visualize trace data for users to analyze applications' performance. This section will show basic flow to visualize data with Jupyter notebook. How to locate trace data on Jupyter notebook # Launching jupyter-lab Launch jupyter-lab at first for learning how to visualize recorded data. cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab CARET uses bokeh for some visualization APIs. Execute the following code for loading bokeh from bokeh.plotting import output_notebook output_notebook () Loading trace data onto Jupyter notebook Locate trace data on Jupyter notebook as well as the architecture file. from caret_analyze import Architecture , Application , Lttng # load the architecture file which is created in the previous page arch = Architecture ( 'yaml' , './architecture.yaml' ) # load recorded data by CARET lttng = Lttng ( './e2e_sample' ) # map the application architecture to recorded data app = Application ( arch , lttng ) After execution of the code, users will often refer to the app object defined as Application class. The app objects provides users latency of callbacks, communication, and paths. Application class is similar to Architecture class which describes structure of the application and their interfaces are similar. In addition, Application class has interfaces to get latency. Basic API to get latency # This section will explain APIs to get callback latency. The following code is one of examples to get callback latency. # Get a callback instance, which has latency information, from app callback = app . get_callback ( '/timer_driven_node/callback_0' ) # Get time-series variation of latency t , latency_ns = callback . to_timeseries () # Get histogram of latency bins , latency_ns = callback . to_histogram () Though this example shows callback latency, CARET serves API to get communication latency. callback.to_dataframe() will provides pandas.DataFrame based object including raw timestamps which is obtained from tracepoints. Todo Sorry for not providing CARET's API list, but we'll provide it in the near future. Visualizing latency of node chain with message flow # CARET provides some APIs to visualize measured data. With message flow, which is one of effective visualizations, users can understand what happens and where is bottleneck in target applications. Execute the following code for visualization with message flow. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path ) The following figure will appear if message_flow method is successful. The horizontal axis shows time line. On the other hand, the vertical axis shows elements of the node chain ( target_path ), which include callback functions and topic messages from input to output. Each colorful line shows how a certain input message is propagated to callback functions and topic communications. Gray rectangles show execution timing of callback functions. If your mouse pointer is put over one of gray rectangles, latency of callback functions will be shown. You can find latency of a target node chain as well if you put the mouse pointer onto one of colorful lines. CARET serves other APIs for visualization. Refer to \u30ae\u30e3\u30e9\u30ea\u30fc for more details.","title":"Visualization"},{"location":"tutorials/visualization/#performance-visualization","text":"CARET serves Python APIs to visualize trace data for users to analyze applications' performance. This section will show basic flow to visualize data with Jupyter notebook.","title":"Performance visualization"},{"location":"tutorials/visualization/#how-to-locate-trace-data-on-jupyter-notebook","text":"Launching jupyter-lab Launch jupyter-lab at first for learning how to visualize recorded data. cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab CARET uses bokeh for some visualization APIs. Execute the following code for loading bokeh from bokeh.plotting import output_notebook output_notebook () Loading trace data onto Jupyter notebook Locate trace data on Jupyter notebook as well as the architecture file. from caret_analyze import Architecture , Application , Lttng # load the architecture file which is created in the previous page arch = Architecture ( 'yaml' , './architecture.yaml' ) # load recorded data by CARET lttng = Lttng ( './e2e_sample' ) # map the application architecture to recorded data app = Application ( arch , lttng ) After execution of the code, users will often refer to the app object defined as Application class. The app objects provides users latency of callbacks, communication, and paths. Application class is similar to Architecture class which describes structure of the application and their interfaces are similar. In addition, Application class has interfaces to get latency.","title":"How to locate trace data on Jupyter notebook"},{"location":"tutorials/visualization/#basic-api-to-get-latency","text":"This section will explain APIs to get callback latency. The following code is one of examples to get callback latency. # Get a callback instance, which has latency information, from app callback = app . get_callback ( '/timer_driven_node/callback_0' ) # Get time-series variation of latency t , latency_ns = callback . to_timeseries () # Get histogram of latency bins , latency_ns = callback . to_histogram () Though this example shows callback latency, CARET serves API to get communication latency. callback.to_dataframe() will provides pandas.DataFrame based object including raw timestamps which is obtained from tracepoints. Todo Sorry for not providing CARET's API list, but we'll provide it in the near future.","title":"Basic API to get latency"},{"location":"tutorials/visualization/#visualizing-latency-of-node-chain-with-message-flow","text":"CARET provides some APIs to visualize measured data. With message flow, which is one of effective visualizations, users can understand what happens and where is bottleneck in target applications. Execute the following code for visualization with message flow. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path ) The following figure will appear if message_flow method is successful. The horizontal axis shows time line. On the other hand, the vertical axis shows elements of the node chain ( target_path ), which include callback functions and topic messages from input to output. Each colorful line shows how a certain input message is propagated to callback functions and topic communications. Gray rectangles show execution timing of callback functions. If your mouse pointer is put over one of gray rectangles, latency of callback functions will be shown. You can find latency of a target node chain as well if you put the mouse pointer onto one of colorful lines. CARET serves other APIs for visualization. Refer to \u30ae\u30e3\u30e9\u30ea\u30fc for more details.","title":"Visualizing latency of node chain with message flow"},{"location":"visualization/","text":"Visualization # Basic APIs Concept # Basic APIs Concept Gallery CARET APIs # Visualization APIs # Callback # callback_sched create_callback_frequency_plot create_callback_period_plot create_callback_latency_plot Communication # create_communication_latency_plot create_communication_frequency_plot create_communication_period_plot Node # create_publish_subscription_period_plot create_publish_subscription_frequency_plot Note: Possible to get publisher as the same. Path # message_flow create_response_time_histogram_plot Helper APIs # CARET provides some APIs which can help user to focus on his/her respective interest. LTTngEventFilter get_callbacks Note: CARET analyze API document .","title":"Visualization"},{"location":"visualization/#visualization","text":"","title":"Visualization"},{"location":"visualization/#basic-apis-concept","text":"Basic APIs Concept Gallery","title":"Basic APIs Concept"},{"location":"visualization/#caret-apis","text":"","title":"CARET APIs"},{"location":"visualization/#visualization-apis","text":"","title":"Visualization APIs"},{"location":"visualization/#callback","text":"callback_sched create_callback_frequency_plot create_callback_period_plot create_callback_latency_plot","title":"Callback"},{"location":"visualization/#communication","text":"create_communication_latency_plot create_communication_frequency_plot create_communication_period_plot","title":"Communication"},{"location":"visualization/#node","text":"create_publish_subscription_period_plot create_publish_subscription_frequency_plot Note: Possible to get publisher as the same.","title":"Node"},{"location":"visualization/#path","text":"message_flow create_response_time_histogram_plot","title":"Path"},{"location":"visualization/#helper-apis","text":"CARET provides some APIs which can help user to focus on his/her respective interest. LTTngEventFilter get_callbacks Note: CARET analyze API document .","title":"Helper APIs"},{"location":"visualization/concept/basic_api_concept/","text":"Basic APIs Concept # The main basic design of the Plot class # The visualization tools provided by CARET are implemented in the Plot class. The usage of each API of the Plot class is unified as follows: from caret_analyze.plot import Plot ... # Processing input data plot = Plot . create_ [ metrics ] _ [ graph_type ] _plot ( data ) plot . show () plot . to_dataframe () The variable plot has two functions, show() and to_dataframe() . The function show() outputs a figure and returns the figure's handler. The function to_dataframe() returns a table summarizing the data. This function is mainly used to analyze based on specific figures. Note: For detailed input/output options, see TimeSeriesPlot .","title":"Basic APIs Concept"},{"location":"visualization/concept/basic_api_concept/#basic-apis-concept","text":"","title":"Basic APIs Concept"},{"location":"visualization/concept/basic_api_concept/#the-main-basic-design-of-the-plot-class","text":"The visualization tools provided by CARET are implemented in the Plot class. The usage of each API of the Plot class is unified as follows: from caret_analyze.plot import Plot ... # Processing input data plot = Plot . create_ [ metrics ] _ [ graph_type ] _plot ( data ) plot . show () plot . to_dataframe () The variable plot has two functions, show() and to_dataframe() . The function show() outputs a figure and returns the figure's handler. The function to_dataframe() returns a table summarizing the data. This function is mainly used to analyze based on specific figures. Note: For detailed input/output options, see TimeSeriesPlot .","title":"The main basic design of the Plot class"},{"location":"visualization/helper_api/lttng_event_filter/","text":"Usage of LTTngEventFilter # CARET can handle measurements and analysis up to several minutes. Memory usage, analysis time, and visualization time, etc., will be issues when leveraging measurement results of longer duration. Therefore, CARET has an API (LTTngEventFilter) to omit unnecessary measurement results when reading LTTng. This section describes how to use the LTTngEventFilter. LTTngEventFilter has the following filters init_pass_filter duration_filter strip_filter API Description # LttngEventFilter . init_pass_filter () Filter the trace points at initialization LttngEventFilter . duration_filter ( duration_s : float , offset_s : float ) [duration_s] : Measure duration [offset_s] : Ignore seconds from start LttngEventFilter . strip_filter ( lsplit_s : Optional [ float ], rsplit_s : Optional [ float ]) Ignore measurement results for [lsplit_s] from the start of the measurement Ignore measurement results for [rsplit_s] seconds before measurement ends Use cases # from caret_analyze import Lttng , LttngEventFilter lttng = Lttng ( '/path/to/ctf' , event_filters = [ LttngEventFilter . duration_filter ( 10 , 5 ) ]) # Filtering from 5 seconds to 10 seconds after the start of the measurement Multiple event_filters can be specified. If there are multiple event_filters have been given, all filters will be applied to the selected interval only.","title":"Usage of LTTngEventFilter"},{"location":"visualization/helper_api/lttng_event_filter/#usage-of-lttngeventfilter","text":"CARET can handle measurements and analysis up to several minutes. Memory usage, analysis time, and visualization time, etc., will be issues when leveraging measurement results of longer duration. Therefore, CARET has an API (LTTngEventFilter) to omit unnecessary measurement results when reading LTTng. This section describes how to use the LTTngEventFilter. LTTngEventFilter has the following filters init_pass_filter duration_filter strip_filter","title":"Usage of LTTngEventFilter"},{"location":"visualization/helper_api/lttng_event_filter/#api-description","text":"LttngEventFilter . init_pass_filter () Filter the trace points at initialization LttngEventFilter . duration_filter ( duration_s : float , offset_s : float ) [duration_s] : Measure duration [offset_s] : Ignore seconds from start LttngEventFilter . strip_filter ( lsplit_s : Optional [ float ], rsplit_s : Optional [ float ]) Ignore measurement results for [lsplit_s] from the start of the measurement Ignore measurement results for [rsplit_s] seconds before measurement ends","title":"API Description"},{"location":"visualization/helper_api/lttng_event_filter/#use-cases","text":"from caret_analyze import Lttng , LttngEventFilter lttng = Lttng ( '/path/to/ctf' , event_filters = [ LttngEventFilter . duration_filter ( 10 , 5 ) ]) # Filtering from 5 seconds to 10 seconds after the start of the measurement Multiple event_filters can be specified. If there are multiple event_filters have been given, all filters will be applied to the selected interval only.","title":"Use cases"},{"location":"visualization/helper_api/path_verify/","text":"Error detection using path.verify() # CARET requires some setup and configuration that users should do. path.verify() method can check the settings are completed. If any error or warning occurs, message from path.verify() give you some instruction to tackle it. Usage # from caret_analyze import Architecture , Application , Lttng # read architecture file. arch = Architecture ( 'yaml' , '/path/to/architecture_file.yaml' ) # read trace result. lttng = Lttng ( '/path/to/trace_data' ) # map architecture information to trace result. app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) path . verify () What path.verify() checks # Check whether using caret/rclcpp [path.verify()] Your applications need to be built with rclcpp provided by CARET, not ROS 2. path.verify() command checks which rclcpp is used for building your application. If caret/rclcpp is not applied, the following warning message is outputted on your terminal or Jupyter notebook. WARNING : 2022 -03-18 12 :53:54 | 'caret/rclcpp' may not be used in subscriber of '/localization/pose_estimator/ndt_scan_matcher' . Check if node latency can be calculated with referring to message_context","title":"Error detection using `path.verify()`"},{"location":"visualization/helper_api/path_verify/#error-detection-using-pathverify","text":"CARET requires some setup and configuration that users should do. path.verify() method can check the settings are completed. If any error or warning occurs, message from path.verify() give you some instruction to tackle it.","title":"Error detection using path.verify()"},{"location":"visualization/helper_api/path_verify/#usage","text":"from caret_analyze import Architecture , Application , Lttng # read architecture file. arch = Architecture ( 'yaml' , '/path/to/architecture_file.yaml' ) # read trace result. lttng = Lttng ( '/path/to/trace_data' ) # map architecture information to trace result. app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) path . verify ()","title":"Usage"},{"location":"visualization/helper_api/path_verify/#what-pathverify-checks","text":"Check whether using caret/rclcpp [path.verify()] Your applications need to be built with rclcpp provided by CARET, not ROS 2. path.verify() command checks which rclcpp is used for building your application. If caret/rclcpp is not applied, the following warning message is outputted on your terminal or Jupyter notebook. WARNING : 2022 -03-18 12 :53:54 | 'caret/rclcpp' may not be used in subscriber of '/localization/pose_estimator/ndt_scan_matcher' . Check if node latency can be calculated with referring to message_context","title":"What path.verify() checks"},{"location":"visualization/helper_api/scope_switch_method/","text":"Scope Switching Methods # CARET provides a ROS-friendly class structure that allows you to switch scope as your interest. Executor Node CallbackGroup Callback Publisher Subscription Timer Please refer to the API documentation for more details about the classes. This section describes how to obtain the targeted class. Description of get_callback # The 'get_callback()' is a function that returns callback information such as callback name, callback period[ns], callback type. API # # def get_callback(self, callback_name: str) -> CallbackBase The 'get_callback()' function returns single callback that match the argument string and callback name (callback name defined in architecture file). If no matching callbacks are found, get_callback raises a exception. Usage # from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callback ( '/timer_driven_node/callback_0' ) callback2 = app . get_callback ( '/timer_driven_node/callback_1' ) Description of get_callbacks # The get_callbacks() is a function that gets callback information. Callbacks information includes callback name, callback period[ns], callback type. API # # def get_callbacks(self, *callback_names: str) -> List[CallbackBase] The 'get_callbacks()' function gets callbacks that match the argument string and callback name (callback name defined in architecture file). If concrete callback names are given and there is no match callbacks, The 'get_callbacks()' function warns and may notify similar callbacks name. The 'get_callbacks()' function can recognize UNIX filename pattern such as '*' or '?'. If patterns are given, get_callbacks doesn't raise any exception, and returns empty list. Usage # from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callbacks ( '/timer_driven_node/callback_0' ) callback2 = app . get_callbacks ( '/timer_driven_node/callback_?' ) callback3 = app . get_callbacks ( '/timer_driven_node/*' )","title":"Scope Switching Methods"},{"location":"visualization/helper_api/scope_switch_method/#scope-switching-methods","text":"CARET provides a ROS-friendly class structure that allows you to switch scope as your interest. Executor Node CallbackGroup Callback Publisher Subscription Timer Please refer to the API documentation for more details about the classes. This section describes how to obtain the targeted class.","title":"Scope Switching Methods"},{"location":"visualization/helper_api/scope_switch_method/#description-of-get_callback","text":"The 'get_callback()' is a function that returns callback information such as callback name, callback period[ns], callback type.","title":"Description of get_callback"},{"location":"visualization/helper_api/scope_switch_method/#api","text":"# def get_callback(self, callback_name: str) -> CallbackBase The 'get_callback()' function returns single callback that match the argument string and callback name (callback name defined in architecture file). If no matching callbacks are found, get_callback raises a exception.","title":"API"},{"location":"visualization/helper_api/scope_switch_method/#usage","text":"from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callback ( '/timer_driven_node/callback_0' ) callback2 = app . get_callback ( '/timer_driven_node/callback_1' )","title":"Usage"},{"location":"visualization/helper_api/scope_switch_method/#description-of-get_callbacks","text":"The get_callbacks() is a function that gets callback information. Callbacks information includes callback name, callback period[ns], callback type.","title":"Description of get_callbacks"},{"location":"visualization/helper_api/scope_switch_method/#api_1","text":"# def get_callbacks(self, *callback_names: str) -> List[CallbackBase] The 'get_callbacks()' function gets callbacks that match the argument string and callback name (callback name defined in architecture file). If concrete callback names are given and there is no match callbacks, The 'get_callbacks()' function warns and may notify similar callbacks name. The 'get_callbacks()' function can recognize UNIX filename pattern such as '*' or '?'. If patterns are given, get_callbacks doesn't raise any exception, and returns empty list.","title":"API"},{"location":"visualization/helper_api/scope_switch_method/#usage_1","text":"from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callbacks ( '/timer_driven_node/callback_0' ) callback2 = app . get_callbacks ( '/timer_driven_node/callback_?' ) callback3 = app . get_callbacks ( '/timer_driven_node/*' )","title":"Usage"},{"location":"visualization/visualization_api/callback_information/","text":"Callback Information # CARET can visualize the callback frequency, period, and latency. Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () #output_notebook() is needed only when you run the script on Jupyter Notebook arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) Execution frequency # # get dataframe plot = Plot . create_callback_frequency_plot ( app ) frequency_df = plot . to_dataframe () frequency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_frequency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below--- Period # # get dataframe plot = Plot . create_callback_period_plot ( app ) period_df = plot . to_dataframe () period_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_period_plot ( app ) plot . show () # ---Output in jupyter-notebook as below--- Latency # # get dataframe plot = Plot . create_callback_latency_plot ( app ) latency_df = plot . to_dataframe () latency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_latency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Callback Information"},{"location":"visualization/visualization_api/callback_information/#callback-information","text":"CARET can visualize the callback frequency, period, and latency. Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () #output_notebook() is needed only when you run the script on Jupyter Notebook arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng )","title":"Callback Information"},{"location":"visualization/visualization_api/callback_information/#execution-frequency","text":"# get dataframe plot = Plot . create_callback_frequency_plot ( app ) frequency_df = plot . to_dataframe () frequency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_frequency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Execution frequency"},{"location":"visualization/visualization_api/callback_information/#period","text":"# get dataframe plot = Plot . create_callback_period_plot ( app ) period_df = plot . to_dataframe () period_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_period_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Period"},{"location":"visualization/visualization_api/callback_information/#latency","text":"# get dataframe plot = Plot . create_callback_latency_plot ( app ) latency_df = plot . to_dataframe () latency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_latency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Latency"},{"location":"visualization/visualization_api/callback_scheduling_visualization/","text":"Callback Scheduling Visualization # Callback Scheduling Visualization will show you callback scheduling of targets such as a Node, Executor, and Callbackgroup. from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import callback_sched arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) app = Application ( arch , lttng ) # target: node node = app . get_node ( 'node_name' ) # get node object callback_sched ( node ) # target: executor executor = app . get_executor ( 'executor_name' ) # get executor object callback_sched ( executor ) # target: executor cbg = app . get_callback_group ( 'cbg_name' ) # get callback group object callback_sched ( cbg ) Callback Scheduling Visualization Short rectangles indicate the callback execution time When the mouse cursor hovers over the long rectangular, a tooltip containing information about the callback will be displayed Timer Event Visualization Arrows shows expected timing of invocation of timer callback When invocations of timer callback are delayed for expected, arrows turns red; otherwise, arrows are white If invocations are late for more 5 ms after expected, they are regarded as delayed","title":"Callback Scheduling Visualization"},{"location":"visualization/visualization_api/callback_scheduling_visualization/#callback-scheduling-visualization","text":"Callback Scheduling Visualization will show you callback scheduling of targets such as a Node, Executor, and Callbackgroup. from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import callback_sched arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) app = Application ( arch , lttng ) # target: node node = app . get_node ( 'node_name' ) # get node object callback_sched ( node ) # target: executor executor = app . get_executor ( 'executor_name' ) # get executor object callback_sched ( executor ) # target: executor cbg = app . get_callback_group ( 'cbg_name' ) # get callback group object callback_sched ( cbg ) Callback Scheduling Visualization Short rectangles indicate the callback execution time When the mouse cursor hovers over the long rectangular, a tooltip containing information about the callback will be displayed Timer Event Visualization Arrows shows expected timing of invocation of timer callback When invocations of timer callback are delayed for expected, arrows turns red; otherwise, arrows are white If invocations are late for more 5 ms after expected, they are regarded as delayed","title":"Callback Scheduling Visualization"},{"location":"visualization/visualization_api/chain_latency/","text":"Chain latency # Chain latency can show the latency of each node in the end-to-end path and the communication time between nodes. from caret_analyze.plot import chain_latency path = app . get_path ( 'target_path' ) chain_latency ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 )","title":"Chain latency"},{"location":"visualization/visualization_api/chain_latency/#chain-latency","text":"Chain latency can show the latency of each node in the end-to-end path and the communication time between nodes. from caret_analyze.plot import chain_latency path = app . get_path ( 'target_path' ) chain_latency ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 )","title":"Chain latency"},{"location":"visualization/visualization_api/communication_information/","text":"Communication Information # CARET can visualize the communication frequency, period, and latency. Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) comm = app . get_communications ( 'topic_name' ) comm = comm [ 0 ] # or comm = app.get_communication('pub_node', 'sub_node', 'topic_name') Frequency # plot = Plot . create_communication_frequency_plot ( comm ) plot . show () Period # plot = Plot . create_communication_period_plot ( comm ) plot . show () Latency # plot = Plot . create_communication_latency_plot ( comm ) plot . show ()","title":"Communication Information"},{"location":"visualization/visualization_api/communication_information/#communication-information","text":"CARET can visualize the communication frequency, period, and latency. Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) comm = app . get_communications ( 'topic_name' ) comm = comm [ 0 ] # or comm = app.get_communication('pub_node', 'sub_node', 'topic_name')","title":"Communication Information"},{"location":"visualization/visualization_api/communication_information/#frequency","text":"plot = Plot . create_communication_frequency_plot ( comm ) plot . show ()","title":"Frequency"},{"location":"visualization/visualization_api/communication_information/#period","text":"plot = Plot . create_communication_period_plot ( comm ) plot . show ()","title":"Period"},{"location":"visualization/visualization_api/communication_information/#latency","text":"plot = Plot . create_communication_latency_plot ( comm ) plot . show ()","title":"Latency"},{"location":"visualization/visualization_api/latency_histogram/","text":"Latency histogram # Histograms can be visualized as follows bins , hist = path . to_histogram () p = figure () p . step ( hist [ 1 :], bins ) show ( p )","title":"Latency histogram"},{"location":"visualization/visualization_api/latency_histogram/#latency-histogram","text":"Histograms can be visualized as follows bins , hist = path . to_histogram () p = figure () p . step ( hist [ 1 :], bins ) show ( p )","title":"Latency histogram"},{"location":"visualization/visualization_api/latency_time_series/","text":"Latency timeseries # t , latency_ns = path . to_timeseries ( remove_dropped = False ) latency_ms = latency_ns * 1.0e-6 p = figure () p . line ( t , latency_ms ) show ( p )","title":"Latency timeseries"},{"location":"visualization/visualization_api/latency_time_series/#latency-timeseries","text":"t , latency_ns = path . to_timeseries ( remove_dropped = False ) latency_ms = latency_ns * 1.0e-6 p = figure () p . line ( t , latency_ms ) show ( p )","title":"Latency timeseries"},{"location":"visualization/visualization_api/message_flow/","text":"Message flow # Visualizing the processing of each message at any point in time. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 ) The vertical axis goes from top to bottom, corresponding to the beginning to the end of the path. Each line represents a message flow. The gray rectangular area indicates the callback execution time. In addition to the basic operations of bokeh, the message flow diagram allows the following operations Scale adjustment of xaxis/yaxis Scale adjustments can be made only on the X-axis or only on the Y-axis by operating the wheel on the axis labels. View detailed information Move the cursor over the lines in the message flow or the gray rectangular area can see the detail information of callback and message.","title":"Message flow"},{"location":"visualization/visualization_api/message_flow/#message-flow","text":"Visualizing the processing of each message at any point in time. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 ) The vertical axis goes from top to bottom, corresponding to the beginning to the end of the path. Each line represents a message flow. The gray rectangular area indicates the callback execution time. In addition to the basic operations of bokeh, the message flow diagram allows the following operations Scale adjustment of xaxis/yaxis Scale adjustments can be made only on the X-axis or only on the Y-axis by operating the wheel on the axis labels. View detailed information Move the cursor over the lines in the message flow or the gray rectangular area can see the detail information of callback and message.","title":"Message flow"},{"location":"visualization/visualization_api/pub_sub_information/","text":"Publish/Subscription Information # CARET can visualize the publish/subscribe frequency and period. Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) pub = app . get_publishers ( 'topic_name' ) pub = pub [ 0 ] # or sub = app.get_subscirber('pub_node', 'sub_node', 'topic_name') Frequency # plot = Plot . create_publish_subscription_frequency_plot ( pub ) plot . show () Period # plot = Plot . create_publish_subscription_period_plot ( pub ) plot . show ()","title":"Publish/Subscription Information"},{"location":"visualization/visualization_api/pub_sub_information/#publishsubscription-information","text":"CARET can visualize the publish/subscribe frequency and period. Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) pub = app . get_publishers ( 'topic_name' ) pub = pub [ 0 ] # or sub = app.get_subscirber('pub_node', 'sub_node', 'topic_name')","title":"Publish/Subscription Information"},{"location":"visualization/visualization_api/pub_sub_information/#frequency","text":"plot = Plot . create_publish_subscription_frequency_plot ( pub ) plot . show ()","title":"Frequency"},{"location":"visualization/visualization_api/pub_sub_information/#period","text":"plot = Plot . create_publish_subscription_period_plot ( pub ) plot . show ()","title":"Period"},{"location":"visualization/visualization_api/response_time/","text":"Plot Response Time # Response Time is shown in Histogram. Response Time has 3 cases ([default, best, worst]). The difference is described in Here . from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) # plot default case plot = Plot . create_response_time_histogram_plot ( path ) plot . show () # plot best case plot = Plot . create_response_time_histogram_plot ( path , case = 'best' ) plot . show () # plot worst case plot = Plot . create_response_time_histogram_plot ( path , case = 'worst' ) plot . show ()","title":"Plot Response Time"},{"location":"visualization/visualization_api/response_time/#plot-response-time","text":"Response Time is shown in Histogram. Response Time has 3 cases ([default, best, worst]). The difference is described in Here . from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) # plot default case plot = Plot . create_response_time_histogram_plot ( path ) plot . show () # plot best case plot = Plot . create_response_time_histogram_plot ( path , case = 'best' ) plot . show () # plot worst case plot = Plot . create_response_time_histogram_plot ( path , case = 'worst' ) plot . show ()","title":"Plot Response Time"}]}