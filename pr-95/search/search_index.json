{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chain-Aware ROS Evaluation Tool (CARET) # CARET is one of performance analysis tool dedicated with ROS 2 applications. It is able to measure not only callback latency and communication latency, but also path latency, in other words, chain of node or callback. As additional tracepoints are introduced by function hook, tracing resolution is improved. Features and capabilities are shown below. Features: Low overhead with LTTng-based tracepoints for sampling events in ROS/DDS layer Flexible tracepoints added by function hooking with LD_PRELOAD Python-based API for flexible data analysis and visualization Application-layer events tracing by cooperation with TILDE, runtime message tracer Capabilities: Performance measurement from several aspects Callback latency, frequency, and period Topic communication latency, frequency, and period Node latency Path latency End-to-end latency of software if path from input to output is selected Visualization of scheduling for callback execution Filtering function to ignore specific nodes and topics Search of target paths to trace Trace of application events like consumption of buffered topic message /tf (planned for v0.3.x release) message_filters (supported by TILDE) image_transport (supported by TILDE) Tracing flow with CARET # CARET gives you capability of tracing your application with introducing new tracepoints to ROS and DDS layer while it utilized original tracepoints for ros2_tracing . CARET is served as only source code, but not as apt package, so far. CARET hooks dedicated functions to those defined in dynamic library in order to add tracepoints. The fork of rclcpp which has CARET-dedicated tracepoints is delivered. You have to build CARET and your application if you want to use. After you run your application with CARET, you will get recorded data which includes events, metadata and timestamp. You have to write a configuration file, called architecture file, in which you defines node latency and target path, before you analyze the data set. You will visualize trace data with the architecture file and CARET_analyze package, including API for data analysis. CARET_analyze is designed on assumption that users analyze trace data on Jupyter Notebook. Contents list # Installation # Installation with Ansible is provided as the following page shows. Installation Tutorials # Refer to these page if you want to try. Recording Configuration Visualization Design # Design documents is prepared, but some are written in Japanese. Architecture overview Supported tracepoints galactic \u3068\u306e\u5dee\u5206(staled) \u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9 \u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u65b9\u6cd5 \u30d1\u30b9\u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9 \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066 \u30c4\u30fc\u30eb\u5229\u7528\u6642\u306e\u5236\u7d04 Details of each step for analysis # CARET serves helpful functions for you to analyze your application efficiently. Please refer to detailed explanation of each step for analysis. Recording Configuration Visualization API list # CARET serves powerful API to visualize and analyze performance. API list is located on the other repository, CARET_analyze . API list (external link) There are two types of APIs: for user and for developer . Related repositories # CARET is constructed of the following packages CARET_trace \uff5c Define tracepoints added by function hooking CARET_analyze \uff5c Library for scripts to analyze and visualize data CARET_analyze_cpp_impl \uff5c Efficient helper functions to analyze trace data written in C++ ros2caret \uff5c CLI commands like ros2 caret CARET_demos \uff5c Demo programs for CARET CARET_doc \uff5c Documentation rclcpp \uff5c the forked rclcpp including CARET-dedicated tracepoints ros2_tracing \uff5c the forked ros2_tracing including definition of CARET-dedicated tracepoints This software is based on results obtained from a project subsidized by the New Energy and Industrial Technology Development Organization (NEDO).","title":"Overview"},{"location":"#chain-aware-ros-evaluation-tool-caret","text":"CARET is one of performance analysis tool dedicated with ROS 2 applications. It is able to measure not only callback latency and communication latency, but also path latency, in other words, chain of node or callback. As additional tracepoints are introduced by function hook, tracing resolution is improved. Features and capabilities are shown below. Features: Low overhead with LTTng-based tracepoints for sampling events in ROS/DDS layer Flexible tracepoints added by function hooking with LD_PRELOAD Python-based API for flexible data analysis and visualization Application-layer events tracing by cooperation with TILDE, runtime message tracer Capabilities: Performance measurement from several aspects Callback latency, frequency, and period Topic communication latency, frequency, and period Node latency Path latency End-to-end latency of software if path from input to output is selected Visualization of scheduling for callback execution Filtering function to ignore specific nodes and topics Search of target paths to trace Trace of application events like consumption of buffered topic message /tf (planned for v0.3.x release) message_filters (supported by TILDE) image_transport (supported by TILDE)","title":"Chain-Aware ROS Evaluation Tool (CARET)"},{"location":"#tracing-flow-with-caret","text":"CARET gives you capability of tracing your application with introducing new tracepoints to ROS and DDS layer while it utilized original tracepoints for ros2_tracing . CARET is served as only source code, but not as apt package, so far. CARET hooks dedicated functions to those defined in dynamic library in order to add tracepoints. The fork of rclcpp which has CARET-dedicated tracepoints is delivered. You have to build CARET and your application if you want to use. After you run your application with CARET, you will get recorded data which includes events, metadata and timestamp. You have to write a configuration file, called architecture file, in which you defines node latency and target path, before you analyze the data set. You will visualize trace data with the architecture file and CARET_analyze package, including API for data analysis. CARET_analyze is designed on assumption that users analyze trace data on Jupyter Notebook.","title":"Tracing flow with CARET"},{"location":"#contents-list","text":"","title":"Contents list"},{"location":"#installation","text":"Installation with Ansible is provided as the following page shows. Installation","title":"Installation"},{"location":"#tutorials","text":"Refer to these page if you want to try. Recording Configuration Visualization","title":"Tutorials"},{"location":"#design","text":"Design documents is prepared, but some are written in Japanese. Architecture overview Supported tracepoints galactic \u3068\u306e\u5dee\u5206(staled) \u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9 \u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u65b9\u6cd5 \u30d1\u30b9\u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9 \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066 \u30c4\u30fc\u30eb\u5229\u7528\u6642\u306e\u5236\u7d04","title":"Design"},{"location":"#details-of-each-step-for-analysis","text":"CARET serves helpful functions for you to analyze your application efficiently. Please refer to detailed explanation of each step for analysis. Recording Configuration Visualization","title":"Details of each step for analysis"},{"location":"#api-list","text":"CARET serves powerful API to visualize and analyze performance. API list is located on the other repository, CARET_analyze . API list (external link) There are two types of APIs: for user and for developer .","title":"API list"},{"location":"#related-repositories","text":"CARET is constructed of the following packages CARET_trace \uff5c Define tracepoints added by function hooking CARET_analyze \uff5c Library for scripts to analyze and visualize data CARET_analyze_cpp_impl \uff5c Efficient helper functions to analyze trace data written in C++ ros2caret \uff5c CLI commands like ros2 caret CARET_demos \uff5c Demo programs for CARET CARET_doc \uff5c Documentation rclcpp \uff5c the forked rclcpp including CARET-dedicated tracepoints ros2_tracing \uff5c the forked ros2_tracing including definition of CARET-dedicated tracepoints This software is based on results obtained from a project subsidized by the New Energy and Industrial Technology Development Organization (NEDO).","title":"Related repositories"},{"location":"changelog/","text":"Changelog # CARET # v0.3.0 _ July 14, 2022 # Supported OS: Ubuntu 22.04 Supported ROS Dist.: ROS Humble Imported to Ubuntu 22.04 and ROS Humble Added new feature to show response time ( CARET_analyze #96 ) Reduced memory consumption wasted for recorded data ( CARET_analyze #100 ) Launched CARET_analyze API document Added small fixes CARET_analyze #107 CARET_analyze #107 CARET_analyze #108 CARET_analyze #109 CARET_analyze #112 CARET_analyze #115 v0.2.3 _ July 14, 2022 # Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Improved output message from path.verify() method Improved view of graphs Added wildcard support for Architecture.callbacks() method Added command line function to check trace data Fixed specification of Architecture.search_paths() method Added function to extract duplicated timer callback v0.2.2 _ May 2, 2022 # Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Added feature to measure complicated node path Added feature to choose optional trace points Added Architecture.search_paths() method Improved trace filtering function","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#caret","text":"","title":"CARET"},{"location":"changelog/#id","text":"Supported OS: Ubuntu 22.04 Supported ROS Dist.: ROS Humble Imported to Ubuntu 22.04 and ROS Humble Added new feature to show response time ( CARET_analyze #96 ) Reduced memory consumption wasted for recorded data ( CARET_analyze #100 ) Launched CARET_analyze API document Added small fixes CARET_analyze #107 CARET_analyze #107 CARET_analyze #108 CARET_analyze #109 CARET_analyze #112 CARET_analyze #115","title":"v0.3.0 _ July 14, 2022"},{"location":"changelog/#id","text":"Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Improved output message from path.verify() method Improved view of graphs Added wildcard support for Architecture.callbacks() method Added command line function to check trace data Fixed specification of Architecture.search_paths() method Added function to extract duplicated timer callback","title":"v0.3.0 _ July 14, 2022"},{"location":"changelog/#id","text":"Supported OS: Ubuntu 20.04 Supported ROS Dist.: ROS Galactic Added feature to measure complicated node path Added feature to choose optional trace points Added Architecture.search_paths() method Improved trace filtering function","title":"v0.3.0 _ July 14, 2022"},{"location":"gallery/","text":"Gallery # This page shows examples of figures that can be visualized in CARET. CARET visualizes these figures on jupyter-notebook. In order to display bokeh graphs on jupyter-notebook, the following commands must be executed beforehand. from bokeh.plotting import output_notebook , figure , show output_notebook () Message flow # Source code : Message flow Chain latency # Source code : Chain latency Latency timeseries # Source code : Latency timeseries Latency histogram # Source code : Latency histogram Execution frequency # Period # Latency # Source code : Execution frequency Callback Scheduling Visualization # Source code : Callback Scheduling Visualization","title":"Gallery"},{"location":"gallery/#gallery","text":"This page shows examples of figures that can be visualized in CARET. CARET visualizes these figures on jupyter-notebook. In order to display bokeh graphs on jupyter-notebook, the following commands must be executed beforehand. from bokeh.plotting import output_notebook , figure , show output_notebook ()","title":"Gallery"},{"location":"gallery/#message-flow","text":"Source code : Message flow","title":"Message flow"},{"location":"gallery/#chain-latency","text":"Source code : Chain latency","title":"Chain latency"},{"location":"gallery/#latency-timeseries","text":"Source code : Latency timeseries","title":"Latency timeseries"},{"location":"gallery/#latency-histogram","text":"Source code : Latency histogram","title":"Latency histogram"},{"location":"gallery/#execution-frequency","text":"","title":"Execution frequency"},{"location":"gallery/#period","text":"","title":"Period"},{"location":"gallery/#latency","text":"Source code : Execution frequency","title":"Latency"},{"location":"gallery/#callback-scheduling-visualization","text":"Source code : Callback Scheduling Visualization","title":"Callback Scheduling Visualization"},{"location":"configuration/","text":"Configuration #","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/architecture_format/","text":"End-to-End \u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u6e2c\u5b9a\u65b9\u6cd5 # \u4ee5\u4e0b\u306b\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092\u793a\u3057\u307e\u3059\u3002 \u306e\u4ed8\u3044\u305f\u9805\u76ee\u306f\u3001\u6e2c\u5b9a\u5bfe\u8c61\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5b9f\u88c5\u3092\u78ba\u8a8d\u306e\u4e0a\u3001\u624b\u4f5c\u696d\u3067\u306e\u4fee\u6b63\u304c\u5fc5\u8981\u306a\u9805\u76ee\u3067\u3059\u3002 \u306e\u4ed8\u3044\u3066\u3044\u306a\u3044\u9805\u76ee\u306f\u96db\u5f62\u3068\u3057\u3066\u81ea\u52d5\u7684\u306b\u8a18\u8f09\u3055\u308c\u307e\u3059 named_paths:\u3010\u30d1\u30b9\u60c5\u5831\u3011 - path_name : target_path\u3010\u30d1\u30b9\u306e\u540d\u524d\u3011 node_chain : - node_name : /ping_node \u3010\u30ce\u30fc\u30c9\u540d\u3011 publish_topic_name : /chatter \u3010\u30ce\u30fc\u30c9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 subscribe_topic_name : UNDEFINED\u3010\u30ce\u30fc\u30c9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 - node_name : /pong_node publish_topic_name : UNDEFINED subscribe_topic_name : /chatter executors:\u3010\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u30fc\u60c5\u5831\u3011 - executor_type : single_threaded_executor\u3010\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u30fc\u7a2e\u5225\u3011 executor_name : \u3010\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u30fc\u540d\u3011 callback_group_names : - /ping_node/callback_group_0 \u3010\u8ffd\u52a0\u3055\u308c\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u540d\u3011 - /pong_node/callback_group_0 nodes:\u3010\u30ce\u30fc\u30c9\u60c5\u5831\u3011 - node_name : /ping_node\u3010\u30ce\u30fc\u30c9\u540d\u3011 callback_groups:\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u306e\u60c5\u5831\u3011 - callback_group_type:\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u306e\u7a2e\u5225\u3011 callback_group_name : /ping_node/callback_group_0 \u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u540d\u3011 callback_names : - /ping_node/callback_0 \u3010\u8ffd\u52a0\u3055\u308c\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 callbacks:\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u60c5\u5831\u3011 - callback_name : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 type : subscription_callback\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u7a2e\u5225\u3011 topic_name : /topic3\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 symbol : Node::{lambda()}\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u306e\u30b7\u30f3\u30dc\u30eb\u540d\u3011 - callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 type : timer_callback\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u7a2e\u985e\u3011 period_ns : 100000000\u3010\u30bf\u30a4\u30de\u30fc\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5468\u671f\u3011 symbol : Node::{lambda()}\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u306e\u30b7\u30f3\u30dc\u30eb\u540d\u3011 variable_passings:\u3010\u5909\u6570\u3092\u4ecb\u3057\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u6e21\u3057\u3011 - callback_name_write : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 callback_name_read : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 publishes:\u3010\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u306e\u60c5\u5831\u3011 - topic_name : /ping\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 subscribes:\u3010\u30b5\u30d6\u30b9\u30af\u30e9\u30a4\u30d6\u306e\u60c5\u5831\u3011 - topic_name : /pong\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 message_contexts:\u3010\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9\u3011 - context_type : use_latest_message\u3010\u7b97\u51fa\u65b9\u6cd5\u306e\u7a2e\u5225*\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u3078\u306e\u5165\u529b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u304b\u3089\u306e\u51fa\u529b\u30c8\u30d4\u30c3\u30af\u540d\u3011","title":"\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8"},{"location":"configuration/architecture_format/#end-to-end","text":"\u4ee5\u4e0b\u306b\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092\u793a\u3057\u307e\u3059\u3002 \u306e\u4ed8\u3044\u305f\u9805\u76ee\u306f\u3001\u6e2c\u5b9a\u5bfe\u8c61\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5b9f\u88c5\u3092\u78ba\u8a8d\u306e\u4e0a\u3001\u624b\u4f5c\u696d\u3067\u306e\u4fee\u6b63\u304c\u5fc5\u8981\u306a\u9805\u76ee\u3067\u3059\u3002 \u306e\u4ed8\u3044\u3066\u3044\u306a\u3044\u9805\u76ee\u306f\u96db\u5f62\u3068\u3057\u3066\u81ea\u52d5\u7684\u306b\u8a18\u8f09\u3055\u308c\u307e\u3059 named_paths:\u3010\u30d1\u30b9\u60c5\u5831\u3011 - path_name : target_path\u3010\u30d1\u30b9\u306e\u540d\u524d\u3011 node_chain : - node_name : /ping_node \u3010\u30ce\u30fc\u30c9\u540d\u3011 publish_topic_name : /chatter \u3010\u30ce\u30fc\u30c9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 subscribe_topic_name : UNDEFINED\u3010\u30ce\u30fc\u30c9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 - node_name : /pong_node publish_topic_name : UNDEFINED subscribe_topic_name : /chatter executors:\u3010\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u30fc\u60c5\u5831\u3011 - executor_type : single_threaded_executor\u3010\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u30fc\u7a2e\u5225\u3011 executor_name : \u3010\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u30fc\u540d\u3011 callback_group_names : - /ping_node/callback_group_0 \u3010\u8ffd\u52a0\u3055\u308c\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u540d\u3011 - /pong_node/callback_group_0 nodes:\u3010\u30ce\u30fc\u30c9\u60c5\u5831\u3011 - node_name : /ping_node\u3010\u30ce\u30fc\u30c9\u540d\u3011 callback_groups:\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u306e\u60c5\u5831\u3011 - callback_group_type:\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u306e\u7a2e\u5225\u3011 callback_group_name : /ping_node/callback_group_0 \u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30eb\u30fc\u30d7\u540d\u3011 callback_names : - /ping_node/callback_0 \u3010\u8ffd\u52a0\u3055\u308c\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 callbacks:\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u60c5\u5831\u3011 - callback_name : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 type : subscription_callback\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u7a2e\u5225\u3011 topic_name : /topic3\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 symbol : Node::{lambda()}\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u306e\u30b7\u30f3\u30dc\u30eb\u540d\u3011 - callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 type : timer_callback\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u7a2e\u985e\u3011 period_ns : 100000000\u3010\u30bf\u30a4\u30de\u30fc\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5468\u671f\u3011 symbol : Node::{lambda()}\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u306e\u30b7\u30f3\u30dc\u30eb\u540d\u3011 variable_passings:\u3010\u5909\u6570\u3092\u4ecb\u3057\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u6e21\u3057\u3011 - callback_name_write : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 callback_name_read : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 publishes:\u3010\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u306e\u60c5\u5831\u3011 - topic_name : /ping\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 subscribes:\u3010\u30b5\u30d6\u30b9\u30af\u30e9\u30a4\u30d6\u306e\u60c5\u5831\u3011 - topic_name : /pong\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 message_contexts:\u3010\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9\u3011 - context_type : use_latest_message\u3010\u7b97\u51fa\u65b9\u6cd5\u306e\u7a2e\u5225*\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u3078\u306e\u5165\u529b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u304b\u3089\u306e\u51fa\u529b\u30c8\u30d4\u30c3\u30af\u540d\u3011","title":"End-to-End \u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u6e2c\u5b9a\u65b9\u6cd5"},{"location":"configuration/create_and_verify_architecture/","text":"Creation and verification of architecture files with CLI # CARET provides CLI to create architecture files and verify paths. Creation of architecture file # The architecture file describes the application structure and latency definitions. The following commands can create an architecture file template including only the application structure section. ros2 caret create_architecture_file [ PATH_TO_CTF ] -o [ OUTPUT_PATH ] After creating the architecture file, please refer to How to define a target path . Verification of paths # The following command verifies whether latency definitions are set sufficiently. ros2 caret verify_paths [ PATH_TO_ARCHITECTURE_FILE ] -p [ DEFINED_PATH_NAMES ] -p is optional; by default, all defined paths are verified. Any number of [DEFINED_PATH_NAMES] can be inputted. This command executes the path.verify() method. Please refer to How to define latency of a single node for details on the path.verify() method and how to handle output warnings.","title":"Creation and Verification of Architecture file with CLI"},{"location":"configuration/create_and_verify_architecture/#creation-and-verification-of-architecture-files-with-cli","text":"CARET provides CLI to create architecture files and verify paths.","title":"Creation and verification of architecture files with CLI"},{"location":"configuration/create_and_verify_architecture/#creation-of-architecture-file","text":"The architecture file describes the application structure and latency definitions. The following commands can create an architecture file template including only the application structure section. ros2 caret create_architecture_file [ PATH_TO_CTF ] -o [ OUTPUT_PATH ] After creating the architecture file, please refer to How to define a target path .","title":"Creation of architecture file"},{"location":"configuration/create_and_verify_architecture/#verification-of-paths","text":"The following command verifies whether latency definitions are set sufficiently. ros2 caret verify_paths [ PATH_TO_ARCHITECTURE_FILE ] -p [ DEFINED_PATH_NAMES ] -p is optional; by default, all defined paths are verified. Any number of [DEFINED_PATH_NAMES] can be inputted. This command executes the path.verify() method. Please refer to How to define latency of a single node for details on the path.verify() method and how to handle output warnings.","title":"Verification of paths"},{"location":"configuration/how_to_search_path/","text":"\u30d1\u30b9\u63a2\u7d22\u306e\u9ad8\u901f\u5316 # search_paths \u30e1\u30bd\u30c3\u30c9\u306f\u30ce\u30fc\u30c9\u56f3\u3092\u63cf\u304d\u3001\u59cb\u70b9\u306b\u8a2d\u5b9a\u3057\u305f\u30ce\u30fc\u30c9\u304b\u3089\u7d42\u70b9\u306b\u8a2d\u5b9a\u3057\u305f\u30ce\u30fc\u30c9\u307e\u3067\u3092\u4e00\u7b46\u66f8\u304d\u3067\u8fbf\u308c\u308b\u7d4c\u8def\uff08\u30d1\u30b9\uff09\u3092\u5168\u63a2\u7d22\u3057\u3001 \u898b\u3064\u304b\u3063\u305f\u7d4c\u8def\uff08\u30d1\u30b9\uff09\u3092\u5168\u3066\u8fd4\u5374\u3059\u308b\u95a2\u6570\u3067\u3059\u3002 \u30ce\u30fc\u30c9\u56f3\u304b\u3089\u5168\u3066\u306e\u63a2\u7d22\u3067\u304d\u308b\u30d1\u30b9\u3092\u5168\u63a2\u7d22\u3059\u308b\u305f\u3081\u3001\u5bfe\u8c61\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u3063\u3066\u306f\u51e6\u7406\u306b\u6642\u9593\u304c\u304b\u304b\u308a\u3059\u304e\u3066\u3057\u307e\u3046\u30b1\u30fc\u30b9\u304c\u3042\u308a\u307e\u3059\u3002 \u3053\u306e\u3088\u3046\u306a\u30b1\u30fc\u30b9\u3067\u3001\u9ad8\u901f\u306b\u76ee\u7684\u3068\u3059\u308b\u30d1\u30b9\u3092\u63a2\u7d22\u3059\u308b\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 API # search_paths \u3067\u306f\u3001\u3053\u306e\u3088\u3046\u306a\u6642\u9593\u304c\u304b\u304b\u308a\u3059\u304e\u3066\u3057\u307e\u3046\u30b1\u30fc\u30b9\u3092\u907f\u3051\u308b\u305f\u3081\u306e API \u304c\u5099\u308f\u3063\u3066\u3044\u307e\u3059\u3002 search_paths ( start_node_name : 'str' , end_node_name : 'str' , max_node_depth : 'Optional[int]' = None , node_filter : 'Optional[Callable[[str], bool]]' = None , communication_filter : 'Optional[Callable[[str], bool]]' = None ) -> 'List[PathStructValue]' start_node_name : \u63a2\u7d22\u306e\u59cb\u70b9\u3068\u306a\u308b\u30ce\u30fc\u30c9\u540d end_node_name : \u63a2\u7d22\u306e\u7d42\u70b9\u3068\u306a\u308b\u30ce\u30fc\u30c9\u540d max_node_depth : \u63a2\u7d22\u3059\u308b\u30d1\u30b9\u304c\u542b\u3080\u6700\u5927\u30ce\u30fc\u30c9\u6570\u3002\u5c0f\u3055\u3044\u307b\u3069\u63a2\u7d22\u7bc4\u56f2\u304c\u72ed\u304f\u306a\u308a\u307e\u3059 node_filter: \u63a2\u7d22\u5bfe\u8c61\u306e\u30ce\u30fc\u30c9\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u95a2\u6570\u3002True \u3092\u8fd4\u5374\u3057\u305f\u5834\u5408\u306f\u63a2\u7d22\u5bfe\u8c61\u306b\u306a\u308a\u307e\u3059\u3002 communication_filter: \u63a2\u7d22\u5bfe\u8c61\u306e\u901a\u4fe1\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u95a2\u6570\u3002True \u3092\u8fd4\u5374\u3057\u305f\u5834\u5408\u306f\u63a2\u7d22\u5bfe\u8c61\u306b\u306a\u308a\u307e\u3059\u3002 \u4f8b # import re # \u6b63\u898f\u8868\u73fe\u306b\u4e00\u81f4\u3059\u308b\u30ce\u30fc\u30c9\u540d\u3092\u63a2\u7d22\u304b\u3089\u9664\u5916\u3059\u308b node_filters = [ re . compile ( r '/_ros2cli_/*' ), re . compile ( r '/launch_ros_*' ), ] # \u6b63\u898f\u8868\u73fe\u306b\u4e00\u81f4\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3092\u63a2\u7d22\u304b\u3089\u9664\u5916\u3059\u308b comm_filters = [ re . compile ( r '/tf/*' ), ] def comm_filter ( topic_name : str ) -> bool : can_pass = True for comm_filter in comm_filters : can_pass &= not bool ( comm_filter . search ( topic_name )) return can_pass def node_filter ( node_name : str ) -> bool : can_pass = True for node_filter in node_filters : can_pass &= not bool ( node_filter . search ( node_name )) return can_pass paths = arch . search_paths ( '/start_node' , '/end_node' , max_node_depth = 30 , node_filter = node_filter , communication_filter = comm_filter )","title":"\u30d1\u30b9\u306e\u63a2\u7d22\u65b9\u6cd5"},{"location":"configuration/how_to_search_path/#_1","text":"search_paths \u30e1\u30bd\u30c3\u30c9\u306f\u30ce\u30fc\u30c9\u56f3\u3092\u63cf\u304d\u3001\u59cb\u70b9\u306b\u8a2d\u5b9a\u3057\u305f\u30ce\u30fc\u30c9\u304b\u3089\u7d42\u70b9\u306b\u8a2d\u5b9a\u3057\u305f\u30ce\u30fc\u30c9\u307e\u3067\u3092\u4e00\u7b46\u66f8\u304d\u3067\u8fbf\u308c\u308b\u7d4c\u8def\uff08\u30d1\u30b9\uff09\u3092\u5168\u63a2\u7d22\u3057\u3001 \u898b\u3064\u304b\u3063\u305f\u7d4c\u8def\uff08\u30d1\u30b9\uff09\u3092\u5168\u3066\u8fd4\u5374\u3059\u308b\u95a2\u6570\u3067\u3059\u3002 \u30ce\u30fc\u30c9\u56f3\u304b\u3089\u5168\u3066\u306e\u63a2\u7d22\u3067\u304d\u308b\u30d1\u30b9\u3092\u5168\u63a2\u7d22\u3059\u308b\u305f\u3081\u3001\u5bfe\u8c61\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u3063\u3066\u306f\u51e6\u7406\u306b\u6642\u9593\u304c\u304b\u304b\u308a\u3059\u304e\u3066\u3057\u307e\u3046\u30b1\u30fc\u30b9\u304c\u3042\u308a\u307e\u3059\u3002 \u3053\u306e\u3088\u3046\u306a\u30b1\u30fc\u30b9\u3067\u3001\u9ad8\u901f\u306b\u76ee\u7684\u3068\u3059\u308b\u30d1\u30b9\u3092\u63a2\u7d22\u3059\u308b\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u307e\u3059\u3002","title":"\u30d1\u30b9\u63a2\u7d22\u306e\u9ad8\u901f\u5316"},{"location":"configuration/how_to_search_path/#api","text":"search_paths \u3067\u306f\u3001\u3053\u306e\u3088\u3046\u306a\u6642\u9593\u304c\u304b\u304b\u308a\u3059\u304e\u3066\u3057\u307e\u3046\u30b1\u30fc\u30b9\u3092\u907f\u3051\u308b\u305f\u3081\u306e API \u304c\u5099\u308f\u3063\u3066\u3044\u307e\u3059\u3002 search_paths ( start_node_name : 'str' , end_node_name : 'str' , max_node_depth : 'Optional[int]' = None , node_filter : 'Optional[Callable[[str], bool]]' = None , communication_filter : 'Optional[Callable[[str], bool]]' = None ) -> 'List[PathStructValue]' start_node_name : \u63a2\u7d22\u306e\u59cb\u70b9\u3068\u306a\u308b\u30ce\u30fc\u30c9\u540d end_node_name : \u63a2\u7d22\u306e\u7d42\u70b9\u3068\u306a\u308b\u30ce\u30fc\u30c9\u540d max_node_depth : \u63a2\u7d22\u3059\u308b\u30d1\u30b9\u304c\u542b\u3080\u6700\u5927\u30ce\u30fc\u30c9\u6570\u3002\u5c0f\u3055\u3044\u307b\u3069\u63a2\u7d22\u7bc4\u56f2\u304c\u72ed\u304f\u306a\u308a\u307e\u3059 node_filter: \u63a2\u7d22\u5bfe\u8c61\u306e\u30ce\u30fc\u30c9\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u95a2\u6570\u3002True \u3092\u8fd4\u5374\u3057\u305f\u5834\u5408\u306f\u63a2\u7d22\u5bfe\u8c61\u306b\u306a\u308a\u307e\u3059\u3002 communication_filter: \u63a2\u7d22\u5bfe\u8c61\u306e\u901a\u4fe1\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u95a2\u6570\u3002True \u3092\u8fd4\u5374\u3057\u305f\u5834\u5408\u306f\u63a2\u7d22\u5bfe\u8c61\u306b\u306a\u308a\u307e\u3059\u3002","title":"API"},{"location":"configuration/how_to_search_path/#_2","text":"import re # \u6b63\u898f\u8868\u73fe\u306b\u4e00\u81f4\u3059\u308b\u30ce\u30fc\u30c9\u540d\u3092\u63a2\u7d22\u304b\u3089\u9664\u5916\u3059\u308b node_filters = [ re . compile ( r '/_ros2cli_/*' ), re . compile ( r '/launch_ros_*' ), ] # \u6b63\u898f\u8868\u73fe\u306b\u4e00\u81f4\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3092\u63a2\u7d22\u304b\u3089\u9664\u5916\u3059\u308b comm_filters = [ re . compile ( r '/tf/*' ), ] def comm_filter ( topic_name : str ) -> bool : can_pass = True for comm_filter in comm_filters : can_pass &= not bool ( comm_filter . search ( topic_name )) return can_pass def node_filter ( node_name : str ) -> bool : can_pass = True for node_filter in node_filters : can_pass &= not bool ( node_filter . search ( node_name )) return can_pass paths = arch . search_paths ( '/start_node' , '/end_node' , max_node_depth = 30 , node_filter = node_filter , communication_filter = comm_filter )","title":"\u4f8b"},{"location":"configuration/how_to_write_architecture/","text":"\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u4f5c\u6210\u65b9\u6cd5 # \u30d1\u30b9\u306e\u5b9a\u7fa9\u306e\u78ba\u8a8d\u65b9\u6cd5 # path . verify () WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 check_procedure ( 'yaml' , './architecture.yaml' , arch , '/message_driven_node' ) [callback_chain] [callback_chain] Path Added: subscribe: /drive, publish: None, callbacks: ('/message_driven_node/callback_1',) Path Added: subscribe: /drive, publish: None, callbacks: ('/message_driven_node/callback_1',) Path Added: subscribe: /topic2, publish: None, callbacks: ('/message_driven_node/callback_0',) Path Added: subscribe: /topic2, publish: None, callbacks: ('/message_driven_node/callback_0',) [pub-sub pair] [pub-sub pair] Path Added: subscribe: /drive, publish: /topic3, Path Added: subscribe: /drive, publish: /topic3, Path Added: subscribe: /topic2, publish: /topic3, Path Added: subscribe: /topic2, publish: /topic3, [dummy paths] [dummy paths] Path Added: subscribe: None, publish: /topic3, Path Added: subscribe: None, publish: /topic3, message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/drive', 'publisher_topic_name': '/topic3'} message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/drive', 'publisher_topic_name': '/topic3'} message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/topic2', 'publisher_topic_name': '/topic3'} message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/topic2', 'publisher_topic_name': '/topic3'} 5 paths found in /message_driven_node. 5 paths found in /message_driven_node. ----- [message context assigned] ----- [message context assigned] subscribe: /drive, publish: None, message_context: None subscribe: /drive, publish: None, message_context: None subscribe: /topic2, publish: None, message_context: None subscribe: /topic2, publish: None, message_context: None subscribe: /drive, publish: /topic3, message_context: None subscribe: /drive, publish: /topic3, message_context: None subscribe: /topic2, publish: /topic3, message_context: None subscribe: /topic2, publish: /topic3, message_context: None subscribe: None, publish: /topic3, message_context: None subscribe: None, publish: /topic3, message_context: None \u4eca\u56de\u306e\u5834\u5408\u306f\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u65b9\u6cd5\u306e\u6307\u5b9a # \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u3001\u300c\u30ce\u30fc\u30c9\u304c\u30e1\u30c3\u30bb\u30fc\u30b8\u3092 subscribe \u3057\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u51e6\u7406\u958b\u59cb\u3059\u308b\u6642\u523b\u300d\u304b\u3089\u300c\u30ce\u30fc\u30c9\u304c\u30e1\u30c3\u30bb\u30fc\u30b8\u3092 publish \u3059\u308b\u6642\u523b\u300d\u307e\u3067\u3068\u3057\u3066\u3044\u307e\u3059\u3002 \u305f\u3060\u3057\u3001\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u30ce\u30fc\u30c9\u306e\u5b9f\u88c5\u306b\u3082\u5927\u304d\u304f\u4f9d\u5b58\u3057\u3001\u7d71\u4e00\u7684\u306a\u624b\u6cd5\u3067\u306e\u6e2c\u5b9a\u306f\u56f0\u96e3\u3067\u3059\u3002 CARET \u3067\u306f\u3044\u304f\u3064\u304b\u306e\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u3092\u63d0\u4f9b\u3057\u3066\u3044\u307e\u3059\u3002 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306f\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3067\u306f\u3001\u4e3b\u306b message_context \u3068\u3044\u3046\u9805\u76ee\u3068\u3057\u3066\u6307\u5b9a\u3057\u307e\u3059\u3002 message_context \u3068\u3057\u3066\u3001\u4ee5\u4e0b\u306e\u30dd\u30ea\u30b7\u30fc\u304c\u6307\u5b9a\u53ef\u80fd\u3067\u3059\u3002 callback_chain inherit_unique_stamp use_latest_message \u305d\u308c\u305e\u308c\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u304c\u7570\u306a\u308a\u3001\u6e2c\u5b9a\u3067\u304d\u308b\u7c92\u5ea6\u306e\u9055\u3044\u3084\u3001\u6e2c\u5b9a\u3067\u304d\u308b\u30b1\u30fc\u30b9\u30fb\u3067\u304d\u306a\u3044\u30b1\u30fc\u30b9\u304c\u7570\u306a\u308a\u307e\u3059\u3002 \u5f93\u3063\u3066\u3001\u30ce\u30fc\u30c9\u306e\u5b9f\u88c5\u3092\u78ba\u8a8d\u3057\u3001\u3069\u306e\u30dd\u30ea\u30b7\u30fc\u3067\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3055\u305b\u308b\u304b\u3001\u3092\u4f7f\u3044\u5206\u3051\u308b\u5fc5\u8981\u304c\u6709\u308a\u307e\u3059\u3002 \u305d\u308c\u305e\u308c\u306e\u8a73\u7d30\u306b\u3064\u3044\u3066\u306f \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306b\u3064\u3044\u3066 \u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \u672c\u7bc0\u3067\u306f\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u8a18\u8ff0\u65b9\u6cd5\u3092\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 callback_chain # callback_chain \u306f\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5b9f\u884c\u9593\u304b\u3089\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3059\u308b\u65b9\u6cd5\u3067\u3059\u3002 \u30ce\u30fc\u30c9\u306e\u5185\u306e\u51e6\u7406\u3092\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30ec\u30d9\u30eb\u307e\u3067\u5206\u89e3\u3059\u308b\u306e\u3067\u3001\u7d30\u304b\u3044\u7c92\u5ea6\u3067\u6e2c\u5b9a\u304c\u53ef\u80fd\u3067\u3059\u3002 \u8a18\u8ff0\u4f8b # \u91cd\u8981\u306a\u9805\u76ee\u306e\u307f\u3092\u629c\u7c8b\u3057\u305f\u8a18\u8ff0\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 *\u306e\u4ed8\u3044\u305f\u9805\u76ee\u306f\u3001\u6e2c\u5b9a\u5bfe\u8c61\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5b9f\u88c5\u3092\u78ba\u8a8d\u306e\u4e0a\u3001\u624b\u4f5c\u696d\u3067\u306e\u4fee\u6b63\u304c\u5fc5\u8981\u306a\u9805\u76ee\u3067\u3059\u3002 - node_name : /ping_node callbacks : - callback_name : subscription_callback_0 - callback_name : timer_callback_0 variable_passings : - callback_name_write : subscription_callback_0 \u3010* \u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u30e1\u30f3\u30d0\u306b\u66f8\u304d\u8fbc\u3080\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 callback_name_read : timer_callback_0 \u3010*\u30e1\u30f3\u30d0\u304b\u3089\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u8aad\u307f\u8fbc\u3080\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 publishes : - topic_name : /ping\u3010/ping_node\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0 \u3010* /ping\u30c8\u30d4\u30c3\u30af\u3092publish\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 subscribes : - topic_name : /pong\u3010/ping_node\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : timer_callback_0\u3010subscribe\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 message_contexts : - context_type : callback_chain \u3010*\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u30dd\u30ea\u30b7\u30fc\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_chain \u30dd\u30ea\u30b7\u30fc\u3067\u306f\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\u3059\u308b\u305f\u3081\u306e\u60c5\u5831\u3068\u3057\u3066\u3001 variable_passings \u3092\u6307\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306e\u53ef\u8996\u5316 # \u4f5c\u6210\u3057\u305f\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3092\u5143\u306b\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3092\u53ef\u8996\u5316\u3067\u304d\u307e\u3059\u3002 \u3053\u3053\u3067\u306f\u3001 CUI \u306b\u3088\u308b\u53ef\u8996\u5316\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 cd ~/ros2_ws/evaluate ros2 caret callback_graph -a ./architecture.yaml -o calback_graph.svg \u30b0\u30e9\u30d5\u306e\u4f5c\u6210\u306b\u306f Graphviz \u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002 \u4f7f\u7528\u53ef\u80fd\u306a\u62e1\u5f35\u5b50\u306b\u3064\u3044\u3066\u306f Graphviz|Output Formats \u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002 \u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002 \u7070\u8272\u306f\u540d\u524d\u7a7a\u9593\u3001\u89d2\u4e38\u56db\u89d2\u306f\u30ce\u30fc\u30c9\u3001\u56db\u89d2\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3001\u77e2\u5370\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u4f9d\u5b58\u95a2\u4fc2\u3092\u793a\u3057\u3066\u3044\u307e\u3059\u3002 \u8d64\u77e2\u5370\u306f\u30c8\u30d4\u30c3\u30af\u3092 publish \u3057\u3066\u3044\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u4e0d\u660e\u306a\u30c8\u30d4\u30c3\u30af\u901a\u4fe1\u3092\u793a\u3057\u3066\u3044\u307e\u3059\u3002 \u3053\u306e\u8d64\u77e2\u5370\u304c\u3001\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3092\u7de8\u96c6\u3057\u3001publish \u5143\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3092\u6307\u5b9a\u3059\u308b\u5fc5\u8981\u306e\u3042\u308b\u7b87\u6240\u3067\u3059\u3002 \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u578b\u306f svg \u5f62\u5f0f\u3067\u3001 tooltip \u306b\u3088\u308b\u60c5\u5831\u306e\u8868\u793a\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\u3002 \u30ab\u30fc\u30bd\u30eb\u3092\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306b\u5408\u308f\u305b\u308b\u3053\u3068\u3067\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u30b7\u30f3\u30dc\u30eb\u540d\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u60c5\u5831\u306e\u8a18\u8ff0 # \u51fa\u529b\u76f4\u5f8c\u306e\u96db\u5f62\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u4f9d\u5b58\u95a2\u4fc2\u306a\u3069\u304c\u8a18\u8ff0\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002 caret \u306f\u30d1\u30b9\u306e\u63a2\u7d22\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3092\u5229\u7528\u3059\u308b\u306e\u3067\u3001\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u4fee\u6b63\u304c\u5fc5\u8981\u306b\u306a\u308a\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u69cb\u7bc9\u306e\u305f\u3081\u306b\u4fee\u6b63\u3059\u308b\u9805\u76ee\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u3068 publish \u306e\u7d10\u4ed8\u3051\uff08\u4e0a\u56f3\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306e\u8d64\u77e2\u5370\uff09 [/nodes/node/publish] \u306b\u306f\u3001\u30ce\u30fc\u30c9\u304c publish \u3057\u3066\u3044\u308b\u30c8\u30d4\u30c3\u30af\u540d\u304c key \u3068\u3057\u3066\u5217\u6319\u3055\u308c\u3066\u3044\u307e\u3059\u3002 value \u306b\u30c8\u30d4\u30c3\u30af\u3092 publish \u3057\u3066\u3044\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3092\u8a18\u8ff0\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \u672a\u63a5\u7d9a\u306e\u30c8\u30d4\u30c3\u30af\u901a\u4fe1\uff08\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u4e0a\u306e\u8d64\u77e2\u5370\uff09\u304c\u7121\u304f\u306a\u308b\u307e\u3067\u4fee\u6b63\u3057\u3066\u304f\u3060\u3055\u3044\u3002 publishes:\u3010\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u306e\u60c5\u5831\u3011 - topic_name : /topic4\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u5909\u6570\u6e21\u3057\u306e\u8a18\u8ff0 [/nodes/node/variable_passing]\u306b\u306f\u3001\u5909\u6570\u6e21\u3057\u306b\u3088\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u4f9d\u5b58\u95a2\u4fc2\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002 callback_write \u306b\u306f\u66f8\u304d\u8fbc\u307f\u5074\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3001callback_read \u306b\u306f\u8aad\u307f\u8fbc\u307f\u5074\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3092\u8a18\u8ff0\u3057\u3066\u304f\u3060\u3055\u3044\u3002 variable_passings:\u3010\u5909\u6570\u3092\u4ecb\u3057\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u6e21\u3057\u3011 - callback_name_write : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 callback_name_read : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 \u5168\u3066\u306e\u77e2\u5370\u304c\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304b\u3089\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002 inherit_unique_stamp # \u8a18\u8ff0\u4f8b # \u91cd\u8981\u306a\u9805\u76ee\u306e\u307f\u3092\u629c\u7c8b\u3057\u305f\u8a18\u8ff0\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 - node_name : /ping_node callbacks : - callback_name : subscription_callback_0 \u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 - callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 publishes : - topic_name : /ping\u3010/ping_node\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0\u3010* /ping\u30c8\u30d4\u30c3\u30af\u3092publish\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 subscribes : - topic_name : /pong\u3010/ping_node\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : subscription_callback_0\u3010subscribe\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 message_contexts : - context_type : inherit_unique_stamp\u3010*\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u30dd\u30ea\u30b7\u30fc\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 use_latest_message # \u8a18\u8ff0\u4f8b # \u91cd\u8981\u306a\u9805\u76ee\u306e\u307f\u3092\u629c\u7c8b\u3057\u305f\u8a18\u8ff0\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 - node_name : /ping_node callbacks : - callback_name : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 - callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 publishes : - topic_name : /ping\u3010/ping_node\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0\u3010* /ping\u30c8\u30d4\u30c3\u30af\u3092publish\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 subscribes : - topic_name : /pong\u3010/ping_node\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : subscription_callback_0\u3010subscribe\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 message_contexts : - context_type : inherit_unique_stamp\u3010*\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u30dd\u30ea\u30b7\u30fc\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306e\u6307\u5b9a"},{"location":"configuration/how_to_write_architecture/#_1","text":"","title":"\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u4f5c\u6210\u65b9\u6cd5"},{"location":"configuration/how_to_write_architecture/#_2","text":"path . verify () WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 check_procedure ( 'yaml' , './architecture.yaml' , arch , '/message_driven_node' ) [callback_chain] [callback_chain] Path Added: subscribe: /drive, publish: None, callbacks: ('/message_driven_node/callback_1',) Path Added: subscribe: /drive, publish: None, callbacks: ('/message_driven_node/callback_1',) Path Added: subscribe: /topic2, publish: None, callbacks: ('/message_driven_node/callback_0',) Path Added: subscribe: /topic2, publish: None, callbacks: ('/message_driven_node/callback_0',) [pub-sub pair] [pub-sub pair] Path Added: subscribe: /drive, publish: /topic3, Path Added: subscribe: /drive, publish: /topic3, Path Added: subscribe: /topic2, publish: /topic3, Path Added: subscribe: /topic2, publish: /topic3, [dummy paths] [dummy paths] Path Added: subscribe: None, publish: /topic3, Path Added: subscribe: None, publish: /topic3, message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/drive', 'publisher_topic_name': '/topic3'} message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/drive', 'publisher_topic_name': '/topic3'} message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/topic2', 'publisher_topic_name': '/topic3'} message context is UNDEFINED. {'context_type': 'UNDEFINED', 'subscription_topic_name': '/topic2', 'publisher_topic_name': '/topic3'} 5 paths found in /message_driven_node. 5 paths found in /message_driven_node. ----- [message context assigned] ----- [message context assigned] subscribe: /drive, publish: None, message_context: None subscribe: /drive, publish: None, message_context: None subscribe: /topic2, publish: None, message_context: None subscribe: /topic2, publish: None, message_context: None subscribe: /drive, publish: /topic3, message_context: None subscribe: /drive, publish: /topic3, message_context: None subscribe: /topic2, publish: /topic3, message_context: None subscribe: /topic2, publish: /topic3, message_context: None subscribe: None, publish: /topic3, message_context: None subscribe: None, publish: /topic3, message_context: None \u4eca\u56de\u306e\u5834\u5408\u306f\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002","title":"\u30d1\u30b9\u306e\u5b9a\u7fa9\u306e\u78ba\u8a8d\u65b9\u6cd5"},{"location":"configuration/how_to_write_architecture/#_3","text":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u3001\u300c\u30ce\u30fc\u30c9\u304c\u30e1\u30c3\u30bb\u30fc\u30b8\u3092 subscribe \u3057\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u51e6\u7406\u958b\u59cb\u3059\u308b\u6642\u523b\u300d\u304b\u3089\u300c\u30ce\u30fc\u30c9\u304c\u30e1\u30c3\u30bb\u30fc\u30b8\u3092 publish \u3059\u308b\u6642\u523b\u300d\u307e\u3067\u3068\u3057\u3066\u3044\u307e\u3059\u3002 \u305f\u3060\u3057\u3001\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u30ce\u30fc\u30c9\u306e\u5b9f\u88c5\u306b\u3082\u5927\u304d\u304f\u4f9d\u5b58\u3057\u3001\u7d71\u4e00\u7684\u306a\u624b\u6cd5\u3067\u306e\u6e2c\u5b9a\u306f\u56f0\u96e3\u3067\u3059\u3002 CARET \u3067\u306f\u3044\u304f\u3064\u304b\u306e\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u3092\u63d0\u4f9b\u3057\u3066\u3044\u307e\u3059\u3002 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306f\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3067\u306f\u3001\u4e3b\u306b message_context \u3068\u3044\u3046\u9805\u76ee\u3068\u3057\u3066\u6307\u5b9a\u3057\u307e\u3059\u3002 message_context \u3068\u3057\u3066\u3001\u4ee5\u4e0b\u306e\u30dd\u30ea\u30b7\u30fc\u304c\u6307\u5b9a\u53ef\u80fd\u3067\u3059\u3002 callback_chain inherit_unique_stamp use_latest_message \u305d\u308c\u305e\u308c\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u304c\u7570\u306a\u308a\u3001\u6e2c\u5b9a\u3067\u304d\u308b\u7c92\u5ea6\u306e\u9055\u3044\u3084\u3001\u6e2c\u5b9a\u3067\u304d\u308b\u30b1\u30fc\u30b9\u30fb\u3067\u304d\u306a\u3044\u30b1\u30fc\u30b9\u304c\u7570\u306a\u308a\u307e\u3059\u3002 \u5f93\u3063\u3066\u3001\u30ce\u30fc\u30c9\u306e\u5b9f\u88c5\u3092\u78ba\u8a8d\u3057\u3001\u3069\u306e\u30dd\u30ea\u30b7\u30fc\u3067\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3055\u305b\u308b\u304b\u3001\u3092\u4f7f\u3044\u5206\u3051\u308b\u5fc5\u8981\u304c\u6709\u308a\u307e\u3059\u3002 \u305d\u308c\u305e\u308c\u306e\u8a73\u7d30\u306b\u3064\u3044\u3066\u306f \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306b\u3064\u3044\u3066 \u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \u672c\u7bc0\u3067\u306f\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u8a18\u8ff0\u65b9\u6cd5\u3092\u3092\u8aac\u660e\u3057\u307e\u3059\u3002","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u65b9\u6cd5\u306e\u6307\u5b9a"},{"location":"configuration/how_to_write_architecture/#callback_chain","text":"callback_chain \u306f\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5b9f\u884c\u9593\u304b\u3089\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3059\u308b\u65b9\u6cd5\u3067\u3059\u3002 \u30ce\u30fc\u30c9\u306e\u5185\u306e\u51e6\u7406\u3092\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30ec\u30d9\u30eb\u307e\u3067\u5206\u89e3\u3059\u308b\u306e\u3067\u3001\u7d30\u304b\u3044\u7c92\u5ea6\u3067\u6e2c\u5b9a\u304c\u53ef\u80fd\u3067\u3059\u3002","title":"callback_chain"},{"location":"configuration/how_to_write_architecture/#_4","text":"\u91cd\u8981\u306a\u9805\u76ee\u306e\u307f\u3092\u629c\u7c8b\u3057\u305f\u8a18\u8ff0\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 *\u306e\u4ed8\u3044\u305f\u9805\u76ee\u306f\u3001\u6e2c\u5b9a\u5bfe\u8c61\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5b9f\u88c5\u3092\u78ba\u8a8d\u306e\u4e0a\u3001\u624b\u4f5c\u696d\u3067\u306e\u4fee\u6b63\u304c\u5fc5\u8981\u306a\u9805\u76ee\u3067\u3059\u3002 - node_name : /ping_node callbacks : - callback_name : subscription_callback_0 - callback_name : timer_callback_0 variable_passings : - callback_name_write : subscription_callback_0 \u3010* \u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u30e1\u30f3\u30d0\u306b\u66f8\u304d\u8fbc\u3080\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 callback_name_read : timer_callback_0 \u3010*\u30e1\u30f3\u30d0\u304b\u3089\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u8aad\u307f\u8fbc\u3080\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 publishes : - topic_name : /ping\u3010/ping_node\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0 \u3010* /ping\u30c8\u30d4\u30c3\u30af\u3092publish\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 subscribes : - topic_name : /pong\u3010/ping_node\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : timer_callback_0\u3010subscribe\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 message_contexts : - context_type : callback_chain \u3010*\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u30dd\u30ea\u30b7\u30fc\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_chain \u30dd\u30ea\u30b7\u30fc\u3067\u306f\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\u3059\u308b\u305f\u3081\u306e\u60c5\u5831\u3068\u3057\u3066\u3001 variable_passings \u3092\u6307\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002","title":"\u8a18\u8ff0\u4f8b"},{"location":"configuration/how_to_write_architecture/#_5","text":"\u4f5c\u6210\u3057\u305f\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3092\u5143\u306b\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3092\u53ef\u8996\u5316\u3067\u304d\u307e\u3059\u3002 \u3053\u3053\u3067\u306f\u3001 CUI \u306b\u3088\u308b\u53ef\u8996\u5316\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 cd ~/ros2_ws/evaluate ros2 caret callback_graph -a ./architecture.yaml -o calback_graph.svg \u30b0\u30e9\u30d5\u306e\u4f5c\u6210\u306b\u306f Graphviz \u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002 \u4f7f\u7528\u53ef\u80fd\u306a\u62e1\u5f35\u5b50\u306b\u3064\u3044\u3066\u306f Graphviz|Output Formats \u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002 \u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002 \u7070\u8272\u306f\u540d\u524d\u7a7a\u9593\u3001\u89d2\u4e38\u56db\u89d2\u306f\u30ce\u30fc\u30c9\u3001\u56db\u89d2\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3001\u77e2\u5370\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u4f9d\u5b58\u95a2\u4fc2\u3092\u793a\u3057\u3066\u3044\u307e\u3059\u3002 \u8d64\u77e2\u5370\u306f\u30c8\u30d4\u30c3\u30af\u3092 publish \u3057\u3066\u3044\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u4e0d\u660e\u306a\u30c8\u30d4\u30c3\u30af\u901a\u4fe1\u3092\u793a\u3057\u3066\u3044\u307e\u3059\u3002 \u3053\u306e\u8d64\u77e2\u5370\u304c\u3001\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3092\u7de8\u96c6\u3057\u3001publish \u5143\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3092\u6307\u5b9a\u3059\u308b\u5fc5\u8981\u306e\u3042\u308b\u7b87\u6240\u3067\u3059\u3002 \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u578b\u306f svg \u5f62\u5f0f\u3067\u3001 tooltip \u306b\u3088\u308b\u60c5\u5831\u306e\u8868\u793a\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\u3002 \u30ab\u30fc\u30bd\u30eb\u3092\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306b\u5408\u308f\u305b\u308b\u3053\u3068\u3067\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u30b7\u30f3\u30dc\u30eb\u540d\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002","title":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306e\u53ef\u8996\u5316"},{"location":"configuration/how_to_write_architecture/#_6","text":"\u51fa\u529b\u76f4\u5f8c\u306e\u96db\u5f62\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u4f9d\u5b58\u95a2\u4fc2\u306a\u3069\u304c\u8a18\u8ff0\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002 caret \u306f\u30d1\u30b9\u306e\u63a2\u7d22\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3092\u5229\u7528\u3059\u308b\u306e\u3067\u3001\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u4fee\u6b63\u304c\u5fc5\u8981\u306b\u306a\u308a\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u69cb\u7bc9\u306e\u305f\u3081\u306b\u4fee\u6b63\u3059\u308b\u9805\u76ee\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u3068 publish \u306e\u7d10\u4ed8\u3051\uff08\u4e0a\u56f3\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306e\u8d64\u77e2\u5370\uff09 [/nodes/node/publish] \u306b\u306f\u3001\u30ce\u30fc\u30c9\u304c publish \u3057\u3066\u3044\u308b\u30c8\u30d4\u30c3\u30af\u540d\u304c key \u3068\u3057\u3066\u5217\u6319\u3055\u308c\u3066\u3044\u307e\u3059\u3002 value \u306b\u30c8\u30d4\u30c3\u30af\u3092 publish \u3057\u3066\u3044\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3092\u8a18\u8ff0\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \u672a\u63a5\u7d9a\u306e\u30c8\u30d4\u30c3\u30af\u901a\u4fe1\uff08\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u4e0a\u306e\u8d64\u77e2\u5370\uff09\u304c\u7121\u304f\u306a\u308b\u307e\u3067\u4fee\u6b63\u3057\u3066\u304f\u3060\u3055\u3044\u3002 publishes:\u3010\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u306e\u60c5\u5831\u3011 - topic_name : /topic4\u3010\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u5909\u6570\u6e21\u3057\u306e\u8a18\u8ff0 [/nodes/node/variable_passing]\u306b\u306f\u3001\u5909\u6570\u6e21\u3057\u306b\u3088\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u4f9d\u5b58\u95a2\u4fc2\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002 callback_write \u306b\u306f\u66f8\u304d\u8fbc\u307f\u5074\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3001callback_read \u306b\u306f\u8aad\u307f\u8fbc\u307f\u5074\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3092\u8a18\u8ff0\u3057\u3066\u304f\u3060\u3055\u3044\u3002 variable_passings:\u3010\u5909\u6570\u3092\u4ecb\u3057\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u6e21\u3057\u3011 - callback_name_write : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 callback_name_read : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d*\u3011 \u5168\u3066\u306e\u77e2\u5370\u304c\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304b\u3089\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002","title":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u60c5\u5831\u306e\u8a18\u8ff0"},{"location":"configuration/how_to_write_architecture/#inherit_unique_stamp","text":"","title":"inherit_unique_stamp"},{"location":"configuration/how_to_write_architecture/#_7","text":"\u91cd\u8981\u306a\u9805\u76ee\u306e\u307f\u3092\u629c\u7c8b\u3057\u305f\u8a18\u8ff0\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 - node_name : /ping_node callbacks : - callback_name : subscription_callback_0 \u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 - callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 publishes : - topic_name : /ping\u3010/ping_node\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0\u3010* /ping\u30c8\u30d4\u30c3\u30af\u3092publish\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 subscribes : - topic_name : /pong\u3010/ping_node\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : subscription_callback_0\u3010subscribe\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 message_contexts : - context_type : inherit_unique_stamp\u3010*\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u30dd\u30ea\u30b7\u30fc\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011","title":"\u8a18\u8ff0\u4f8b"},{"location":"configuration/how_to_write_architecture/#use_latest_message","text":"","title":"use_latest_message"},{"location":"configuration/how_to_write_architecture/#_8","text":"\u91cd\u8981\u306a\u9805\u76ee\u306e\u307f\u3092\u629c\u7c8b\u3057\u305f\u8a18\u8ff0\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 - node_name : /ping_node callbacks : - callback_name : subscription_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 - callback_name : timer_callback_0\u3010\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 publishes : - topic_name : /ping\u3010/ping_node\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_names : - timer_callback_0\u3010* /ping\u30c8\u30d4\u30c3\u30af\u3092publish\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u540d\u3011 subscribes : - topic_name : /pong\u3010/ping_node\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 callback_name : subscription_callback_0\u3010subscribe\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3011 message_contexts : - context_type : inherit_unique_stamp\u3010*\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u30dd\u30ea\u30b7\u30fc\u3011 subscription_topic_name : /pong\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304csubscribe\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011 publisher_topic_name : /ping\u3010\u30ce\u30fc\u30c9\u306e\u30d1\u30b9\u304cpublish\u3059\u308b\u30c8\u30d4\u30c3\u30af\u540d\u3011","title":"\u8a18\u8ff0\u4f8b"},{"location":"design/about_callback_graph/","text":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066 # ROS \u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u4e00\u822c\u7684\u306b\u30ce\u30fc\u30c9\u306e\u30b0\u30e9\u30d5\u3067\u8a18\u8ff0\u3055\u308c\u3001\u305d\u308c\u306b\u4f34\u3044\u30ce\u30fc\u30c9\u5358\u4f4d\u306e\u30ec\u30a4\u30c6\u30f3\u30b7\uff08\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\uff09\u3092\u628a\u63e1\u3057\u305f\u3044\u30b1\u30fc\u30b9\u304c\u751f\u3058\u307e\u3059\u3002 \u3057\u304b\u3057\u306a\u304c\u3089\u3001\u4e00\u3064\u306e\u30ce\u30fc\u30c9\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u8907\u6570\u5b58\u5728\u3059\u308b\u30b1\u30fc\u30b9\u3067\u306f\u3001\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u8003\u3048\u305f\u969b\u306b\u4e0d\u90fd\u5408\u304c\u751f\u3058\u307e\u3059\u3002 \u4e0a\u56f3\u306f\u3001 /lidar \u3068 /camera \u30c8\u30d4\u30c3\u30af\u3092\u30b5\u30d6\u30b9\u30af\u30e9\u30a4\u30d6\u3057\u3001\u305d\u306e\uff12\u3064\u306e\u60c5\u5831\u3092\u7d71\u5408\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092 /fusion \u306b\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u3059\u308b TargetNode \u3092\u4f8b\u3068\u3057\u3066\u793a\u3057\u3066\u3044\u307e\u3059\u3002 /lidar \u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3067\u306f\u3001\u30e1\u30f3\u30d0\u5909\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u683c\u7d0d\u3057\u3001/camera \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u5185\u3067\u7d71\u5408\u3055\u305b\u3066\u3044\u307e\u3059\u3002 \u203b CARET \u3067\u306f \u3001\u5909\u6570\u3092\u7d4c\u7531\u3057\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u6e21\u3057\u3092 Variable Passing \u3068\u547c\u3073\u3001\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3078\u8a18\u8ff0\u3055\u305b\u3066\u3044\u307e\u3059\u3002 \u3053\u306e\u6642\u3001 TargetNode \u306e\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u6b21\u306e\uff12\u3064\u304c\u8003\u3048\u3089\u308c\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af C \u2192 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af D\uff08/lidar \u30c8\u30d4\u30c3\u30af \u2192 /fusion \u30c8\u30d4\u30c3\u30af\u306e\u30d1\u30b9\uff09 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af D\uff08/camera \u30c8\u30d4\u30c3\u30af \u2192 /fusion \u30c8\u30d4\u30c3\u30af\u306e\u30d1\u30b9\uff09 \u3053\u306e\u3088\u3046\u306a\u4e00\u3064\u306e\u30ce\u30fc\u30c9\u306b\u8907\u6570\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u5b58\u5728\u30b1\u30fc\u30b9\u3067\u306f\u3001\u6307\u5b9a\u3059\u308b\u30d1\u30b9\u6bce\u306b\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u69cb\u6210\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u7570\u306a\u308a\u307e\u3059\u3002 \u305d\u306e\u305f\u3081\u3001 CARET \u3067\u306f ROS \u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3068\u3057\u3066\u8a18\u8ff0\u3057\u3066\u3044\u307e\u3059\u3002 \u30ce\u30fc\u30c9\u30fb\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u6574\u7406 A node is an executable that uses ROS to communicate with other nodes. ( http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes \u3088\u308a\u5f15\u7528) \u3068\u8a00\u308f\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u3001\u30ce\u30fc\u30c9\u306f\u5b9f\u884c\u53ef\u80fd\u306a\u5358\u4f4d\u3067\u3059\u3002 \u4e00\u65b9\u3067\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306f\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u3055\u308c\u308b\u30bf\u30b9\u30af\u306e\u5358\u4f4d\u3068\u3057\u3066\u6349\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 \u7279\u306b ROS 2 \u306e\u5834\u5408\u3001SingleThreadedExecutor \u3092\u59cb\u3081\u3068\u3059\u308b\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u304c\u8907\u6570\u5b58\u5728\u3057\u3001 \u30b9\u30ec\u30c3\u30c9\u6570\u306e\u9055\u3044\u3060\u3051\u3067\u306a\u304f\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5b9f\u884c\u9806\u5e8f\u304c\u7570\u306a\u308a\u307e\u3059\u3002 \u6027\u80fd\u3092\u8a55\u4fa1\u3059\u308b\u4e0a\u3067\u306f\u3001\u4f55\u306e\u30ce\u30fc\u30c9\u304c\u4f55\u306e\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u3067\u5b9f\u884c\u3055\u308c\u3066\u3044\u305f\u304b\u3082\u91cd\u8981\u306a\u89b3\u70b9\u3067\u3059\u3002","title":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066"},{"location":"design/about_callback_graph/#_1","text":"ROS \u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u4e00\u822c\u7684\u306b\u30ce\u30fc\u30c9\u306e\u30b0\u30e9\u30d5\u3067\u8a18\u8ff0\u3055\u308c\u3001\u305d\u308c\u306b\u4f34\u3044\u30ce\u30fc\u30c9\u5358\u4f4d\u306e\u30ec\u30a4\u30c6\u30f3\u30b7\uff08\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\uff09\u3092\u628a\u63e1\u3057\u305f\u3044\u30b1\u30fc\u30b9\u304c\u751f\u3058\u307e\u3059\u3002 \u3057\u304b\u3057\u306a\u304c\u3089\u3001\u4e00\u3064\u306e\u30ce\u30fc\u30c9\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u8907\u6570\u5b58\u5728\u3059\u308b\u30b1\u30fc\u30b9\u3067\u306f\u3001\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u8003\u3048\u305f\u969b\u306b\u4e0d\u90fd\u5408\u304c\u751f\u3058\u307e\u3059\u3002 \u4e0a\u56f3\u306f\u3001 /lidar \u3068 /camera \u30c8\u30d4\u30c3\u30af\u3092\u30b5\u30d6\u30b9\u30af\u30e9\u30a4\u30d6\u3057\u3001\u305d\u306e\uff12\u3064\u306e\u60c5\u5831\u3092\u7d71\u5408\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092 /fusion \u306b\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u3059\u308b TargetNode \u3092\u4f8b\u3068\u3057\u3066\u793a\u3057\u3066\u3044\u307e\u3059\u3002 /lidar \u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3067\u306f\u3001\u30e1\u30f3\u30d0\u5909\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u683c\u7d0d\u3057\u3001/camera \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u5185\u3067\u7d71\u5408\u3055\u305b\u3066\u3044\u307e\u3059\u3002 \u203b CARET \u3067\u306f \u3001\u5909\u6570\u3092\u7d4c\u7531\u3057\u305f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u6e21\u3057\u3092 Variable Passing \u3068\u547c\u3073\u3001\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u3078\u8a18\u8ff0\u3055\u305b\u3066\u3044\u307e\u3059\u3002 \u3053\u306e\u6642\u3001 TargetNode \u306e\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u6b21\u306e\uff12\u3064\u304c\u8003\u3048\u3089\u308c\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af C \u2192 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af D\uff08/lidar \u30c8\u30d4\u30c3\u30af \u2192 /fusion \u30c8\u30d4\u30c3\u30af\u306e\u30d1\u30b9\uff09 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af D\uff08/camera \u30c8\u30d4\u30c3\u30af \u2192 /fusion \u30c8\u30d4\u30c3\u30af\u306e\u30d1\u30b9\uff09 \u3053\u306e\u3088\u3046\u306a\u4e00\u3064\u306e\u30ce\u30fc\u30c9\u306b\u8907\u6570\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u5b58\u5728\u30b1\u30fc\u30b9\u3067\u306f\u3001\u6307\u5b9a\u3059\u308b\u30d1\u30b9\u6bce\u306b\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u69cb\u6210\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u7570\u306a\u308a\u307e\u3059\u3002 \u305d\u306e\u305f\u3081\u3001 CARET \u3067\u306f ROS \u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u3068\u3057\u3066\u8a18\u8ff0\u3057\u3066\u3044\u307e\u3059\u3002 \u30ce\u30fc\u30c9\u30fb\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u6574\u7406 A node is an executable that uses ROS to communicate with other nodes. ( http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes \u3088\u308a\u5f15\u7528) \u3068\u8a00\u308f\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u3001\u30ce\u30fc\u30c9\u306f\u5b9f\u884c\u53ef\u80fd\u306a\u5358\u4f4d\u3067\u3059\u3002 \u4e00\u65b9\u3067\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306f\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u3055\u308c\u308b\u30bf\u30b9\u30af\u306e\u5358\u4f4d\u3068\u3057\u3066\u6349\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 \u7279\u306b ROS 2 \u306e\u5834\u5408\u3001SingleThreadedExecutor \u3092\u59cb\u3081\u3068\u3059\u308b\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u304c\u8907\u6570\u5b58\u5728\u3057\u3001 \u30b9\u30ec\u30c3\u30c9\u6570\u306e\u9055\u3044\u3060\u3051\u3067\u306a\u304f\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5b9f\u884c\u9806\u5e8f\u304c\u7570\u306a\u308a\u307e\u3059\u3002 \u6027\u80fd\u3092\u8a55\u4fa1\u3059\u308b\u4e0a\u3067\u306f\u3001\u4f55\u306e\u30ce\u30fc\u30c9\u304c\u4f55\u306e\u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u3067\u5b9f\u884c\u3055\u308c\u3066\u3044\u305f\u304b\u3082\u91cd\u8981\u306a\u89b3\u70b9\u3067\u3059\u3002","title":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066"},{"location":"design/architecture_overview/","text":"Architecture overview # This section explains an overview of software architecture of CARET. CARET collects data, which include timestamps, from tracepoints embedded in user application, ROS 2 and DDS. The data set is stored into a storage as \"Trace Data\". A set of trace data is divided into two sections by CARET_analyze package after loading trace data; Architecture and Runtime Data. Architecture object includes description of target application's structure. This object can be reused unless structure of the target application or name of the components is changed. Runtime Data object has data sampled during execution of the target application. The sampled data includes timestamps, whose value are different per execution, obtained from tracepoints. Architecture object and Runtime Data object are implemented as Python-based classes. The structure of their classes are designed based on the structure of ROS applications which are constructed of executors, nodes, callback functions, and topic messages. ROS-based structure makes CARET's API friendly for ROS users. They are able to find target nodes, topic messages, or executors if they know their application structure. Architecture object serves APIs to search node chains and define node latency as mentioned in tutorial/architecture file section . Architecture object is reusable after it is saved as a YAML-based file called \"architecture file\". Runtime Data object serves APIs to retrieve pandas.DataFrame -based objects including callback latency or communication. Users can analyze temporal aspects of their applications, with visualization, as they expect. APIs for visualization are also served by CARET_analyze which plays main role to analyze trace data. Cooperation with TILDE, a framework tools to detect deadline overrun # CARET can cooperate with TILDE, a framework tool to detect deadline overrun. TILDE lets CARET trace events in user applications which cannot be traced from ROS/DDS layer. One example of the events is consumption of message buffered in nodes. The events can be observed in only application layer, but CARET cannot observe the events. On the other hand, TILDE can trace application-layer events. It is able to trace execution of callback function to consume a certain buffered message since it annotate message consumption per single message. TILDE serves CARET this capability to trace consumption of buffered message. Todo TILDE is now under development. Please wait for more details.","title":"Architecture overview"},{"location":"design/architecture_overview/#architecture-overview","text":"This section explains an overview of software architecture of CARET. CARET collects data, which include timestamps, from tracepoints embedded in user application, ROS 2 and DDS. The data set is stored into a storage as \"Trace Data\". A set of trace data is divided into two sections by CARET_analyze package after loading trace data; Architecture and Runtime Data. Architecture object includes description of target application's structure. This object can be reused unless structure of the target application or name of the components is changed. Runtime Data object has data sampled during execution of the target application. The sampled data includes timestamps, whose value are different per execution, obtained from tracepoints. Architecture object and Runtime Data object are implemented as Python-based classes. The structure of their classes are designed based on the structure of ROS applications which are constructed of executors, nodes, callback functions, and topic messages. ROS-based structure makes CARET's API friendly for ROS users. They are able to find target nodes, topic messages, or executors if they know their application structure. Architecture object serves APIs to search node chains and define node latency as mentioned in tutorial/architecture file section . Architecture object is reusable after it is saved as a YAML-based file called \"architecture file\". Runtime Data object serves APIs to retrieve pandas.DataFrame -based objects including callback latency or communication. Users can analyze temporal aspects of their applications, with visualization, as they expect. APIs for visualization are also served by CARET_analyze which plays main role to analyze trace data.","title":"Architecture overview"},{"location":"design/architecture_overview/#cooperation-with-tilde-a-framework-tools-to-detect-deadline-overrun","text":"CARET can cooperate with TILDE, a framework tool to detect deadline overrun. TILDE lets CARET trace events in user applications which cannot be traced from ROS/DDS layer. One example of the events is consumption of message buffered in nodes. The events can be observed in only application layer, but CARET cannot observe the events. On the other hand, TILDE can trace application-layer events. It is able to trace execution of callback function to consume a certain buffered message since it annotate message consumption per single message. TILDE serves CARET this capability to trace consumption of buffered message. Todo TILDE is now under development. Please wait for more details.","title":"Cooperation with TILDE, a framework tools to detect deadline overrun"},{"location":"design/communication_latency_definition/","text":"\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # CARET \u3067\u7b97\u51fa\u3055\u308c\u308b\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306b\u3064\u3044\u3066\u8a73\u7d30\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 \u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # \u901a\u4fe1\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # CARET \u304c\u7b97\u51fa\u3057\u3066\u3044\u308b\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002 Pub-Sub \u30ec\u30a4\u30c6\u30f3\u30b7 = Subscription\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5b9f\u884c\u958b\u59cb\u6642\u523b - Publisher::publish()\u5b9f\u884c\u958b\u59cb\u6642\u523b \u3053\u306e\u5024\u306f\u3001ros2 topic delay \u3084\u3001topic statistics \u3067\u6e2c\u5b9a\u3055\u308c\u308b\u5024\u306b\u5bfe\u5fdc\u3057\u307e\u3059\u3002 \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7 = \u73fe\u5728\u6642\u523b - msg.header.stamp \u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u306e\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u306b\u3064\u3044\u3066\u306f\u3001\u3053\u3061\u3089\u306e\u8ad6\u6587\u3082\u53c2\u7167\u304f\u3060\u3055\u3044\u3002 Response-Time Analysis of ROS 2 Processing Chains Under Reservation-Based Scheduling","title":"\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/communication_latency_definition/#_1","text":"CARET \u3067\u7b97\u51fa\u3055\u308c\u308b\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306b\u3064\u3044\u3066\u8a73\u7d30\u3092\u8aac\u660e\u3057\u307e\u3059\u3002","title":"\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/communication_latency_definition/#_2","text":"","title":"\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/communication_latency_definition/#_3","text":"CARET \u304c\u7b97\u51fa\u3057\u3066\u3044\u308b\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002 Pub-Sub \u30ec\u30a4\u30c6\u30f3\u30b7 = Subscription\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u5b9f\u884c\u958b\u59cb\u6642\u523b - Publisher::publish()\u5b9f\u884c\u958b\u59cb\u6642\u523b \u3053\u306e\u5024\u306f\u3001ros2 topic delay \u3084\u3001topic statistics \u3067\u6e2c\u5b9a\u3055\u308c\u308b\u5024\u306b\u5bfe\u5fdc\u3057\u307e\u3059\u3002 \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7 = \u73fe\u5728\u6642\u523b - msg.header.stamp \u30a8\u30b0\u30bc\u30ad\u30e5\u30fc\u30bf\u306e\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u306b\u3064\u3044\u3066\u306f\u3001\u3053\u3061\u3089\u306e\u8ad6\u6587\u3082\u53c2\u7167\u304f\u3060\u3055\u3044\u3002 Response-Time Analysis of ROS 2 Processing Chains Under Reservation-Based Scheduling","title":"\u901a\u4fe1\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/diff/","text":"ROS 2 galactic \u3068\u306e\u5dee\u5206 # caret.repos \u306b\u306f caret \u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u4ed6\u306b\u3001\u4ee5\u4e0b\u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002 https://github.com/ros2/rcl.git https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added https://github.com/eclipse-cyclonedds/cyclonedds.git \u305d\u308c\u305e\u308c\u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u5dee\u5206\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002 rcl # \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306a\u3057\u3002 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3092\u6709\u52b9\u306b\u3059\u308b\u305f\u3081\u306e\u518d\u30d3\u30eb\u30c9\u3002 rclcpp # \u30ea\u30dd\u30b8\u30c8\u30ea\uff1a https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added \u8ffd\u52a0\u3057\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306b\u3064\u3044\u3066\u306f\u3001 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u5b9a\u7fa9 \u306e [CARET \u30d5\u30a9\u30fc\u30af\u5b9f\u88c5] \u3068\u306a\u308a\u307e\u3059\u3002 rclcpp \u5b9f\u88c5\u306e\u7406\u7531 \u4e0a\u8a18\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u5b9f\u88c5\u3055\u308c\u305f\u95a2\u6570\u5185\u306b\u633f\u5165\u3057\u3066\u3044\u307e\u3059\u3002 \u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u5b9f\u88c5\u306f\u30d8\u30c3\u30c0\u30fc\u306b\u542b\u307e\u308c\u3001\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d0\u30a4\u30ca\u30ea\u5185\u306b\u751f\u6210\u3055\u308c\u307e\u3059 LD_PRELOAD \u3067\u306e\u30d5\u30c3\u30af\u304c\u4e0d\u53ef\u80fd\u306a\u6e2c\u5b9a\u7b87\u6240\u306a\u305f\u3081\u3001 rclcpp \u306b\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002 \u307e\u305f\u3001\u30d3\u30eb\u30c9\u3092\u901a\u3059\u305f\u3081\u306b ros2_tracing \u306e include \u30d5\u30a1\u30a4\u30eb\u3092\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002 rclcpp \u306b ros2_tracing \u306e include \u30d5\u30a1\u30a4\u30eb\u3092\u8ffd\u52a0\u3057\u305f\u7406\u7531 LD_PRELOAD \u3067\u306f\u5b9f\u884c\u958b\u59cb\u76f4\u5f8c\u306b\u30ab\u30b9\u30bf\u30e0\u306e\u5171\u6709\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u512a\u5148\u3057\u3066\u8aad\u307f\u8fbc\u307e\u305b\u308b\u3053\u3068\u304c\u53ef\u80fd\u306b\u306a\u308a\u307e\u3059\u3002 \u4e00\u65b9\u3067\u3001\u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d8\u30c3\u30c0\u30fc\u306b\u8ffd\u52a0\u3055\u308c\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306b\u306f\u3001\u30d3\u30eb\u30c9\u6642\u306e\u30d8\u30c3\u30c0\u30fc\u63a2\u7d22\u306b\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248\u30d8\u30c3\u30c0\u30fc\u304c\u512a\u5148\u3057\u3066\u8aad\u307f\u8fbc\u307e\u308c\u308b\u5fc5\u8981\u3042\u308a\u307e\u3059\u3002 gcc \u306e -I \u30d5\u30e9\u30b0\u3084 CPATH \u306a\u3069\u3092\u691c\u8a0e\u3057\u307e\u3057\u305f\u304c\u3001\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248 rclcpp/include, /opt/ros/galactic/include \uff08ros2_tracing \u542b\u3080\uff09,\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248 tracetools/include \u306e\u9806\u3068\u306a\u308a\u3001\u8ffd\u52a0\u3057\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u672a\u5b9a\u7fa9\u306e\u30a8\u30e9\u30fc\u3067\u30d3\u30eb\u30c9\u304c\u901a\u305b\u307e\u305b\u3093\u3002 \u305d\u306e\u305f\u3081\u3001 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248 tracetools/include \u306b\u8ffd\u52a0\u3055\u308c\u3066\u3044\u306a\u3044\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306f\u3001\u4e00\u6642\u7684\u306b rclcpp/include \u914d\u4e0b\u306b\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002 ros2 \u672c\u5bb6\u3078\u306e\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u30de\u30fc\u30b8\u3092\u691c\u8a0e\u3057\u3066\u3044\u304f\u969b\u306b\u306f\u3001rclcpp \u3078\u306e ros2_tracing \u306e include \u30d5\u30a1\u30a4\u30eb\u8ffd\u52a0\u306f\u5fc5\u8981\u3042\u308a\u307e\u305b\u3093\u3002 ros2_tracing # rclcpp \u3067\u8ffd\u52a0\u3057\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u5b9a\u7fa9\u3092\u8ffd\u52a0 \u30ea\u30dd\u30b8\u30c8\u30ea\uff1a https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added \u30d5\u30c3\u30af\u3067\u306f\u306a\u304f\u3001rclcpp \u3078\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3092\u8ffd\u52a0\u3057\u305f\u7406\u7531\u306b\u3064\u3044\u3066\u306f\u3001\u300crclcpp \u5b9f\u88c5\u306e\u7406\u7531\u300d\u3092\u53c2\u7167\u3002 cyclonedds # \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306a\u3057\u3002 DDS \u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u306e\u305f\u3081\u306e\u8a66\u9a13\u5c0e\u5165","title":"galactic\u3068\u306e\u5dee\u5206(staled)"},{"location":"design/diff/#ros-2-galactic","text":"caret.repos \u306b\u306f caret \u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u4ed6\u306b\u3001\u4ee5\u4e0b\u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002 https://github.com/ros2/rcl.git https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added https://github.com/eclipse-cyclonedds/cyclonedds.git \u305d\u308c\u305e\u308c\u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u5dee\u5206\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002","title":"ROS 2 galactic \u3068\u306e\u5dee\u5206"},{"location":"design/diff/#rcl","text":"\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306a\u3057\u3002 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3092\u6709\u52b9\u306b\u3059\u308b\u305f\u3081\u306e\u518d\u30d3\u30eb\u30c9\u3002","title":"rcl"},{"location":"design/diff/#rclcpp","text":"\u30ea\u30dd\u30b8\u30c8\u30ea\uff1a https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added \u8ffd\u52a0\u3057\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306b\u3064\u3044\u3066\u306f\u3001 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u5b9a\u7fa9 \u306e [CARET \u30d5\u30a9\u30fc\u30af\u5b9f\u88c5] \u3068\u306a\u308a\u307e\u3059\u3002 rclcpp \u5b9f\u88c5\u306e\u7406\u7531 \u4e0a\u8a18\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u5b9f\u88c5\u3055\u308c\u305f\u95a2\u6570\u5185\u306b\u633f\u5165\u3057\u3066\u3044\u307e\u3059\u3002 \u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u5b9f\u88c5\u306f\u30d8\u30c3\u30c0\u30fc\u306b\u542b\u307e\u308c\u3001\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d0\u30a4\u30ca\u30ea\u5185\u306b\u751f\u6210\u3055\u308c\u307e\u3059 LD_PRELOAD \u3067\u306e\u30d5\u30c3\u30af\u304c\u4e0d\u53ef\u80fd\u306a\u6e2c\u5b9a\u7b87\u6240\u306a\u305f\u3081\u3001 rclcpp \u306b\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002 \u307e\u305f\u3001\u30d3\u30eb\u30c9\u3092\u901a\u3059\u305f\u3081\u306b ros2_tracing \u306e include \u30d5\u30a1\u30a4\u30eb\u3092\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002 rclcpp \u306b ros2_tracing \u306e include \u30d5\u30a1\u30a4\u30eb\u3092\u8ffd\u52a0\u3057\u305f\u7406\u7531 LD_PRELOAD \u3067\u306f\u5b9f\u884c\u958b\u59cb\u76f4\u5f8c\u306b\u30ab\u30b9\u30bf\u30e0\u306e\u5171\u6709\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u512a\u5148\u3057\u3066\u8aad\u307f\u8fbc\u307e\u305b\u308b\u3053\u3068\u304c\u53ef\u80fd\u306b\u306a\u308a\u307e\u3059\u3002 \u4e00\u65b9\u3067\u3001\u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d8\u30c3\u30c0\u30fc\u306b\u8ffd\u52a0\u3055\u308c\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306b\u306f\u3001\u30d3\u30eb\u30c9\u6642\u306e\u30d8\u30c3\u30c0\u30fc\u63a2\u7d22\u306b\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248\u30d8\u30c3\u30c0\u30fc\u304c\u512a\u5148\u3057\u3066\u8aad\u307f\u8fbc\u307e\u308c\u308b\u5fc5\u8981\u3042\u308a\u307e\u3059\u3002 gcc \u306e -I \u30d5\u30e9\u30b0\u3084 CPATH \u306a\u3069\u3092\u691c\u8a0e\u3057\u307e\u3057\u305f\u304c\u3001\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248 rclcpp/include, /opt/ros/galactic/include \uff08ros2_tracing \u542b\u3080\uff09,\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248 tracetools/include \u306e\u9806\u3068\u306a\u308a\u3001\u8ffd\u52a0\u3057\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u672a\u5b9a\u7fa9\u306e\u30a8\u30e9\u30fc\u3067\u30d3\u30eb\u30c9\u304c\u901a\u305b\u307e\u305b\u3093\u3002 \u305d\u306e\u305f\u3081\u3001 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u8ffd\u52a0\u7248 tracetools/include \u306b\u8ffd\u52a0\u3055\u308c\u3066\u3044\u306a\u3044\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306f\u3001\u4e00\u6642\u7684\u306b rclcpp/include \u914d\u4e0b\u306b\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002 ros2 \u672c\u5bb6\u3078\u306e\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u30de\u30fc\u30b8\u3092\u691c\u8a0e\u3057\u3066\u3044\u304f\u969b\u306b\u306f\u3001rclcpp \u3078\u306e ros2_tracing \u306e include \u30d5\u30a1\u30a4\u30eb\u8ffd\u52a0\u306f\u5fc5\u8981\u3042\u308a\u307e\u305b\u3093\u3002","title":"rclcpp"},{"location":"design/diff/#ros2_tracing","text":"rclcpp \u3067\u8ffd\u52a0\u3057\u305f\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u5b9a\u7fa9\u3092\u8ffd\u52a0 \u30ea\u30dd\u30b8\u30c8\u30ea\uff1a https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added \u30d5\u30c3\u30af\u3067\u306f\u306a\u304f\u3001rclcpp \u3078\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3092\u8ffd\u52a0\u3057\u305f\u7406\u7531\u306b\u3064\u3044\u3066\u306f\u3001\u300crclcpp \u5b9f\u88c5\u306e\u7406\u7531\u300d\u3092\u53c2\u7167\u3002","title":"ros2_tracing"},{"location":"design/diff/#cyclonedds","text":"\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u5909\u66f4\u306a\u3057\u3002 DDS \u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u306e\u305f\u3081\u306e\u8a66\u9a13\u5c0e\u5165","title":"cyclonedds"},{"location":"design/how_to_calculate_latency/","text":"\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u8a08\u7b97\u65b9\u6cd5 # \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u3068\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5 # \u4ee5\u4e0b\u306f\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u3068\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u8868\u3057\u305f\u56f3\u3067\u3059\u3002 \u3053\u3053\u3067\u306f\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u3068\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002 \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5 # \u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e publish \u306e\u6642\u523b\u3068\u3001\u5f8c\u7d9a\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u958b\u59cb\u3057\u305f\u6642\u523b\u306e\u5dee\u5206\u3067\u8a08\u7b97\u3057\u3066\u3044\u307e\u3059\u3002 \u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1 # \u6b21\u306e\u8868\u306f\u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u306e\u30c8\u30ec\u30fc\u30b9\u306b\u5fc5\u8981\u306a\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3068\u3001\u305d\u306e\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u5f15\u6570\uff08\u30c8\u30ec\u30fc\u30b9\u30c7\u30fc\u30bf\u3068\u3057\u3066\u51fa\u529b\u3055\u308c\u308b\u3082\u306e\uff09\u3067\u3059\u3002\u203b\u7c21\u6613\u7248 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540d \u5f15\u6570 1 \u5f15\u6570 2 \u6642\u523b rclcpp_intra_publish publisher_handle_arg message_arg time1 dispatch_intra_process_subscription_callback message_arg callback_arg time2 callback_start callback_arg is_intra_process time3 \u203b \u5f15\u6570\u306b\u3064\u3044\u3066\u306f\u3053\u3061\u3089\u3092\u53c2\u7167 message_arg \u3068 callback_arg \u306b\u306f\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u30a2\u30c9\u30ec\u30b9\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u30a2\u30c9\u30ec\u30b9\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002 rclcpp_intra_publisher \u3068 dispatch_intra_process_subscription_callback \u306f\u540c\u3058 message_arg \u3092\u6301\u3064\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540c\u58eb\u3067\u7d10\u3065\u3051\u3001dispatch_intra_process_subscription_callback \u3068 callback_start \u306f\u540c\u3058 callback_arg \u3092\u6301\u3064\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540c\u58eb\u3067\u7d10\u3065\u3051\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u4e0b\u8a18\u306e\u3088\u3046\u306a\u8868\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 \u6700\u5f8c\u306b callback_start - rclcpp_intra_publish \u3067 \u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u306e\u30ec\u30a4\u30c6\u30f3\u30b7 \u3092\u7b97\u51fa\u3057\u3066\u3044\u307e\u3059\u3002 idx rclcpp_intra_publish dispatch_intra_process_subscription_callback callback_start 0 time1 time2 time3 1 ... ... ... \u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1 # \u4ee5\u4e0b\u306f\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306e\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3068\u305d\u306e\u5f15\u6570\u3067\u3059\u3002 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540d \u5f15\u6570 1 \u5f15\u6570 2 \u5f15\u6570 3 \u6642\u523b rclcpp_publish publisher_handle_arg message_arg @1 time1 rcl_publish publisher_handle_arg message_arg @1 time2 dds_write publisher_handle_arg message_arg @1 time3 dds_bind_addr_to_stamp message_arg @1 stamp_arg time4 dispatch_subscription_callback messsage_arg@2 stamp_arg callback_arg time5 callback_start callback_arg is_intra_process time6 \u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u3068\u540c\u69d8\u306b\u540c\u3058\u5f15\u6570\u3092\u6301\u3064\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540c\u58eb\u3092\u7d10\u3065\u3051\u3066\u3044\u304d\u3001publish \u304b\u3089 callback_start \u307e\u3067\u306e\u8868\u3092\u4f5c\u6210\u3057\u307e\u3059\uff08\u4e0b\u8a18\u8868\uff09\u3002 1 \u884c\u304c 1 \u3064\u306e\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306e\u30c1\u30a7\u30fc\u30f3\u3092\u8868\u3057\u3001 callback_start - rclcpp_publish \u306b\u3066 \u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306e\u30ec\u30a4\u30c6\u30f3\u30b7 \u3092\u7b97\u51fa\u3057\u307e\u3059\u3002 idx rclcpp_publish rcl_publish dds_write dds_bind_addr_to_stamp dispatch_subscription_callback callback_start 0 time1 time2 time3 time4 time5 time6 1 ... ... ... ... ... ...\u3000 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5 # \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306f 2 \u3064\u3042\u308a\u307e\u3059\u3002 \u305d\u308c\u305e\u308c\u306e\u624b\u6cd5\u30fb\u9577\u6240\u30fb\u77ed\u6240\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u5229\u7528 # \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u6e2c\u5b9a\u306f\u3001\u540c\u3058\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30a2\u30c9\u30ec\u30b9\u3092\u6301\u3064 callback_start \u3068 rclcpp_publish \u306e\u5dee\u5206\u3092\u4f7f\u3063\u3066\u7b97\u51fa\u3057\u307e\u3059\u3002 callback_start \u3068 rclcpp_publish \u306e\u7d10\u3065\u3051\u306f\u3001rclcpp_publish \u304b\u3089\u898b\u3066\u4e00\u756a\u8fd1\u3044 callback_start \u3068\u7d10\u3065\u3051\u307e\u3059\u3002 idx callback_start (cb_A) [s] rclcpp_publish (cb_A) [s] callback_end (cb_A) [s] callback_arg (cb_A) 0 0 3 4 0x1000 1 2 5 6 0x1000 2 4 7 8 0x1000 ... ... ... ... ... idx callback_start (cb_B) [s] rclcpp_publish (cb_B) [s] callback_end (cb_B) [s] callback_arg (cb_B) 0 4 8 9 0x2000 1 8 12 13 0x2000 2 10 14 15 0x2000 \u4e0a\u8a18\u8868\u306e\u3088\u3046\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af A\u30fbB\uff08cb_A\u30fbcb_B\uff09\u304c\u5b58\u5728\u3057\u3001A\u2192B \u3068\u51e6\u7406\u304c\u7d9a\u304f\u6642\u3001cb_A \u306e callback_end \u3068 cb_B \u306e callback_start \u3092\u7d50\u3073\u4ed8\u3051\u3066\u8868\u3092\u4f5c\u308a\u307e\u3059\u3002 \u6700\u5f8c\u306e callback \u3060\u3051\u306f publish \u306e\u6642\u306e\u6642\u523b\u3092\u63a1\u7528\u3057\u3001\u4e0b\u8a18\u8868\u306e\u3088\u3046\u306b\u4e00\u3064\u306e\u30c6\u30fc\u30d6\u30eb\u306b\u3057\u307e\u3059\u3002 idx callback_start (cb_A) [s] callback_end (cb_A) [s] callback_start (cb_B) [s] rclcpp_publish (cb_B) [s] 0 0 4 4 8 1 2 6 Lost Lost 2 4 8 8 12 ... ... ... ... ... \u4e0a\u8a18\u306e\u3088\u3046\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u3064\u306a\u304e\u3001 rclcpp_publish (cb_X) - callback_start (cb_Y) \u3067 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7 \u3092\u7b97\u51fa\u3057\u307e\u3059\u3002 \u203b\u30ce\u30fc\u30c9\u5185\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\uff11\u3064\u306e\u5834\u5408\u3001X, Y \u306f\u540c\u3058\u3082\u306e\u3092\u6307\u3057\u307e\u3059\u3002 \u8907\u6570\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u3042\u308b\u5834\u5408\u306f\u3001X \u304c\u6700\u5f8c\u30fbY \u304c\u6700\u521d\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3092\u6307\u3057\u307e\u3059\u3002","title":"\u30ec\u30a4\u30c6\u30f3\u30b7\u7b97\u51fa\u65b9\u6cd5"},{"location":"design/how_to_calculate_latency/#_1","text":"","title":"\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u8a08\u7b97\u65b9\u6cd5"},{"location":"design/how_to_calculate_latency/#_2","text":"\u4ee5\u4e0b\u306f\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u3068\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u8868\u3057\u305f\u56f3\u3067\u3059\u3002 \u3053\u3053\u3067\u306f\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u3068\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8aac\u660e\u3057\u307e\u3059\u3002","title":"\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u3068\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5"},{"location":"design/how_to_calculate_latency/#_3","text":"\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e publish \u306e\u6642\u523b\u3068\u3001\u5f8c\u7d9a\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u958b\u59cb\u3057\u305f\u6642\u523b\u306e\u5dee\u5206\u3067\u8a08\u7b97\u3057\u3066\u3044\u307e\u3059\u3002","title":"\u901a\u4fe1\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5"},{"location":"design/how_to_calculate_latency/#_4","text":"\u6b21\u306e\u8868\u306f\u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u306e\u30c8\u30ec\u30fc\u30b9\u306b\u5fc5\u8981\u306a\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3068\u3001\u305d\u306e\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u5f15\u6570\uff08\u30c8\u30ec\u30fc\u30b9\u30c7\u30fc\u30bf\u3068\u3057\u3066\u51fa\u529b\u3055\u308c\u308b\u3082\u306e\uff09\u3067\u3059\u3002\u203b\u7c21\u6613\u7248 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540d \u5f15\u6570 1 \u5f15\u6570 2 \u6642\u523b rclcpp_intra_publish publisher_handle_arg message_arg time1 dispatch_intra_process_subscription_callback message_arg callback_arg time2 callback_start callback_arg is_intra_process time3 \u203b \u5f15\u6570\u306b\u3064\u3044\u3066\u306f\u3053\u3061\u3089\u3092\u53c2\u7167 message_arg \u3068 callback_arg \u306b\u306f\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u30a2\u30c9\u30ec\u30b9\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u30a2\u30c9\u30ec\u30b9\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002 rclcpp_intra_publisher \u3068 dispatch_intra_process_subscription_callback \u306f\u540c\u3058 message_arg \u3092\u6301\u3064\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540c\u58eb\u3067\u7d10\u3065\u3051\u3001dispatch_intra_process_subscription_callback \u3068 callback_start \u306f\u540c\u3058 callback_arg \u3092\u6301\u3064\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540c\u58eb\u3067\u7d10\u3065\u3051\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u4e0b\u8a18\u306e\u3088\u3046\u306a\u8868\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 \u6700\u5f8c\u306b callback_start - rclcpp_intra_publish \u3067 \u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u306e\u30ec\u30a4\u30c6\u30f3\u30b7 \u3092\u7b97\u51fa\u3057\u3066\u3044\u307e\u3059\u3002 idx rclcpp_intra_publish dispatch_intra_process_subscription_callback callback_start 0 time1 time2 time3 1 ... ... ...","title":"\u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1"},{"location":"design/how_to_calculate_latency/#_5","text":"\u4ee5\u4e0b\u306f\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306e\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3068\u305d\u306e\u5f15\u6570\u3067\u3059\u3002 \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540d \u5f15\u6570 1 \u5f15\u6570 2 \u5f15\u6570 3 \u6642\u523b rclcpp_publish publisher_handle_arg message_arg @1 time1 rcl_publish publisher_handle_arg message_arg @1 time2 dds_write publisher_handle_arg message_arg @1 time3 dds_bind_addr_to_stamp message_arg @1 stamp_arg time4 dispatch_subscription_callback messsage_arg@2 stamp_arg callback_arg time5 callback_start callback_arg is_intra_process time6 \u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u3068\u540c\u69d8\u306b\u540c\u3058\u5f15\u6570\u3092\u6301\u3064\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u540c\u58eb\u3092\u7d10\u3065\u3051\u3066\u3044\u304d\u3001publish \u304b\u3089 callback_start \u307e\u3067\u306e\u8868\u3092\u4f5c\u6210\u3057\u307e\u3059\uff08\u4e0b\u8a18\u8868\uff09\u3002 1 \u884c\u304c 1 \u3064\u306e\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306e\u30c1\u30a7\u30fc\u30f3\u3092\u8868\u3057\u3001 callback_start - rclcpp_publish \u306b\u3066 \u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306e\u30ec\u30a4\u30c6\u30f3\u30b7 \u3092\u7b97\u51fa\u3057\u307e\u3059\u3002 idx rclcpp_publish rcl_publish dds_write dds_bind_addr_to_stamp dispatch_subscription_callback callback_start 0 time1 time2 time3 time4 time5 time6 1 ... ... ... ... ... ...","title":"\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1"},{"location":"design/how_to_calculate_latency/#_6","text":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5\u306f 2 \u3064\u3042\u308a\u307e\u3059\u3002 \u305d\u308c\u305e\u308c\u306e\u624b\u6cd5\u30fb\u9577\u6240\u30fb\u77ed\u6240\u3092\u8aac\u660e\u3057\u307e\u3059\u3002","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u7b97\u51fa\u65b9\u6cd5"},{"location":"design/how_to_calculate_latency/#_7","text":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u6e2c\u5b9a\u306f\u3001\u540c\u3058\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30a2\u30c9\u30ec\u30b9\u3092\u6301\u3064 callback_start \u3068 rclcpp_publish \u306e\u5dee\u5206\u3092\u4f7f\u3063\u3066\u7b97\u51fa\u3057\u307e\u3059\u3002 callback_start \u3068 rclcpp_publish \u306e\u7d10\u3065\u3051\u306f\u3001rclcpp_publish \u304b\u3089\u898b\u3066\u4e00\u756a\u8fd1\u3044 callback_start \u3068\u7d10\u3065\u3051\u307e\u3059\u3002 idx callback_start (cb_A) [s] rclcpp_publish (cb_A) [s] callback_end (cb_A) [s] callback_arg (cb_A) 0 0 3 4 0x1000 1 2 5 6 0x1000 2 4 7 8 0x1000 ... ... ... ... ... idx callback_start (cb_B) [s] rclcpp_publish (cb_B) [s] callback_end (cb_B) [s] callback_arg (cb_B) 0 4 8 9 0x2000 1 8 12 13 0x2000 2 10 14 15 0x2000 \u4e0a\u8a18\u8868\u306e\u3088\u3046\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af A\u30fbB\uff08cb_A\u30fbcb_B\uff09\u304c\u5b58\u5728\u3057\u3001A\u2192B \u3068\u51e6\u7406\u304c\u7d9a\u304f\u6642\u3001cb_A \u306e callback_end \u3068 cb_B \u306e callback_start \u3092\u7d50\u3073\u4ed8\u3051\u3066\u8868\u3092\u4f5c\u308a\u307e\u3059\u3002 \u6700\u5f8c\u306e callback \u3060\u3051\u306f publish \u306e\u6642\u306e\u6642\u523b\u3092\u63a1\u7528\u3057\u3001\u4e0b\u8a18\u8868\u306e\u3088\u3046\u306b\u4e00\u3064\u306e\u30c6\u30fc\u30d6\u30eb\u306b\u3057\u307e\u3059\u3002 idx callback_start (cb_A) [s] callback_end (cb_A) [s] callback_start (cb_B) [s] rclcpp_publish (cb_B) [s] 0 0 4 4 8 1 2 6 Lost Lost 2 4 8 8 12 ... ... ... ... ... \u4e0a\u8a18\u306e\u3088\u3046\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u3064\u306a\u304e\u3001 rclcpp_publish (cb_X) - callback_start (cb_Y) \u3067 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7 \u3092\u7b97\u51fa\u3057\u307e\u3059\u3002 \u203b\u30ce\u30fc\u30c9\u5185\u306b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\uff11\u3064\u306e\u5834\u5408\u3001X, Y \u306f\u540c\u3058\u3082\u306e\u3092\u6307\u3057\u307e\u3059\u3002 \u8907\u6570\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u304c\u3042\u308b\u5834\u5408\u306f\u3001X \u304c\u6700\u5f8c\u30fbY \u304c\u6700\u521d\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3092\u6307\u3057\u307e\u3059\u3002","title":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u5229\u7528"},{"location":"design/latency_definition/","text":"\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 #","title":"\u30d1\u30b9\u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9"},{"location":"design/latency_definition/#_1","text":"","title":"\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/limits/","text":"\u5236\u9650 # \u4efb\u610f\u306e\u30ce\u30fc\u30c9\u30da\u30a2\u306e\u9593\u306f\u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u30fb\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306f\u56fa\u5b9a\u3002\u30c8\u30d4\u30c3\u30af\u6bce\u306b\u6307\u5b9a\u3057\u3066\u3044\u306a\u3044\u3053\u3068\u3002 /rosout \u3084/parameter_event \u306f\u30d1\u30b9\u306b\u306f\u542b\u307e\u306a\u3044\u3002 \u540c\u3058\u540d\u524d\u7a7a\u9593\u3092\u6301\u3064\u3001\u540c\u3058\u30ce\u30fc\u30c9\u540d\u306f\u4e00\u3064\u306e\u307f\u3002 ROS \u30ec\u30a4\u30e4\u30fc\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3044\u308b\u3002 \u540c\u3058\u30b9\u30ec\u30c3\u30c9\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u30da\u30a2\u304c\u5b58\u5728\u3059\u308b\u3002\u540c\u3058\u30b9\u30ec\u30c3\u30c9\u3067\u306e\u5b9f\u884c\u3092\u524d\u63d0\u306b\u3057\u3066\u3044\u308b\u3000\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u30da\u30a2\u304c\u3042\u308b\u3002 reentrant \u3067\u5b9f\u884c\u3057\u3066\u3044\u306a\u3044 \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u518d\u30d3\u30eb\u30c9\u304c\u5fc5\u8981\uff08rclcpp \u306e\u30d8\u30c3\u30c0\u30fc\u306b\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3092\u8ffd\u52a0\u3057\u305f\u305f\u3081\uff09 galatic \u306e\u307f \u5bfe\u5fdc FastDDS/CycloneDDS \u306e\u307f\u5bfe\u5fdc\uff08DDS-layer \u6e2c\u5b9a\u306e\u305f\u3081\u306b DDS \u5185\u306e\u30d5\u30c3\u30af\u3082\u884c\u3063\u3066\u3044\u308b\u305f\u3081\uff09 Linux \u306e\u307f\u306e\u5bfe\u5fdc\uff08LTTng \u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u3088\u308b\u3082\u306e\uff09","title":"\u30c4\u30fc\u30eb\u5229\u7528\u6642\u306e\u5236\u7d04"},{"location":"design/limits/#_1","text":"\u4efb\u610f\u306e\u30ce\u30fc\u30c9\u30da\u30a2\u306e\u9593\u306f\u30d7\u30ed\u30bb\u30b9\u5185\u901a\u4fe1\u30fb\u30d7\u30ed\u30bb\u30b9\u9593\u901a\u4fe1\u306f\u56fa\u5b9a\u3002\u30c8\u30d4\u30c3\u30af\u6bce\u306b\u6307\u5b9a\u3057\u3066\u3044\u306a\u3044\u3053\u3068\u3002 /rosout \u3084/parameter_event \u306f\u30d1\u30b9\u306b\u306f\u542b\u307e\u306a\u3044\u3002 \u540c\u3058\u540d\u524d\u7a7a\u9593\u3092\u6301\u3064\u3001\u540c\u3058\u30ce\u30fc\u30c9\u540d\u306f\u4e00\u3064\u306e\u307f\u3002 ROS \u30ec\u30a4\u30e4\u30fc\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3044\u308b\u3002 \u540c\u3058\u30b9\u30ec\u30c3\u30c9\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u30da\u30a2\u304c\u5b58\u5728\u3059\u308b\u3002\u540c\u3058\u30b9\u30ec\u30c3\u30c9\u3067\u306e\u5b9f\u884c\u3092\u524d\u63d0\u306b\u3057\u3066\u3044\u308b\u3000\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u306e\u30da\u30a2\u304c\u3042\u308b\u3002 reentrant \u3067\u5b9f\u884c\u3057\u3066\u3044\u306a\u3044 \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u518d\u30d3\u30eb\u30c9\u304c\u5fc5\u8981\uff08rclcpp \u306e\u30d8\u30c3\u30c0\u30fc\u306b\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u3092\u8ffd\u52a0\u3057\u305f\u305f\u3081\uff09 galatic \u306e\u307f \u5bfe\u5fdc FastDDS/CycloneDDS \u306e\u307f\u5bfe\u5fdc\uff08DDS-layer \u6e2c\u5b9a\u306e\u305f\u3081\u306b DDS \u5185\u306e\u30d5\u30c3\u30af\u3082\u884c\u3063\u3066\u3044\u308b\u305f\u3081\uff09 Linux \u306e\u307f\u306e\u5bfe\u5fdc\uff08LTTng \u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u3088\u308b\u3082\u306e\uff09","title":"\u5236\u9650"},{"location":"design/node_latency_definition/","text":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306b\u3064\u3044\u3066 # \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u7b97\u51fa\u304c\u56f0\u96e3\u3067\u3059 \u76f4\u63a5\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u6d41\u308c\u3092\u8ffd\u3044\u3001\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u51fa\u3059\u306e\u306f\u7c21\u5358\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002 CARET \u306f\u3044\u304f\u3064\u304b\u306e\u524d\u63d0\u306e\u3082\u3068\u3001\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002 callback_chain \u30dd\u30ea\u30b7\u30fc # \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066 \u3082\u3054\u53c2\u7167\u304f\u3060\u3055\u3044\u3002 \u60f3\u5b9a # \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30ad\u30e5\u30fc\u30b5\u30a4\u30ba\uff11\u3092\u60f3\u5b9a \u53b3\u5bc6\u306b\u6e2c\u5b9a\u3067\u304d\u308b\u306e\u306f Single Threaded Executor \u306e\u307f \u9577\u6240 # \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3078\u306e\u5909\u66f4\u304c\u4e0d\u8981 \u4efb\u610f\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u578b\u306b\u9069\u7528\u53ef\u80fd \u77ed\u6240 # \u30ad\u30e5\u30fc\u30b5\u30a4\u30ba\u304c\u5927\u304d\u3044\u6642\u3001\u30ec\u30a4\u30c6\u30f3\u30b7\u304c\u5c0f\u3055\u3081\u306b\u51fa\u308b\u30b1\u30fc\u30b9\u304c\u3042\u308b\u3002 multi threaded executor \u3067\u306f\u3001\u30ec\u30a4\u30c6\u30f3\u30b7\u304c\u5927\u304d\u3081\u306b\u51fa\u308b\u30b1\u30fc\u30b9\u304c\u3042\u308b\u3002 \u5b9f\u88c5\u3092\u8aad\u307f\u89e3\u304f\u306e\u304c\u96e3\u3057\u3044 \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # inherit_unique_stamp \u30dd\u30ea\u30b7\u30fc # \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # \u5165\u51fa\u529b\u306e\u30d8\u30c3\u30c0\u30fc\u3067\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u53d6\u308a\u3001\u5165\u529b\u30c8\u30d4\u30c3\u30af\u3068\u51fa\u529b\u30c8\u30d4\u30c3\u30af\u306e\u6642\u523b\u306e\u5dee\u5206\u304b\u3089\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3057\u307e\u3059\u3002 \u60f3\u5b9a # \u5165\u51fa\u529b\u306e\u30bf\u30a4\u30e0\u30b9\u30bf\u30f3\u30d7\u306e\u5024\u3067\u30de\u30c3\u30c1\u30f3\u30b0\u304c\u53d6\u308c\u308b\u3053\u3068\uff08\u5024\u3092\u66f8\u304d\u63db\u3048\u305a\u306b\u3001\u305d\u306e\u307e\u307e publish \u3057\u3066\u3044\u308b\u3053\u3068\uff09 \u5165\u51fa\u529b\u3068\u3082\u306b header \u3092\u3082\u3063\u3066\u3044\u308b\u3053\u3068 \u9577\u6240 # \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3078\u306e\u5909\u66f4\u304c\u4e0d\u8981 \u30ad\u30e5\u30fc\u30b5\u30a4\u30ba\u306b\u4f9d\u3089\u306a\u3044 \u77ed\u6240 # \u30d8\u30c3\u30c0\u30fc\u304c\u5fc5\u8981 publish \u524d\u306b stamp=\u73fe\u5728\u6642\u523b\u3068\u3057\u3066\u3044\u308b\u30b1\u30fc\u30b9\u306f\u5bfe\u5fdc\u4e0d\u53ef use_latest_message \u30dd\u30ea\u30b7\u30fc # \u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9 # \u5404\u30dd\u30ea\u30b7\u30fc\u306e\u6bd4\u8f03 # \u30dd\u30ea\u30b7\u30fc\u306e\u9078\u3073\u65b9 # \u6c7a\u5b9a\u6728\u304c\u6b32\u3057\u3044 \u6ce8\u610f\u70b9 # \u6e2c\u5b9a\u3067\u304d\u306a\u3044\u30b1\u30fc\u30b9 \u8aa4\u3063\u305f\u5024\u3092\u7b97\u51fa\u3059\u308b\u30b1\u30fc\u30b9","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u5b9a\u7fa9"},{"location":"design/node_latency_definition/#_1","text":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u7b97\u51fa\u304c\u56f0\u96e3\u3067\u3059 \u76f4\u63a5\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u6d41\u308c\u3092\u8ffd\u3044\u3001\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u51fa\u3059\u306e\u306f\u7c21\u5358\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002 CARET \u306f\u3044\u304f\u3064\u304b\u306e\u524d\u63d0\u306e\u3082\u3068\u3001\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306b\u3064\u3044\u3066"},{"location":"design/node_latency_definition/#callback_chain","text":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30b0\u30e9\u30d5\u306b\u3064\u3044\u3066 \u3082\u3054\u53c2\u7167\u304f\u3060\u3055\u3044\u3002","title":"callback_chain \u30dd\u30ea\u30b7\u30fc"},{"location":"design/node_latency_definition/#_2","text":"\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u9593\u306e\u30ad\u30e5\u30fc\u30b5\u30a4\u30ba\uff11\u3092\u60f3\u5b9a \u53b3\u5bc6\u306b\u6e2c\u5b9a\u3067\u304d\u308b\u306e\u306f Single Threaded Executor \u306e\u307f","title":"\u60f3\u5b9a"},{"location":"design/node_latency_definition/#_3","text":"\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3078\u306e\u5909\u66f4\u304c\u4e0d\u8981 \u4efb\u610f\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u578b\u306b\u9069\u7528\u53ef\u80fd","title":"\u9577\u6240"},{"location":"design/node_latency_definition/#_4","text":"\u30ad\u30e5\u30fc\u30b5\u30a4\u30ba\u304c\u5927\u304d\u3044\u6642\u3001\u30ec\u30a4\u30c6\u30f3\u30b7\u304c\u5c0f\u3055\u3081\u306b\u51fa\u308b\u30b1\u30fc\u30b9\u304c\u3042\u308b\u3002 multi threaded executor \u3067\u306f\u3001\u30ec\u30a4\u30c6\u30f3\u30b7\u304c\u5927\u304d\u3081\u306b\u51fa\u308b\u30b1\u30fc\u30b9\u304c\u3042\u308b\u3002 \u5b9f\u88c5\u3092\u8aad\u307f\u89e3\u304f\u306e\u304c\u96e3\u3057\u3044","title":"\u77ed\u6240"},{"location":"design/node_latency_definition/#_5","text":"","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/node_latency_definition/#_6","text":"","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/node_latency_definition/#inherit_unique_stamp","text":"","title":"inherit_unique_stamp \u30dd\u30ea\u30b7\u30fc"},{"location":"design/node_latency_definition/#_7","text":"\u5165\u51fa\u529b\u306e\u30d8\u30c3\u30c0\u30fc\u3067\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u53d6\u308a\u3001\u5165\u529b\u30c8\u30d4\u30c3\u30af\u3068\u51fa\u529b\u30c8\u30d4\u30c3\u30af\u306e\u6642\u523b\u306e\u5dee\u5206\u304b\u3089\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u3092\u7b97\u51fa\u3057\u307e\u3059\u3002","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/node_latency_definition/#_8","text":"\u5165\u51fa\u529b\u306e\u30bf\u30a4\u30e0\u30b9\u30bf\u30f3\u30d7\u306e\u5024\u3067\u30de\u30c3\u30c1\u30f3\u30b0\u304c\u53d6\u308c\u308b\u3053\u3068\uff08\u5024\u3092\u66f8\u304d\u63db\u3048\u305a\u306b\u3001\u305d\u306e\u307e\u307e publish \u3057\u3066\u3044\u308b\u3053\u3068\uff09 \u5165\u51fa\u529b\u3068\u3082\u306b header \u3092\u3082\u3063\u3066\u3044\u308b\u3053\u3068","title":"\u60f3\u5b9a"},{"location":"design/node_latency_definition/#_9","text":"\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3078\u306e\u5909\u66f4\u304c\u4e0d\u8981 \u30ad\u30e5\u30fc\u30b5\u30a4\u30ba\u306b\u4f9d\u3089\u306a\u3044","title":"\u9577\u6240"},{"location":"design/node_latency_definition/#_10","text":"\u30d8\u30c3\u30c0\u30fc\u304c\u5fc5\u8981 publish \u524d\u306b stamp=\u73fe\u5728\u6642\u523b\u3068\u3057\u3066\u3044\u308b\u30b1\u30fc\u30b9\u306f\u5bfe\u5fdc\u4e0d\u53ef","title":"\u77ed\u6240"},{"location":"design/node_latency_definition/#use_latest_message","text":"","title":"use_latest_message \u30dd\u30ea\u30b7\u30fc"},{"location":"design/node_latency_definition/#_11","text":"","title":"\u30ce\u30fc\u30c9\u30ec\u30a4\u30c6\u30f3\u30b7\u306e\u5b9a\u7fa9"},{"location":"design/node_latency_definition/#_12","text":"","title":"\u5404\u30dd\u30ea\u30b7\u30fc\u306e\u6bd4\u8f03"},{"location":"design/node_latency_definition/#_13","text":"\u6c7a\u5b9a\u6728\u304c\u6b32\u3057\u3044","title":"\u30dd\u30ea\u30b7\u30fc\u306e\u9078\u3073\u65b9"},{"location":"design/node_latency_definition/#_14","text":"\u6e2c\u5b9a\u3067\u304d\u306a\u3044\u30b1\u30fc\u30b9 \u8aa4\u3063\u305f\u5024\u3092\u7b97\u51fa\u3059\u308b\u30b1\u30fc\u30b9","title":"\u6ce8\u610f\u70b9"},{"location":"design/supported_tracepoints/","text":"Tracepoints definition # This section lists all tracepoints and their definition. Before listing tracepoints. Some tracepoints are used for collecting identification of executors, nodes, callbacks, and topics during application's initialization. They are called initialization tracepoints. The other tracepoints are embedded for sampling timestamps after completion of initialization, and called runtime tracepoints. Almost all of tracepoints supported by CARET are embedded in ROS and DDS layer. CARET utilizes some of the tracepoints embedded in original ROS 2 middleware, which are used for ros2-tracing. Some of the rest tracepoints are added to the fork of ROS 2's rclcpp, the other are introduced by function hooking with LD_PRELOAD. AS explained, tracepoints for CARET is embedded by three ways and they are identified as below. Original tracepoints tracepoints embedded in original ROS 2 middleware which are utilized by ros2-tracing some of tracepoints, for service, action and lifecycle node, are not utilized by CARET Extended tracepoints CARET-dedicated tracepoints added to the fork of rclcpp Hooked tracepoints CARET-dedicated tracepoints introduced by function hooking with LD_PRELOAD Info Please read this section if you are interested in CARET-dedicated tracepoints are extended by the forked rclcpp and LD_PRELOAD. CARET would like to add tracepoints by function hooking as possible. LD_PRELOAD is reasonable to hook functions defined in dynamic library, but it cannot be applied to functions by implemented with C++ template. Such template-based implementation is mapped into binary file after it is built or compiled. Original rclcpp uses C++ template for some functions like intra-process communication, for example. The forked rclcpp is introduced to add tracepoints to the functions. Sequence diagram of major tracepoints # Initialization tracepoints # ros2:rcl_init # [Original tracepoints] Sampled items void * context_handle ros2:rcl_node_init # [Original tracepoints] Sampled items void * node_handle void * rmw_handle char * node_name char * node_namespace ros2:rcl_publisher_init # [Original tracepoints] Sampled items void * publisher_handle void * node_handle void * rmw_publisher_handle char * topic_name size_t queue_depth ros2:rcl_subscription_init # [Original tracepoints] Sampled items void * subscription_handle void * node_handle void * rmw_subscription_handle char * topic_name size_t queue_depth ros2:rclcpp_subscription_init # [Original tracepoints] Sampled items void * subscription_handle void * subscription ros2:rclcpp_subscription_callback_added # [Original tracepoints] Sampled items void * subscription void * callback ros2:rcl_timer_init # [Original tracepoints] Sampled items void * timer_handle int64_t period ros2:rclcpp_timer_callback_added # [Original tracepoints] Sampled items void * timer_handle void * callback ros2:rclcpp_timer_link_node # [Original tracepoints] Sampled items void * timer_handle void * node_handle ros2:rclcpp_callback_register # [Original tracepoints] Sampled items void * callback char * function_symbol ros2_caret:rmw_implementation # [Hooked tracepoints] Sampled items char * rmw_impl ros2_caret:construct_executor # [Hooked tracepoints] Sampled items void * executor_addr char * executor_type_name ros2_caret:construct_static_executor # [Hooked tracepoints] Sampled items void * executor_addr void * entities_collector_addr char * executor_type_name ros2_caret:add_callback_group # [Hooked tracepoints] Sampled items void * executor_addr void * callback_group_addr char * group_type_name ros2_caret:add_callback_group_static_executor # [Hooked tracepoints] Sampled items void * entities_collector_addr void * callback_group_addr char * group_type_name ros2_caret:callback_group_add_timer # [Hooked tracepoints] Sampled items void * callback_group_addr void * timer_handle ros2_caret:callback_group_add_subscription # [Hooked tracepoints] Sampled items void * callback_group_addr void * subscription_handle ros2_caret:callback_group_add_service # [Hooked tracepoints] Sampled items void * callback_group_addr void * service_handle ros2_caret:callback_group_add_client # [Hooked tracepoints] Sampled items void * callback_group_addr void * client_handle Runtime tracepoints # ros2:callback_start # [Original tracepoints] Sampled items void * callback bool is_intra_process ros2:callback_end # [Original tracepoints] Sampled items void * callback ros2:message_construct # [Extended tracepoints] Sampled items void * original_message void * constructed_message ros2:rclcpp_intra_publish # [Extended tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp ros2:dispatch_subscription_callback # [Extended tracepoints] Sampled items void * message void * callback uint64_t source_timestamp uint64_t message_timestamp ros2:dispatch_intra_process_subscription_callback # [Extended tracepoints] Sampled items void * message void * callback uint64_t message_timestamp ros2:rcl_publish # [Original tracepoints] Sampled items void * publisher_handle void * message ros2:rclcpp_publish # [Original tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp ros2_caret:dds_write # [Hooked tracepoints] Sampled items void * message ros2_caret:dds_bind_addr_to_stamp # [Hooked tracepoints] Sampled items void * addr uint64_t source_stamp ros2_caret:dds_bind_addr_to_addr # [Hooked tracepoints] Sampled items void * addr_from void * addr_to Structure of tracepoint relationship # Some tracepoints share a same identification, such as a node ID ( node_handle ) and an address of callback instance. The shared identification associates each tracepoint to another, the association constructs structure of tracepoint relationship. The following figures show four structures. Tracepoints for representing structure of a node # graph RL node_handle[[node_handle]] subscription_handle[[subscription_handle]] subscription[[subscription]] callback[[callback]] timer_handle[[timer_handle]] client_handle[[client_handle]] node_handle[[node_handle]] publisher_handle[[publisher_handle]] rcl_init[rcl_init<ul><li>context_handle</li></ul>] rcl_node_init[rcl_node_init<br /><ul><li>node_handle</li><li>node_name</li><li>node_namespace</li><li>rmw_handle</li></ul>] rcl_publisher_init[rcl_publisher_init<br /><ul><li>node_handle</li><li>publisher_handle</li><li>rmw_publisher_handle</li><li>topic_name</li><li>queue_depth</li></ul>] rcl_subscription_init[rcl_subscription_init<ul><li>subscription_handle</li><li>node_handle</li><li>rmw_subscription_handle</li><li>topic_name</li><li>queue_depth</li></ul>] rclcpp_subscription_init[rclcpp_subscription_init<ul><li>subscription_handle</li><li>subscription</li></ul>] rclcpp_subscription_callback_added[rclcpp_subscription_callback_added<ul><li>subscription</li><li>callback</li></ul>] rclcpp_timer_link_node[rclcpp_timer_link_node<ul><li>timer_handle</li><li>node_handle</li></ul>] rclcpp_callback_register[rclcpp_callback_register<ul><li>callback</li><li>function_symbol</li></ul>] rmw_implementation[rmw_implementation<ul><li>rmw_impl</li></ul>] rcl_timer_init[rcl_timer_init<ul><li>timer_handle</li><li>period</li></ul>] rcl_publisher_init <--> node_handle node_handle <--> rcl_node_init rcl_subscription_init <--> node_handle subscription_handle <--> rcl_subscription_init rclcpp_subscription_init <--> subscription_handle publisher_handle <--> rcl_publisher_init subscription <--> rclcpp_subscription_init rclcpp_subscription_callback_added <--> subscription callback <--> rclcpp_subscription_callback_added rcl_timer_init <--> timer_handle rclcpp_timer_callback_added <--> timer_handle callback <--> rclcpp_timer_callback_added timer_handle <--> rclcpp_timer_link_node rclcpp_timer_link_node <--> node_handle callback <--> rclcpp_callback_register rmw_implementation If a certain of address of callback instance is unique, scanning the shared identification including timer_callback_added lets you identify a node to which the callback belongs. On the other hand, if node_handle is identified uniquely, callback in the node is identified as well. Tracepoints for representing structure of executor and callback group # graph RL subscription_handle[[subscription_handle]] executor_addr[[executor_addr]] entities_collector_addr[[entities_collector_addr]] timer_handle[[timer_handle]] client_handle[[client_handle]] service_handle[[service_handle]] callback_group_addr[[callback_group_addr]] construct_executor[construct_executor<ul><li>executor_addr</li><li>executor_type_name</li></ul>] construct_static_executor[construct_static_executor<ul><li>executor_addr</li><li>executor_type_name</li><li>entities_collector_addr</li></ul>] add_callback_group[add_callback_group<ul><li>executor_addr</li><li>callback_group_addr</li><li>group_type_name</li></ul>] add_callback_group_static_executor[add_callback_group_static_executor<ul><li>entities_collector_addr</li><li>callback_group_addr</li><li>group_type_name</li></ul>] callback_group_add_timer[callback_group_add_timer<ul><li>callback_group_addr</li><li>timer_handle</li></ul>] callback_group_add_subscription[callback_group_add_subscription<ul><li>callback_group_addr</li><li>subscription_handle</li></ul>] callback_group_add_service[callback_group_add_service<ul><li>callback_group_addr</li><li>service_handle</li></ul>] callback_group_add_client[callback_group_add_client<ul><li>callback_group_addr</li><li>client_handle</li></ul>] executor_addr <--> construct_executor entities_collector_addr <--> construct_static_executor add_callback_group <--> executor_addr callback_group_addr <--> add_callback_group add_callback_group_static_executor <--> entities_collector_addr callback_group_addr <--> add_callback_group_static_executor callback_group_add_timer <--> callback_group_addr timer_handle <--> callback_group_add_timer callback_group_add_subscription <--> callback_group_addr subscription_handle <--> callback_group_add_subscription callback_group_add_service <--> callback_group_addr service_handle <--> callback_group_add_service callback_group_add_client <--> callback_group_addr client_handle <--> callback_group_add_client A handler such as timer_handle and subscription_handle are assigned to a callback group. A callback group belongs to an executor. Tracepoints for representing flow of message transmission # graph LR source_timestamp[[source_timestamp]] message_dds[[message_addr]] message_intra[[message_addr]] message_inter[[message_addr]] publish((\"publish(message)\")) source_timestamp[[source_timestamp]] message_intra_sub[[message_addr]] rclcpp_intra_publish[rclcpp_intra_publish<ul><li>publisher_handle</li><li>message_addr</li><li>message_timestamp</li></ul>] message_construct_intra[message_construct<ul><li>original_message_addr</li><li>constructed_message_addr</li></ul>] message_construct_inter[message_construct<ul><li>original_message_addr</li><li>constructed_message_addr</li></ul>] rclcpp_publish[rclcpp_publish<ul><li>publisher_handle</li><li>message_addr</li><li>message_timestamp</li></ul>] rcl_publish[rcl_publish<ul><li>publisher_handle</li><li>message_addr</li></ul>] dds_write[dds_write<ul><li>message_addr</li></ul>] dds_bind_addr_to_addr[dds_bind_addr_to_addr<ul><li>addr_from</li><li>addr_to</li></ul>] dds_bind_addr_to_stamp[dds_bind_addr_to_stamp<ul><li>message_addr</li><li>source_timestamp</li></ul>] publish --> rclcpp_intra_publish publish --> rclcpp_publish subgraph message_copy_if_necessary rclcpp_intra_publish <--> message_intra rclcpp_publish <--> message_inter message_construct_intra -.-> message_intra message_intra -.-> message_construct_intra message_construct_inter -.-> message_inter message_inter -.-> message_construct_inter end message_inter <--> rcl_publish message_inter <--> dds_write dds_write <--> message_dds message_dds <--> dds_bind_addr_to_stamp dds_bind_addr_to_stamp <--> source_timestamp dds_bind_addr_to_addr -.-> message_dds message_dds -.-> dds_bind_addr_to_addr If a topic message is defined with unique_ptr and transmitted to multiple subscription by publish method, the topic message may be copied. CARET can associate an address of original message to that of copied one by message_construct . A certain message is identified with an unique address in rcl layer, it is identified with source_timestamp in DDS layer. All messages communicated via DDS have source_timestamp given automatically, which are introduced for QoS function.A pair of publish and subscription same source_timestamp . CARET utilizes source_timestamp to map transmitted message to received one. CARET maps a message_addr to a published message for intra-process communication, and a source_timestamp to one for inter-communication. Tracepoints for representing flow of callback execution after message reception # graph LR source_timestamp[[source_timestamp]] message_intra_sub[[message_addr]] message_intra[[message_addr]] callback[[callback]] source_timestamp[[source_timestamp]] source_timestamp_sub[source_timestamp] dispatch_subscription_callback[dispatch_subscription_callback<ul><li>message_addr</li><li>callback</li><li>source_timestamp</li><li>message_timestamp</li></ul>] dispatch_intra_process_subscription_callback[dispatch_intra_process_subscription_callback<ul><li>message_addr</li><li>callback</li><li>message_timestamp</li></ul>] callback_end_[callback_end<ul><li>callback</li></ul>] callback_start[callback_start<ul><li>callback</li><li>is_intra_process</li></ul>] source_timestamp --Inter Process Communication--> source_timestamp_sub message_intra --Intra Process Communication--> message_intra_sub message_intra_sub --> dispatch_intra_process_subscription_callback dispatch_intra_process_subscription_callback --> callback callback --> callback_start callback --> callback_end_ dispatch_subscription_callback --> callback source_timestamp_sub --> dispatch_subscription_callback As well as flow of message transmission, a message is identified by message_addr for intra-process communication, but source_timestamp for inter-process communication. message_addr and source_timestamp is mapped a corresponding callback_start . As explained, message_addr and source_timestamp are identifier for transmission flow using publish method. This means that a invoked publish method is mapped to a callback_start . However this does not mean that CARET can map a callback_start to a corresponding publish . CARET can trace a certain flow from publish to callback_start , but the reversed mapping, from callback_start to publish , is not supported by CARET. The capability of mapping between callback_start and publish will be improved in v0.3.* release or later.","title":"Supported tracepoints"},{"location":"design/supported_tracepoints/#tracepoints-definition","text":"This section lists all tracepoints and their definition. Before listing tracepoints. Some tracepoints are used for collecting identification of executors, nodes, callbacks, and topics during application's initialization. They are called initialization tracepoints. The other tracepoints are embedded for sampling timestamps after completion of initialization, and called runtime tracepoints. Almost all of tracepoints supported by CARET are embedded in ROS and DDS layer. CARET utilizes some of the tracepoints embedded in original ROS 2 middleware, which are used for ros2-tracing. Some of the rest tracepoints are added to the fork of ROS 2's rclcpp, the other are introduced by function hooking with LD_PRELOAD. AS explained, tracepoints for CARET is embedded by three ways and they are identified as below. Original tracepoints tracepoints embedded in original ROS 2 middleware which are utilized by ros2-tracing some of tracepoints, for service, action and lifecycle node, are not utilized by CARET Extended tracepoints CARET-dedicated tracepoints added to the fork of rclcpp Hooked tracepoints CARET-dedicated tracepoints introduced by function hooking with LD_PRELOAD Info Please read this section if you are interested in CARET-dedicated tracepoints are extended by the forked rclcpp and LD_PRELOAD. CARET would like to add tracepoints by function hooking as possible. LD_PRELOAD is reasonable to hook functions defined in dynamic library, but it cannot be applied to functions by implemented with C++ template. Such template-based implementation is mapped into binary file after it is built or compiled. Original rclcpp uses C++ template for some functions like intra-process communication, for example. The forked rclcpp is introduced to add tracepoints to the functions.","title":"Tracepoints definition"},{"location":"design/supported_tracepoints/#sequence-diagram-of-major-tracepoints","text":"","title":"Sequence diagram of major tracepoints"},{"location":"design/supported_tracepoints/#initialization-tracepoints","text":"","title":"Initialization tracepoints"},{"location":"design/supported_tracepoints/#ros2rcl_init","text":"[Original tracepoints] Sampled items void * context_handle","title":"ros2:rcl_init"},{"location":"design/supported_tracepoints/#ros2rcl_node_init","text":"[Original tracepoints] Sampled items void * node_handle void * rmw_handle char * node_name char * node_namespace","title":"ros2:rcl_node_init"},{"location":"design/supported_tracepoints/#ros2rcl_publisher_init","text":"[Original tracepoints] Sampled items void * publisher_handle void * node_handle void * rmw_publisher_handle char * topic_name size_t queue_depth","title":"ros2:rcl_publisher_init"},{"location":"design/supported_tracepoints/#ros2rcl_subscription_init","text":"[Original tracepoints] Sampled items void * subscription_handle void * node_handle void * rmw_subscription_handle char * topic_name size_t queue_depth","title":"ros2:rcl_subscription_init"},{"location":"design/supported_tracepoints/#ros2rclcpp_subscription_init","text":"[Original tracepoints] Sampled items void * subscription_handle void * subscription","title":"ros2:rclcpp_subscription_init"},{"location":"design/supported_tracepoints/#ros2rclcpp_subscription_callback_added","text":"[Original tracepoints] Sampled items void * subscription void * callback","title":"ros2:rclcpp_subscription_callback_added"},{"location":"design/supported_tracepoints/#ros2rcl_timer_init","text":"[Original tracepoints] Sampled items void * timer_handle int64_t period","title":"ros2:rcl_timer_init"},{"location":"design/supported_tracepoints/#ros2rclcpp_timer_callback_added","text":"[Original tracepoints] Sampled items void * timer_handle void * callback","title":"ros2:rclcpp_timer_callback_added"},{"location":"design/supported_tracepoints/#ros2rclcpp_timer_link_node","text":"[Original tracepoints] Sampled items void * timer_handle void * node_handle","title":"ros2:rclcpp_timer_link_node"},{"location":"design/supported_tracepoints/#ros2rclcpp_callback_register","text":"[Original tracepoints] Sampled items void * callback char * function_symbol","title":"ros2:rclcpp_callback_register"},{"location":"design/supported_tracepoints/#ros2_caretrmw_implementation","text":"[Hooked tracepoints] Sampled items char * rmw_impl","title":"ros2_caret:rmw_implementation"},{"location":"design/supported_tracepoints/#ros2_caretconstruct_executor","text":"[Hooked tracepoints] Sampled items void * executor_addr char * executor_type_name","title":"ros2_caret:construct_executor"},{"location":"design/supported_tracepoints/#ros2_caretconstruct_static_executor","text":"[Hooked tracepoints] Sampled items void * executor_addr void * entities_collector_addr char * executor_type_name","title":"ros2_caret:construct_static_executor"},{"location":"design/supported_tracepoints/#ros2_caretadd_callback_group","text":"[Hooked tracepoints] Sampled items void * executor_addr void * callback_group_addr char * group_type_name","title":"ros2_caret:add_callback_group"},{"location":"design/supported_tracepoints/#ros2_caretadd_callback_group_static_executor","text":"[Hooked tracepoints] Sampled items void * entities_collector_addr void * callback_group_addr char * group_type_name","title":"ros2_caret:add_callback_group_static_executor"},{"location":"design/supported_tracepoints/#ros2_caretcallback_group_add_timer","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * timer_handle","title":"ros2_caret:callback_group_add_timer"},{"location":"design/supported_tracepoints/#ros2_caretcallback_group_add_subscription","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * subscription_handle","title":"ros2_caret:callback_group_add_subscription"},{"location":"design/supported_tracepoints/#ros2_caretcallback_group_add_service","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * service_handle","title":"ros2_caret:callback_group_add_service"},{"location":"design/supported_tracepoints/#ros2_caretcallback_group_add_client","text":"[Hooked tracepoints] Sampled items void * callback_group_addr void * client_handle","title":"ros2_caret:callback_group_add_client"},{"location":"design/supported_tracepoints/#runtime-tracepoints","text":"","title":"Runtime tracepoints"},{"location":"design/supported_tracepoints/#ros2callback_start","text":"[Original tracepoints] Sampled items void * callback bool is_intra_process","title":"ros2:callback_start"},{"location":"design/supported_tracepoints/#ros2callback_end","text":"[Original tracepoints] Sampled items void * callback","title":"ros2:callback_end"},{"location":"design/supported_tracepoints/#ros2message_construct","text":"[Extended tracepoints] Sampled items void * original_message void * constructed_message","title":"ros2:message_construct"},{"location":"design/supported_tracepoints/#ros2rclcpp_intra_publish","text":"[Extended tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp","title":"ros2:rclcpp_intra_publish"},{"location":"design/supported_tracepoints/#ros2dispatch_subscription_callback","text":"[Extended tracepoints] Sampled items void * message void * callback uint64_t source_timestamp uint64_t message_timestamp","title":"ros2:dispatch_subscription_callback"},{"location":"design/supported_tracepoints/#ros2dispatch_intra_process_subscription_callback","text":"[Extended tracepoints] Sampled items void * message void * callback uint64_t message_timestamp","title":"ros2:dispatch_intra_process_subscription_callback"},{"location":"design/supported_tracepoints/#ros2rcl_publish","text":"[Original tracepoints] Sampled items void * publisher_handle void * message","title":"ros2:rcl_publish"},{"location":"design/supported_tracepoints/#ros2rclcpp_publish","text":"[Original tracepoints] Sampled items void * publisher_handle void * message uint64_t message_timestamp","title":"ros2:rclcpp_publish"},{"location":"design/supported_tracepoints/#ros2_caretdds_write","text":"[Hooked tracepoints] Sampled items void * message","title":"ros2_caret:dds_write"},{"location":"design/supported_tracepoints/#ros2_caretdds_bind_addr_to_stamp","text":"[Hooked tracepoints] Sampled items void * addr uint64_t source_stamp","title":"ros2_caret:dds_bind_addr_to_stamp"},{"location":"design/supported_tracepoints/#ros2_caretdds_bind_addr_to_addr","text":"[Hooked tracepoints] Sampled items void * addr_from void * addr_to","title":"ros2_caret:dds_bind_addr_to_addr"},{"location":"design/supported_tracepoints/#structure-of-tracepoint-relationship","text":"Some tracepoints share a same identification, such as a node ID ( node_handle ) and an address of callback instance. The shared identification associates each tracepoint to another, the association constructs structure of tracepoint relationship. The following figures show four structures.","title":"Structure of tracepoint relationship"},{"location":"design/supported_tracepoints/#tracepoints-for-representing-structure-of-a-node","text":"graph RL node_handle[[node_handle]] subscription_handle[[subscription_handle]] subscription[[subscription]] callback[[callback]] timer_handle[[timer_handle]] client_handle[[client_handle]] node_handle[[node_handle]] publisher_handle[[publisher_handle]] rcl_init[rcl_init<ul><li>context_handle</li></ul>] rcl_node_init[rcl_node_init<br /><ul><li>node_handle</li><li>node_name</li><li>node_namespace</li><li>rmw_handle</li></ul>] rcl_publisher_init[rcl_publisher_init<br /><ul><li>node_handle</li><li>publisher_handle</li><li>rmw_publisher_handle</li><li>topic_name</li><li>queue_depth</li></ul>] rcl_subscription_init[rcl_subscription_init<ul><li>subscription_handle</li><li>node_handle</li><li>rmw_subscription_handle</li><li>topic_name</li><li>queue_depth</li></ul>] rclcpp_subscription_init[rclcpp_subscription_init<ul><li>subscription_handle</li><li>subscription</li></ul>] rclcpp_subscription_callback_added[rclcpp_subscription_callback_added<ul><li>subscription</li><li>callback</li></ul>] rclcpp_timer_link_node[rclcpp_timer_link_node<ul><li>timer_handle</li><li>node_handle</li></ul>] rclcpp_callback_register[rclcpp_callback_register<ul><li>callback</li><li>function_symbol</li></ul>] rmw_implementation[rmw_implementation<ul><li>rmw_impl</li></ul>] rcl_timer_init[rcl_timer_init<ul><li>timer_handle</li><li>period</li></ul>] rcl_publisher_init <--> node_handle node_handle <--> rcl_node_init rcl_subscription_init <--> node_handle subscription_handle <--> rcl_subscription_init rclcpp_subscription_init <--> subscription_handle publisher_handle <--> rcl_publisher_init subscription <--> rclcpp_subscription_init rclcpp_subscription_callback_added <--> subscription callback <--> rclcpp_subscription_callback_added rcl_timer_init <--> timer_handle rclcpp_timer_callback_added <--> timer_handle callback <--> rclcpp_timer_callback_added timer_handle <--> rclcpp_timer_link_node rclcpp_timer_link_node <--> node_handle callback <--> rclcpp_callback_register rmw_implementation If a certain of address of callback instance is unique, scanning the shared identification including timer_callback_added lets you identify a node to which the callback belongs. On the other hand, if node_handle is identified uniquely, callback in the node is identified as well.","title":"Tracepoints for representing structure of a node"},{"location":"design/supported_tracepoints/#tracepoints-for-representing-structure-of-executor-and-callback-group","text":"graph RL subscription_handle[[subscription_handle]] executor_addr[[executor_addr]] entities_collector_addr[[entities_collector_addr]] timer_handle[[timer_handle]] client_handle[[client_handle]] service_handle[[service_handle]] callback_group_addr[[callback_group_addr]] construct_executor[construct_executor<ul><li>executor_addr</li><li>executor_type_name</li></ul>] construct_static_executor[construct_static_executor<ul><li>executor_addr</li><li>executor_type_name</li><li>entities_collector_addr</li></ul>] add_callback_group[add_callback_group<ul><li>executor_addr</li><li>callback_group_addr</li><li>group_type_name</li></ul>] add_callback_group_static_executor[add_callback_group_static_executor<ul><li>entities_collector_addr</li><li>callback_group_addr</li><li>group_type_name</li></ul>] callback_group_add_timer[callback_group_add_timer<ul><li>callback_group_addr</li><li>timer_handle</li></ul>] callback_group_add_subscription[callback_group_add_subscription<ul><li>callback_group_addr</li><li>subscription_handle</li></ul>] callback_group_add_service[callback_group_add_service<ul><li>callback_group_addr</li><li>service_handle</li></ul>] callback_group_add_client[callback_group_add_client<ul><li>callback_group_addr</li><li>client_handle</li></ul>] executor_addr <--> construct_executor entities_collector_addr <--> construct_static_executor add_callback_group <--> executor_addr callback_group_addr <--> add_callback_group add_callback_group_static_executor <--> entities_collector_addr callback_group_addr <--> add_callback_group_static_executor callback_group_add_timer <--> callback_group_addr timer_handle <--> callback_group_add_timer callback_group_add_subscription <--> callback_group_addr subscription_handle <--> callback_group_add_subscription callback_group_add_service <--> callback_group_addr service_handle <--> callback_group_add_service callback_group_add_client <--> callback_group_addr client_handle <--> callback_group_add_client A handler such as timer_handle and subscription_handle are assigned to a callback group. A callback group belongs to an executor.","title":"Tracepoints for representing structure of executor and callback group"},{"location":"design/supported_tracepoints/#tracepoints-for-representing-flow-of-message-transmission","text":"graph LR source_timestamp[[source_timestamp]] message_dds[[message_addr]] message_intra[[message_addr]] message_inter[[message_addr]] publish((\"publish(message)\")) source_timestamp[[source_timestamp]] message_intra_sub[[message_addr]] rclcpp_intra_publish[rclcpp_intra_publish<ul><li>publisher_handle</li><li>message_addr</li><li>message_timestamp</li></ul>] message_construct_intra[message_construct<ul><li>original_message_addr</li><li>constructed_message_addr</li></ul>] message_construct_inter[message_construct<ul><li>original_message_addr</li><li>constructed_message_addr</li></ul>] rclcpp_publish[rclcpp_publish<ul><li>publisher_handle</li><li>message_addr</li><li>message_timestamp</li></ul>] rcl_publish[rcl_publish<ul><li>publisher_handle</li><li>message_addr</li></ul>] dds_write[dds_write<ul><li>message_addr</li></ul>] dds_bind_addr_to_addr[dds_bind_addr_to_addr<ul><li>addr_from</li><li>addr_to</li></ul>] dds_bind_addr_to_stamp[dds_bind_addr_to_stamp<ul><li>message_addr</li><li>source_timestamp</li></ul>] publish --> rclcpp_intra_publish publish --> rclcpp_publish subgraph message_copy_if_necessary rclcpp_intra_publish <--> message_intra rclcpp_publish <--> message_inter message_construct_intra -.-> message_intra message_intra -.-> message_construct_intra message_construct_inter -.-> message_inter message_inter -.-> message_construct_inter end message_inter <--> rcl_publish message_inter <--> dds_write dds_write <--> message_dds message_dds <--> dds_bind_addr_to_stamp dds_bind_addr_to_stamp <--> source_timestamp dds_bind_addr_to_addr -.-> message_dds message_dds -.-> dds_bind_addr_to_addr If a topic message is defined with unique_ptr and transmitted to multiple subscription by publish method, the topic message may be copied. CARET can associate an address of original message to that of copied one by message_construct . A certain message is identified with an unique address in rcl layer, it is identified with source_timestamp in DDS layer. All messages communicated via DDS have source_timestamp given automatically, which are introduced for QoS function.A pair of publish and subscription same source_timestamp . CARET utilizes source_timestamp to map transmitted message to received one. CARET maps a message_addr to a published message for intra-process communication, and a source_timestamp to one for inter-communication.","title":"Tracepoints for representing flow of message transmission"},{"location":"design/supported_tracepoints/#tracepoints-for-representing-flow-of-callback-execution-after-message-reception","text":"graph LR source_timestamp[[source_timestamp]] message_intra_sub[[message_addr]] message_intra[[message_addr]] callback[[callback]] source_timestamp[[source_timestamp]] source_timestamp_sub[source_timestamp] dispatch_subscription_callback[dispatch_subscription_callback<ul><li>message_addr</li><li>callback</li><li>source_timestamp</li><li>message_timestamp</li></ul>] dispatch_intra_process_subscription_callback[dispatch_intra_process_subscription_callback<ul><li>message_addr</li><li>callback</li><li>message_timestamp</li></ul>] callback_end_[callback_end<ul><li>callback</li></ul>] callback_start[callback_start<ul><li>callback</li><li>is_intra_process</li></ul>] source_timestamp --Inter Process Communication--> source_timestamp_sub message_intra --Intra Process Communication--> message_intra_sub message_intra_sub --> dispatch_intra_process_subscription_callback dispatch_intra_process_subscription_callback --> callback callback --> callback_start callback --> callback_end_ dispatch_subscription_callback --> callback source_timestamp_sub --> dispatch_subscription_callback As well as flow of message transmission, a message is identified by message_addr for intra-process communication, but source_timestamp for inter-process communication. message_addr and source_timestamp is mapped a corresponding callback_start . As explained, message_addr and source_timestamp are identifier for transmission flow using publish method. This means that a invoked publish method is mapped to a callback_start . However this does not mean that CARET can map a callback_start to a corresponding publish . CARET can trace a certain flow from publish to callback_start , but the reversed mapping, from callback_start to publish , is not supported by CARET. The capability of mapping between callback_start and publish will be improved in v0.3.* release or later.","title":"Tracepoints for representing flow of callback execution after message reception"},{"location":"faq/","text":"FAQ # Installation # Setup fails # In case you encounter errors during setup or build process, please make sure to use an appropriate branch for your environment ROS 2 Galactic, Ubuntu 20.04: galactic branch ROS 2 Humble, Ubuntu 22.04: main branch It's also important to delete ./build ./install and ./src directory before rebuilding CARET if you have built CARET using wrong settings CLI tool doesn't work # In case CLI tool execution fails, please make sure to perform CARET environment settings source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Warning CARET CLI tool doesn't work properly in Anaconda environment. Please use pure Python. Visualization # Result (plot, message_flow, etc.) is not outputted, or there seems something wrong with the result # Please use the following commands for verification ros2 caret check_caret_rclcpp to check if a target application is built with CARET/rclcpp ros2 caret check_ctf to check if tracing data is recorded properly Please make sure the followings: A target application is built with CARET/rclcpp CARET environment is set properly before running a target application export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so) source ~/ros2_caret_ws/install/local_setup.bash LTTng trace is started before running a target application ros2 trace -s e2e_sample -k -u \"ros2*\" or consider to use launch file Trace data is not discarded In case trace data is discarded, use Trace filter The size of trace data is proper If the size of trace data is extremely small (e.g. only few KByte) and a target application has lots of nodes, the maximum number of file descriptors may not be enough. It can be increased by ulimit -n 65536 See Recording for more details Parts of results are not outputted # If certain nodes are not traced but some nodes are traced, some packages may be built without CARET/rclcpp. Please make sure <depend>rclcpp</depend> is described in package.xml Another possibility is that some nodes can't be analyzed due to CARET's limitations: CARET cannot analyze a node which has two or more timer callbacks with the same period time setting CARET cannot analyze a node which has two or more subscription callbacks with the same topic name Callback information in such nodes are not outputted. Also, message flow will be discontinued at such nodes TraceResultAnalyzeError: Failed to find error occurs # The error occurs if information in an architecture file and trace data are inconsistent with each other Please modify the architecture file or check recording process e.g. TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)() Visualization (callback) # Callback frequency is smaller than expected value # Plot.create_callback_frequency_plot calculates frequency from one second to one second. It counts how many times a callback function is called for a second, and just uses the count as frequency. Therefore, the frequency on the last term tends to small because the last term is usually shorter than one second Another possibility is that the frequency of a subscription callback will be small if it receives topics not periodically but infrequently. Also, the frequency of a timer callback will be small if the timer dynamically stops/starts Callback latency is bigger than expected value # Some nodes may run initialization process. In this case, the latency time calculated by Plot.create_callback_latency_plot is huge on the first execution Visualization (message flow) # Message flow is discontinued # If parts of nodes/communications don't run at all during recording, message flow stops on the way and such nodes/communications are not displayed on y-axis Please make sure that all nodes/communications in a target path run during recording, or modify a target path to analyze actually working path Another possibility is that a target path includes a node which CARET cannot analyze due to its limitations as explained above What is a gray color rectangle in a message flow diagram? # A rectangle in a message flow diagram indicates a period from the entry to the exit of a callback function, while a line shows a flow of topics Note: a rectangle is not always illustrated Huge delay between topic publication and callback start # In a message flow diagram, term from ooo/rclcpp_publish to ooo/callback_start means latency from when a topic is published to when the following callback starts It includes the following time: Communication (topic) latency Wait by ROS scheduler Wait by OS scheduler In most cases, it doesn't take so much time. In case the time is huge, the followings are possible causes: There is a problem in communication An executor cannot wake up because other processes occupy CPU A callback cannot wake up because other callbacks in the same callback group occupy the executor Processing time of a callback is longer than topic subscription period Message flow looks split # Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 50 Hz, while Node_B publishes a topic at 10 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks split at Node_C . It's because Node_C publishes 5 topics while receiving 1 topic from Node_B Note: A similar phenomenon will happen even if Callback c0 is a timer callback Message flow looks dropped # Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 10 Hz, while Node_B publishes a topic at 50 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks disconnected at Node_C four times every five messages. It's because Node_C publishes 1 topic while receiving 5 topics from Node_B . So 4 topics don't have a corresponding topic to be published to Node_D Note: A similar phenomenon will happen even if Callback c0 is a timer callback How response time is calculated? # In general, response time is the time a system or functional unit takes to react to a given input ( reference ). Response time calculated by CARET is the time it takes for input data to arrive at the last node. It doesn't include processing time at the first/last node nor latency of an actuator. It's calculated as the sum of communication latency time (from the time when a node publishes a topic to the time when the following node subscribes the topic) and node latency time (from the time when a node subscribes a topic to the time when it publishes another topic) in a path In the following diagram, input data at point A is first reflected with output at point X ( ResponseTime_Best ) ResponseTime_Best can be considered as a path (dataflow) latency time ResponseTime_Best can be considered as a happy case, which is contrary to the following worst case scenario Assuming that input information is created by a sensor such as an object detection sensor, delay in a sensor should be considered. For instance, if a new object appears at point B, the time from point B to point A should added to the response time. The worst case scenario is that a new object appears just after the previous flow (point C). Response time for the worst case is shown as ResponseTime_Worst CARET can calculate both ResponseTime_Best and ResponseTime_Worst using the following APIs: response_time.to_best_case_timeseries() , response_time.to_best_case_histogram() response_time.to_worst_case_timeseries() , response_time.to_best_worst_histogram() CARET also provides response_time.to_histogram() API. It creates histogram assuming a new object appears from point C to point A at intervals of histogram bin size","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#installation","text":"","title":"Installation"},{"location":"faq/#setup-fails","text":"In case you encounter errors during setup or build process, please make sure to use an appropriate branch for your environment ROS 2 Galactic, Ubuntu 20.04: galactic branch ROS 2 Humble, Ubuntu 22.04: main branch It's also important to delete ./build ./install and ./src directory before rebuilding CARET if you have built CARET using wrong settings","title":"Setup fails"},{"location":"faq/#cli-tool-doesnt-work","text":"In case CLI tool execution fails, please make sure to perform CARET environment settings source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Warning CARET CLI tool doesn't work properly in Anaconda environment. Please use pure Python.","title":"CLI tool doesn't work"},{"location":"faq/#visualization","text":"","title":"Visualization"},{"location":"faq/#result-plot-message_flow-etc-is-not-outputted-or-there-seems-something-wrong-with-the-result","text":"Please use the following commands for verification ros2 caret check_caret_rclcpp to check if a target application is built with CARET/rclcpp ros2 caret check_ctf to check if tracing data is recorded properly Please make sure the followings: A target application is built with CARET/rclcpp CARET environment is set properly before running a target application export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so) source ~/ros2_caret_ws/install/local_setup.bash LTTng trace is started before running a target application ros2 trace -s e2e_sample -k -u \"ros2*\" or consider to use launch file Trace data is not discarded In case trace data is discarded, use Trace filter The size of trace data is proper If the size of trace data is extremely small (e.g. only few KByte) and a target application has lots of nodes, the maximum number of file descriptors may not be enough. It can be increased by ulimit -n 65536 See Recording for more details","title":"Result (plot, message_flow, etc.) is not outputted, or there seems something wrong with the result"},{"location":"faq/#parts-of-results-are-not-outputted","text":"If certain nodes are not traced but some nodes are traced, some packages may be built without CARET/rclcpp. Please make sure <depend>rclcpp</depend> is described in package.xml Another possibility is that some nodes can't be analyzed due to CARET's limitations: CARET cannot analyze a node which has two or more timer callbacks with the same period time setting CARET cannot analyze a node which has two or more subscription callbacks with the same topic name Callback information in such nodes are not outputted. Also, message flow will be discontinued at such nodes","title":"Parts of results are not outputted"},{"location":"faq/#traceresultanalyzeerror-failed-to-find-error-occurs","text":"The error occurs if information in an architecture file and trace data are inconsistent with each other Please modify the architecture file or check recording process e.g. TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)()","title":"TraceResultAnalyzeError: Failed to find error occurs"},{"location":"faq/#visualization-callback","text":"","title":"Visualization (callback)"},{"location":"faq/#callback-frequency-is-smaller-than-expected-value","text":"Plot.create_callback_frequency_plot calculates frequency from one second to one second. It counts how many times a callback function is called for a second, and just uses the count as frequency. Therefore, the frequency on the last term tends to small because the last term is usually shorter than one second Another possibility is that the frequency of a subscription callback will be small if it receives topics not periodically but infrequently. Also, the frequency of a timer callback will be small if the timer dynamically stops/starts","title":"Callback frequency is smaller than expected value"},{"location":"faq/#callback-latency-is-bigger-than-expected-value","text":"Some nodes may run initialization process. In this case, the latency time calculated by Plot.create_callback_latency_plot is huge on the first execution","title":"Callback latency is bigger than expected value"},{"location":"faq/#visualization-message-flow","text":"","title":"Visualization (message flow)"},{"location":"faq/#message-flow-is-discontinued","text":"If parts of nodes/communications don't run at all during recording, message flow stops on the way and such nodes/communications are not displayed on y-axis Please make sure that all nodes/communications in a target path run during recording, or modify a target path to analyze actually working path Another possibility is that a target path includes a node which CARET cannot analyze due to its limitations as explained above","title":"Message flow is discontinued"},{"location":"faq/#what-is-a-gray-color-rectangle-in-a-message-flow-diagram","text":"A rectangle in a message flow diagram indicates a period from the entry to the exit of a callback function, while a line shows a flow of topics Note: a rectangle is not always illustrated","title":"What is a gray color rectangle in a message flow diagram?"},{"location":"faq/#huge-delay-between-topic-publication-and-callback-start","text":"In a message flow diagram, term from ooo/rclcpp_publish to ooo/callback_start means latency from when a topic is published to when the following callback starts It includes the following time: Communication (topic) latency Wait by ROS scheduler Wait by OS scheduler In most cases, it doesn't take so much time. In case the time is huge, the followings are possible causes: There is a problem in communication An executor cannot wake up because other processes occupy CPU A callback cannot wake up because other callbacks in the same callback group occupy the executor Processing time of a callback is longer than topic subscription period","title":"Huge delay between topic publication and callback start"},{"location":"faq/#message-flow-looks-split","text":"Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 50 Hz, while Node_B publishes a topic at 10 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks split at Node_C . It's because Node_C publishes 5 topics while receiving 1 topic from Node_B Note: A similar phenomenon will happen even if Callback c0 is a timer callback","title":"Message flow looks split"},{"location":"faq/#message-flow-looks-dropped","text":"Take the following system for example; Node_C publishes a topic when it receives a topic from Node_A Node_A publishes a topic with a rate of 10 Hz, while Node_B publishes a topic at 50 Hz Message flow ( Node_B -> Node_C -> Node_D ) looks disconnected at Node_C four times every five messages. It's because Node_C publishes 1 topic while receiving 5 topics from Node_B . So 4 topics don't have a corresponding topic to be published to Node_D Note: A similar phenomenon will happen even if Callback c0 is a timer callback","title":"Message flow looks dropped"},{"location":"faq/#how-response-time-is-calculated","text":"In general, response time is the time a system or functional unit takes to react to a given input ( reference ). Response time calculated by CARET is the time it takes for input data to arrive at the last node. It doesn't include processing time at the first/last node nor latency of an actuator. It's calculated as the sum of communication latency time (from the time when a node publishes a topic to the time when the following node subscribes the topic) and node latency time (from the time when a node subscribes a topic to the time when it publishes another topic) in a path In the following diagram, input data at point A is first reflected with output at point X ( ResponseTime_Best ) ResponseTime_Best can be considered as a path (dataflow) latency time ResponseTime_Best can be considered as a happy case, which is contrary to the following worst case scenario Assuming that input information is created by a sensor such as an object detection sensor, delay in a sensor should be considered. For instance, if a new object appears at point B, the time from point B to point A should added to the response time. The worst case scenario is that a new object appears just after the previous flow (point C). Response time for the worst case is shown as ResponseTime_Worst CARET can calculate both ResponseTime_Best and ResponseTime_Worst using the following APIs: response_time.to_best_case_timeseries() , response_time.to_best_case_histogram() response_time.to_worst_case_timeseries() , response_time.to_best_worst_histogram() CARET also provides response_time.to_histogram() API. It creates histogram assuming a new object appears from point C to point A at intervals of histogram bin size","title":"How response time is calculated?"},{"location":"installation/installation/","text":"Installation # Requirements # CARET is confirmed to run on the platforms shown in the following table with supported version. dependent platform supported version ROS Humble Ubuntu 22.04 LTTng stable-2.13 Linux Kernel 5.15.x Python3 3.10.x The recent version, after v0.3.0, of CARET supports only the combination of ROS 2 Humble and Ubuntu 22.04. If you want to run CARET on ROS 2 Galactic and Ubuntu 20.04, please refer to documents for v0.2.3 Installation # Installation using meta repository is the least time-consuming way to install CARET. With meta repository and Ansible, you can skip the laborious manual setup which is explained in manual installation(./manual_installation.md) section (written in Japanese). Please execute the following steps on Ubuntu 20.04. The order is important so that you have to follow the steps in order. Clone caret and enter the directory. git clone https://github.com/tier4/caret.git ros2_caret_ws cd ros2_caret_ws main branch is dedicated for ROS 2 Humble. If you want to use CARET for ROS 2 Galactic, please execute git checkout galactic in ros2_caret_ws directory. Create the src directory and clone repositories into it. CARET uses vcstool to construct workspaces. mkdir src vcs import src < caret.repos Run setup_caret.sh . ./setup_caret.sh Build the workspace. source /opt/ros/humble/setup.bash colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release Check whether CARET (ros2-tracing) is enabled. CARET inherits some functions from ros2-tracing . source ~/ros2_caret_ws/install/local_setup.bash ros2 run tracetools status # return Tracing enabled If you see Tracing enabled , you can continue to apply CARET to your application.","title":"Installation"},{"location":"installation/installation/#installation","text":"","title":"Installation"},{"location":"installation/installation/#requirements","text":"CARET is confirmed to run on the platforms shown in the following table with supported version. dependent platform supported version ROS Humble Ubuntu 22.04 LTTng stable-2.13 Linux Kernel 5.15.x Python3 3.10.x The recent version, after v0.3.0, of CARET supports only the combination of ROS 2 Humble and Ubuntu 22.04. If you want to run CARET on ROS 2 Galactic and Ubuntu 20.04, please refer to documents for v0.2.3","title":"Requirements"},{"location":"installation/installation/#installation_1","text":"Installation using meta repository is the least time-consuming way to install CARET. With meta repository and Ansible, you can skip the laborious manual setup which is explained in manual installation(./manual_installation.md) section (written in Japanese). Please execute the following steps on Ubuntu 20.04. The order is important so that you have to follow the steps in order. Clone caret and enter the directory. git clone https://github.com/tier4/caret.git ros2_caret_ws cd ros2_caret_ws main branch is dedicated for ROS 2 Humble. If you want to use CARET for ROS 2 Galactic, please execute git checkout galactic in ros2_caret_ws directory. Create the src directory and clone repositories into it. CARET uses vcstool to construct workspaces. mkdir src vcs import src < caret.repos Run setup_caret.sh . ./setup_caret.sh Build the workspace. source /opt/ros/humble/setup.bash colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release Check whether CARET (ros2-tracing) is enabled. CARET inherits some functions from ros2-tracing . source ~/ros2_caret_ws/install/local_setup.bash ros2 run tracetools status # return Tracing enabled If you see Tracing enabled , you can continue to apply CARET to your application.","title":"Installation"},{"location":"installation/manual_installation/","text":"Manual installation # \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb # LTTng \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb \u8a73\u7d30\u306f LTTng \u306e\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt-add-repository ppa:lttng/stable-2.12 sudo apt-get update sudo apt-get install lttng-tools liblttng-ust-dev sudo apt-get install python3-babeltrace python3-lttng ROS 2 Humble \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3001\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3002 \u8a73\u7d30\u306f ROS2 \u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt update && sudo apt install -y \\ build-essential \\ cmake \\ git \\ python3-colcon-common-extensions \\ python3-flake8 \\ python3-pip \\ python3-pytest-cov \\ python3-rosdep \\ python3-setuptools \\ python3-vcstool \\ python3-bt2 \\ wget python3 -m pip install -U \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest \\ setuptools \\ colorcet sudo apt install ros-humble-desktop ros2 trace \u95a2\u9023\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt install -y \\ ros-humble-ros2trace \\ ros-humble-ros2trace-analysis \\ ros-humble-tracetools \\ ros-humble-tracetools-analysis \\ ros-humble-tracetools-launch \\ ros-humble-tracetools-read \\ ros-humble-tracetools-test \\ ros-humble-tracetools-trace caret \u306e\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt update && sudo apt install -y \\ graphviz \\ graphviz-dev python3 -m pip install -U \\ pytest-mock \\ pybind11 \\ 'pandas>=1.4.0' \\ bokeh \\ pandas-bokeh \\ jupyterlab \\ graphviz # julyterlab\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u6642\u306b[ImportError: The Jupyter Server requires tornado >=6.1.0]\u3068\u51fa\u308b\u5834\u5408\u306f\u4ee5\u4e0b\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068 # pip install tornado --upgrade CARET \u306e\u30d3\u30eb\u30c9 # mkdir -p ~/ros2_caret_ws/src cd ~/ros2_caret_ws wget https://raw.githubusercontent.com/tier4/caret/main/caret.repos vcs import src < caret.repos rosdep install \\ --from-paths src --ignore-src \\ --rosdistro humble -y \\ --skip-keys \"console_bridge fastcdr fastrtps rti-connext-dds-5.3.1 urdfdom_headers\" # [ERROR: the following packages/stacks could not have their rosdep keys resolved] \u3068\u51fa\u308b\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u3092\u8a66\u3059\u3053\u3068 # rosdep init # rosdep update source /opt/ros/humble/setup.bash # \u30d5\u30a9\u30fc\u30af\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30d8\u30c3\u30c0\u30fc\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u7528\u3055\u305b\u308b\u305f\u3081\u306e\u30b7\u30f3\u30dc\u30ea\u30c3\u30af\u30ea\u30f3\u30af\u3092\u4f5c\u6210 ln -sf ~/ros2_caret_ws/src/ros-tracing/ros2_tracing/tracetools/include/tracetools ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_action/include/rclcpp_action ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_components/include/rclcpp_components/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_lifecycle/include/rclcpp_lifecycle/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ # CARET\u306e\u30d3\u30eb\u30c9 colcon build --cmake-args -DCMAKE_BUILD_TYPE = Release -DBUILD_TESTING = off --symlink-install ros2 tracing \u304c\u6709\u52b9\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d $ source ~/ros2_caret_ws/install/local_setup.bash $ ros2 run tracetools status Tracing enabled","title":"Manual Installation"},{"location":"installation/manual_installation/#manual-installation","text":"","title":"Manual installation"},{"location":"installation/manual_installation/#_1","text":"LTTng \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb \u8a73\u7d30\u306f LTTng \u306e\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt-add-repository ppa:lttng/stable-2.12 sudo apt-get update sudo apt-get install lttng-tools liblttng-ust-dev sudo apt-get install python3-babeltrace python3-lttng ROS 2 Humble \u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3001\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3002 \u8a73\u7d30\u306f ROS2 \u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8 \u3092\u53c2\u7167\u3002 sudo apt update && sudo apt install -y \\ build-essential \\ cmake \\ git \\ python3-colcon-common-extensions \\ python3-flake8 \\ python3-pip \\ python3-pytest-cov \\ python3-rosdep \\ python3-setuptools \\ python3-vcstool \\ python3-bt2 \\ wget python3 -m pip install -U \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest \\ setuptools \\ colorcet sudo apt install ros-humble-desktop ros2 trace \u95a2\u9023\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt install -y \\ ros-humble-ros2trace \\ ros-humble-ros2trace-analysis \\ ros-humble-tracetools \\ ros-humble-tracetools-analysis \\ ros-humble-tracetools-launch \\ ros-humble-tracetools-read \\ ros-humble-tracetools-test \\ ros-humble-tracetools-trace caret \u306e\u4f9d\u5b58\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb sudo apt update && sudo apt install -y \\ graphviz \\ graphviz-dev python3 -m pip install -U \\ pytest-mock \\ pybind11 \\ 'pandas>=1.4.0' \\ bokeh \\ pandas-bokeh \\ jupyterlab \\ graphviz # julyterlab\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u6642\u306b[ImportError: The Jupyter Server requires tornado >=6.1.0]\u3068\u51fa\u308b\u5834\u5408\u306f\u4ee5\u4e0b\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068 # pip install tornado --upgrade","title":"\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb"},{"location":"installation/manual_installation/#caret","text":"mkdir -p ~/ros2_caret_ws/src cd ~/ros2_caret_ws wget https://raw.githubusercontent.com/tier4/caret/main/caret.repos vcs import src < caret.repos rosdep install \\ --from-paths src --ignore-src \\ --rosdistro humble -y \\ --skip-keys \"console_bridge fastcdr fastrtps rti-connext-dds-5.3.1 urdfdom_headers\" # [ERROR: the following packages/stacks could not have their rosdep keys resolved] \u3068\u51fa\u308b\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u3092\u8a66\u3059\u3053\u3068 # rosdep init # rosdep update source /opt/ros/humble/setup.bash # \u30d5\u30a9\u30fc\u30af\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u30d8\u30c3\u30c0\u30fc\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u7528\u3055\u305b\u308b\u305f\u3081\u306e\u30b7\u30f3\u30dc\u30ea\u30c3\u30af\u30ea\u30f3\u30af\u3092\u4f5c\u6210 ln -sf ~/ros2_caret_ws/src/ros-tracing/ros2_tracing/tracetools/include/tracetools ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_action/include/rclcpp_action ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_components/include/rclcpp_components/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ ln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_lifecycle/include/rclcpp_lifecycle/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/ # CARET\u306e\u30d3\u30eb\u30c9 colcon build --cmake-args -DCMAKE_BUILD_TYPE = Release -DBUILD_TESTING = off --symlink-install ros2 tracing \u304c\u6709\u52b9\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d $ source ~/ros2_caret_ws/install/local_setup.bash $ ros2 run tracetools status Tracing enabled","title":"CARET \u306e\u30d3\u30eb\u30c9"},{"location":"recording/","text":"Recording with CARET # Steps to record trace data with CARET # Build a target application with CARET and check it ( See details ) (Optional) Configure trace filter ( See details ) Record the application ( See details ) Validate trace data ( See details ) Other tips # CLI tools ROS time (sim_time) support","title":"Recording"},{"location":"recording/#recording-with-caret","text":"","title":"Recording with CARET"},{"location":"recording/#steps-to-record-trace-data-with-caret","text":"Build a target application with CARET and check it ( See details ) (Optional) Configure trace filter ( See details ) Record the application ( See details ) Validate trace data ( See details )","title":"Steps to record trace data with CARET"},{"location":"recording/#other-tips","text":"CLI tools ROS time (sim_time) support","title":"Other tips"},{"location":"recording/build_check/","text":"Build with CARET # Build a target application with CARET # A target application should be built with CARET/rclcpp to record trace data. If you have already built the application without CARET/rclcpp, you have to build the application with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. Also, -DBUILD_TESTING=OFF should be given to build option. cd <path-to-workspace> source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after ROS 2's setup.bash colcon build --symlink-install --cmake-args -DBUILD_TESTING = OFF Reason for building a target application with CARET/rclcpp CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET. Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application. In order to apply rclcpp which has the additional tracepoints, the application have to be built with CARET/rclcpp again. Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as demo_nodes_cpp . If you want to trace such pre-build packages, please build them again from source code. Reason for giving -DBUILD_TESTING=OFF To use CARET, you need to use forked shared libraries and headers such as CARET/rclcpp. In the test codes, CARET/rclcpp is not available due to loading priority issues for headers. Depending on the version of CARET, conflicts may occur between the shared libraries of ros-rclcpp and the headers of CARET/rclcpp, resulting in compile errors. Therefore, test codes have to be excluded from building. Check whether CARET/rclcpp is applied to each package # You can check whether a target application is successfully built with CARET/rclcpp using ros2 caret check_caret_rclcpp command. ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Output Message Description All packages are built using caret-rclcpp There is no problem The following packages have not been built using caret-rclcpp CARET/rclcpp is not applied to the listed packages (Please read the next section to fix it) How to fix # In case CARET/rclcpp is not applied to the package you want to analyze, you need to fix it. The followings show possible causes and solutions. Case 1: All packages are listed as CARET/rclcpp is not applied Make sure you applied CARET's local_setup.bash after ROS2's setup.bash (keep the order) Case 2: Some, but not all, packages are listed as CARET/rclcpp is not applied Make sure you have the following line in package.xml in the listed package <depend>rclcpp</depend> Info The listed packages are not traced while other packages built with CARET/rclcpp are properly traced. Therefore, you can ignore this message if you don't need to trace/analyze the listed packages.","title":"Build and check"},{"location":"recording/build_check/#build-with-caret","text":"","title":"Build with CARET"},{"location":"recording/build_check/#build-a-target-application-with-caret","text":"A target application should be built with CARET/rclcpp to record trace data. If you have already built the application without CARET/rclcpp, you have to build the application with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. Also, -DBUILD_TESTING=OFF should be given to build option. cd <path-to-workspace> source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after ROS 2's setup.bash colcon build --symlink-install --cmake-args -DBUILD_TESTING = OFF Reason for building a target application with CARET/rclcpp CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET. Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application. In order to apply rclcpp which has the additional tracepoints, the application have to be built with CARET/rclcpp again. Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as demo_nodes_cpp . If you want to trace such pre-build packages, please build them again from source code. Reason for giving -DBUILD_TESTING=OFF To use CARET, you need to use forked shared libraries and headers such as CARET/rclcpp. In the test codes, CARET/rclcpp is not available due to loading priority issues for headers. Depending on the version of CARET, conflicts may occur between the shared libraries of ros-rclcpp and the headers of CARET/rclcpp, resulting in compile errors. Therefore, test codes have to be excluded from building.","title":"Build a target application with CARET"},{"location":"recording/build_check/#check-whether-caretrclcpp-is-applied-to-each-package","text":"You can check whether a target application is successfully built with CARET/rclcpp using ros2 caret check_caret_rclcpp command. ros2 caret check_caret_rclcpp --workspace <path-to-workspace> Output Message Description All packages are built using caret-rclcpp There is no problem The following packages have not been built using caret-rclcpp CARET/rclcpp is not applied to the listed packages (Please read the next section to fix it)","title":"Check whether CARET/rclcpp is applied to each package"},{"location":"recording/build_check/#how-to-fix","text":"In case CARET/rclcpp is not applied to the package you want to analyze, you need to fix it. The followings show possible causes and solutions. Case 1: All packages are listed as CARET/rclcpp is not applied Make sure you applied CARET's local_setup.bash after ROS2's setup.bash (keep the order) Case 2: Some, but not all, packages are listed as CARET/rclcpp is not applied Make sure you have the following line in package.xml in the listed package <depend>rclcpp</depend> Info The listed packages are not traced while other packages built with CARET/rclcpp are properly traced. Therefore, you can ignore this message if you don't need to trace/analyze the listed packages.","title":"How to fix"},{"location":"recording/cli_tool/","text":"CLI tools for recording # CARET provides CLI tools which can be utilized at recording process. Info CARET environment settings need to be performed to use these CLI tools by the following commands. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash Build results validation # This command checks whether a target application is successfully built with CARET/rclcpp. ( See details ) ros2 caret check_caret_rclcpp --workspace <path-to-workspace> ---Output text as below--- INFO : 2022 -09-29 20 :18:43 | All packages are built using caret-rclcpp. Trace data validation # This command checks whether a recording is successful. ( See details ) If there are problems with the recorded data, warning messages will be displayed ros2 caret check_ctf --trace_dir <path-to-trace-data> Node summary # This command displays the number of events per node. ros2 caret node_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= node_name | number_of_trace_points ----------------------+-------------------------- /message_driven_node | 4207 /timer_driven_node | 3630 /filter_node | 2680 /drive_node | 2146 /sensor_dummy_node | 2144 /actuator_dummy_node | 1609 Topic summary # This command displays the number of events per topic. ros2 caret topic_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= topic_name | number_of_trace_points -------------------+-------------------------- /drive | 2668 /topic1 | 2668 /topic2 | 2668 /topic4 | 2658 /topic3 | 2478 /parameter_events | 66 /rosout | 6 Info If the number of events is too huge to handle, trace filtering is a reasonable choice to exclude unnecessary nodes/topics based on the output result. Tracepoint summary # This command displays all tracepoints included in the trace data and the number of events collected by tracepoints. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 4216 ros2:callback_start | 4216 ros2_caret:dds_write | 2790 ros2_caret:dds_bind_addr_to_stamp | 2790 ros2:rcl_publish | 2650 ros2:rclcpp_publish | 2650 ros2:dispatch_subscription_callback | 2620 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0 Filtering for summary commands # Executing a summary command for huge trace data (e.g., more than 10 minutes) takes time. The following two options allow you to filter the load range of trace data used for summary output. In both options, the argument type is float and the unit of time is second. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --duration_filter <DURATION> <OFFSET> ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --strip_filter <LSTRIP> <RSTRIP> --duration_filter [DURATION] [OFFSET] Load only this [DURATION] from [OFFSET]. --strip_filter [LSTRIP] [RSTRIP] Ignore trace data for specified seconds from start/end. ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 Filtered trace range | 17 :34:15 ~ 17 :34:45 Filtered trace duration | 0 :00:29 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 2385 ros2:callback_start | 2385 ros2:dispatch_subscription_callback | 1485 ros2:rcl_publish | 1484 ros2_caret:dds_write | 1484 ros2_caret:dds_bind_addr_to_stamp | 1484 ros2:rclcpp_publish | 1484 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0","title":"CLI tools"},{"location":"recording/cli_tool/#cli-tools-for-recording","text":"CARET provides CLI tools which can be utilized at recording process. Info CARET environment settings need to be performed to use these CLI tools by the following commands. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash","title":"CLI tools for recording"},{"location":"recording/cli_tool/#build-results-validation","text":"This command checks whether a target application is successfully built with CARET/rclcpp. ( See details ) ros2 caret check_caret_rclcpp --workspace <path-to-workspace> ---Output text as below--- INFO : 2022 -09-29 20 :18:43 | All packages are built using caret-rclcpp.","title":"Build results validation"},{"location":"recording/cli_tool/#trace-data-validation","text":"This command checks whether a recording is successful. ( See details ) If there are problems with the recorded data, warning messages will be displayed ros2 caret check_ctf --trace_dir <path-to-trace-data>","title":"Trace data validation"},{"location":"recording/cli_tool/#node-summary","text":"This command displays the number of events per node. ros2 caret node_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= node_name | number_of_trace_points ----------------------+-------------------------- /message_driven_node | 4207 /timer_driven_node | 3630 /filter_node | 2680 /drive_node | 2146 /sensor_dummy_node | 2144 /actuator_dummy_node | 1609","title":"Node summary"},{"location":"recording/cli_tool/#topic-summary","text":"This command displays the number of events per topic. ros2 caret topic_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= topic_name | number_of_trace_points -------------------+-------------------------- /drive | 2668 /topic1 | 2668 /topic2 | 2668 /topic4 | 2658 /topic3 | 2478 /parameter_events | 66 /rosout | 6 Info If the number of events is too huge to handle, trace filtering is a reasonable choice to exclude unnecessary nodes/topics based on the output result.","title":"Topic summary"},{"location":"recording/cli_tool/#tracepoint-summary","text":"This command displays all tracepoints included in the trace data and the number of events collected by tracepoints. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 4216 ros2:callback_start | 4216 ros2_caret:dds_write | 2790 ros2_caret:dds_bind_addr_to_stamp | 2790 ros2:rcl_publish | 2650 ros2:rclcpp_publish | 2650 ros2:dispatch_subscription_callback | 2620 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0","title":"Tracepoint summary"},{"location":"recording/cli_tool/#filtering-for-summary-commands","text":"Executing a summary command for huge trace data (e.g., more than 10 minutes) takes time. The following two options allow you to filter the load range of trace data used for summary output. In both options, the argument type is float and the unit of time is second. ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --duration_filter <DURATION> <OFFSET> ros2 caret trace_point_summary --trace_dir <path-to-trace-data> --strip_filter <LSTRIP> <RSTRIP> --duration_filter [DURATION] [OFFSET] Load only this [DURATION] from [OFFSET]. --strip_filter [LSTRIP] [RSTRIP] Ignore trace data for specified seconds from start/end. ---Output text as below--- ============================================= Trace creation datetime | 2022 -07-16 17 :34:07 Trace range | 17 :34:07 ~ 17 :35:08 Trace duration | 0 :01:00 Filtered trace range | 17 :34:15 ~ 17 :34:45 Filtered trace duration | 0 :00:29 ============================================= trace_point | number_of_trace_points ---------------------------------------------------+-------------------------- ros2:callback_end | 2385 ros2:callback_start | 2385 ros2:dispatch_subscription_callback | 1485 ros2:rcl_publish | 1484 ros2_caret:dds_write | 1484 ros2_caret:dds_bind_addr_to_stamp | 1484 ros2:rclcpp_publish | 1484 ros2:rclcpp_subscription_callback_added | 44 ros2:rclcpp_service_callback_added | 44 ros2:rclcpp_callback_register | 44 ros2:rclcpp_timer_callback_added | 44 ros2_caret:callback_group_add_service | 36 ros2:rcl_service_init | 36 ros2:rcl_publisher_init | 17 ros2_caret:callback_group_add_subscription | 11 ros2:rcl_node_init | 6 ros2_caret:add_callback_group | 6 ros2:rcl_subscription_init | 5 ros2:rclcpp_subscription_init | 5 ros2:rcl_timer_init | 3 ros2:rclcpp_timer_link_node | 3 ros2_caret:callback_group_add_timer | 3 ros2_caret:construct_executor | 1 ros2_caret:rmw_implementation | 1 ros2:rcl_init | 1 ros2:rcl_client_init | 0 ros2:dispatch_intra_process_subscription_callback | 0 ros2_caret:tilde_subscribe_added | 0 ros2_caret:tilde_subscribe | 0 ros2_caret:tilde_publisher_init | 0 ros2_caret:tilde_publish | 0 ros2_caret:sim_time | 0 ros2_caret:on_data_available | 0 ros2:message_construct | 0 ros2_caret:dds_bind_addr_to_addr | 0 ros2_caret:construct_static_executor | 0 ros2:rclcpp_intra_publish | 0 ros2:rcl_lifecycle_transition | 0 ros2:rcl_lifecycle_state_machine_init | 0 ros2_caret:callback_group_add_client | 0 ros2_caret:add_callback_group_static_executor | 0 ros2_caret:tilde_subscription_init | 0","title":"Filtering for summary commands"},{"location":"recording/recording/","text":"Recording # Recording with CARET # CARET uses LTTng for tracing a target application. A LTTng session has to be started before running the application. This page explains two different ways for it: Starting LTTng session manually and Starting LTTng session using ROS launch system. Explanation in this page assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws . Starting LTTng session manually # Two terminals are needed for this method: One for starting a LTTng session, another for running a target application. Open a terminal and start a LTTng session with the following commands (Optional) ROS_TRACE_DIR variable is a destination directory where recorded trace data will be stored. Default is ~/.ros/tracing With \" -s \" option, you can give session name. The recorded trace data will be stored into ~/ros_ws/evaluate/e2e_sample in this sample Press \"Enter\" key to start a session source /opt/ros/humble/setup.bash # (Optional) Set a destination directory mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key Open another terminal and launch a target application Perform environment settings in the same order as below. CARET's local_setup.bash should be applied along with ROS 2's setup.bash as the target application refers to CARET/rclcpp # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash Set LD_PRELOAD to enable tracepoints provided by function hook export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) (Optional) Apply trace filtering . With configuration of trace filtering, CARET can ignore unnecessary nodes/topics. This function is useful for a large application # Apply filter directly export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Apply filter using a setting file source ./caret_topic_filter.bash Launch the target application ros2 run caret_demos end_to_end_sample Stop the target application Press \"Enter\" key to stop the LTTng session in the terminal where the LTTng session runs Info A LTTng session needs to be started before running a target application. Otherwise, some trace points won't be recorded and analysis will fail later. Info You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with ulimit -n command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; ulimit -n 65536 . Starting LTTng session via ROS launch # You can start LTTng session using ROS launch system. When you start a LTTng session in one terminal, you have to open another terminal for executing a target application as explained above. Operating multiple terminals is laborious for users. Launching LTTng session along with application by ROS launch is a reasonable way to apply CARET repeatedly. Create a launch file for a target application in ROS general manner if you haven't made it # launch/end_to_end_sample.launch.py import launch import launch_ros.actions def generate_launch_description (): return launch . LaunchDescription ([ launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Add description to start a LTTng session # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace def generate_launch_description (): return launch . LaunchDescription ([ Trace ( session_name = 'e2e_sample' , events_kernel = [], events_ust = [ 'ros2*' ] ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Launch a target application and a LTTng session via the launch file Environment settings are still needed, but all operations are performed in just one terminal source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) source ./caret_topic_filter.bash ros2 launch caret_demos end_to_end_sample_with_lttng_session.launch.py Advanced: Useful settings for launch file # The following script shows advanced settings for a launch file caret_session option is used to set a session name. If not assigned, datetime (YYYYMMDD-HHMMSS) is used caret_light option is used to add another event filter. Only events specified in caret_event variable are recorded. In this example, high level events, such as ros2:rclcpp layer, are recorded if caret_light is set to \"true\". This setting will be helpful to record a huge application. Please refer to tracepoint summary to find which events are recorded, and modify caret_event as you want. # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace import sys import datetime from distutils.util import strtobool def generate_launch_description (): caret_session = \"\" caret_event = [ \"ros2*\" ] caret_light = True for arg in sys . argv : if arg . startswith ( \"caret_session:=\" ): caret_session = arg . split ( \":=\" )[ 1 ] elif arg . startswith ( \"caret_light:=\" ): try : caret_light = strtobool ( arg . split ( \":=\" )[ 1 ]) # 0 or 1 except : print ( \"Invalid arguments 'caret_light'.\" ) print ( \"Start tracing with 'ros2*'.\" ) if caret_light : caret_event = [ \"ros2:*callback*\" , \"ros2:dispatch*\" , \"ros2:rclcpp*\" , \"ros2_caret:rmw*\" , \"*callback_group*\" , \"ros2_caret:*executor\" , \"ros2_caret:dds_bind*\" , \"ros2:rcl_*init\" ] if caret_session == \"\" : dt_now = datetime . datetime . now () caret_session = \"autoware_launch_trace_\" + dt_now . strftime ( \"%Y%m %d -%H%M%S\" ) return launch . LaunchDescription ([ Trace ( session_name = caret_session , events_kernel = [], events_ust = caret_event ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ])","title":"Recording"},{"location":"recording/recording/#recording","text":"","title":"Recording"},{"location":"recording/recording/#recording-with-caret","text":"CARET uses LTTng for tracing a target application. A LTTng session has to be started before running the application. This page explains two different ways for it: Starting LTTng session manually and Starting LTTng session using ROS launch system. Explanation in this page assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws .","title":"Recording with CARET"},{"location":"recording/recording/#starting-lttng-session-manually","text":"Two terminals are needed for this method: One for starting a LTTng session, another for running a target application. Open a terminal and start a LTTng session with the following commands (Optional) ROS_TRACE_DIR variable is a destination directory where recorded trace data will be stored. Default is ~/.ros/tracing With \" -s \" option, you can give session name. The recorded trace data will be stored into ~/ros_ws/evaluate/e2e_sample in this sample Press \"Enter\" key to start a session source /opt/ros/humble/setup.bash # (Optional) Set a destination directory mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key Open another terminal and launch a target application Perform environment settings in the same order as below. CARET's local_setup.bash should be applied along with ROS 2's setup.bash as the target application refers to CARET/rclcpp # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash Set LD_PRELOAD to enable tracepoints provided by function hook export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) (Optional) Apply trace filtering . With configuration of trace filtering, CARET can ignore unnecessary nodes/topics. This function is useful for a large application # Apply filter directly export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Apply filter using a setting file source ./caret_topic_filter.bash Launch the target application ros2 run caret_demos end_to_end_sample Stop the target application Press \"Enter\" key to stop the LTTng session in the terminal where the LTTng session runs Info A LTTng session needs to be started before running a target application. Otherwise, some trace points won't be recorded and analysis will fail later. Info You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with ulimit -n command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; ulimit -n 65536 .","title":"Starting LTTng session manually"},{"location":"recording/recording/#starting-lttng-session-via-ros-launch","text":"You can start LTTng session using ROS launch system. When you start a LTTng session in one terminal, you have to open another terminal for executing a target application as explained above. Operating multiple terminals is laborious for users. Launching LTTng session along with application by ROS launch is a reasonable way to apply CARET repeatedly. Create a launch file for a target application in ROS general manner if you haven't made it # launch/end_to_end_sample.launch.py import launch import launch_ros.actions def generate_launch_description (): return launch . LaunchDescription ([ launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Add description to start a LTTng session # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace def generate_launch_description (): return launch . LaunchDescription ([ Trace ( session_name = 'e2e_sample' , events_kernel = [], events_ust = [ 'ros2*' ] ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ]) Launch a target application and a LTTng session via the launch file Environment settings are still needed, but all operations are performed in just one terminal source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) source ./caret_topic_filter.bash ros2 launch caret_demos end_to_end_sample_with_lttng_session.launch.py","title":"Starting LTTng session via ROS launch"},{"location":"recording/recording/#advanced-useful-settings-for-launch-file","text":"The following script shows advanced settings for a launch file caret_session option is used to set a session name. If not assigned, datetime (YYYYMMDD-HHMMSS) is used caret_light option is used to add another event filter. Only events specified in caret_event variable are recorded. In this example, high level events, such as ros2:rclcpp layer, are recorded if caret_light is set to \"true\". This setting will be helpful to record a huge application. Please refer to tracepoint summary to find which events are recorded, and modify caret_event as you want. # launch/end_to_end_sample_with_lttng_session.launch.py import launch import launch_ros.actions from tracetools_launch.action import Trace import sys import datetime from distutils.util import strtobool def generate_launch_description (): caret_session = \"\" caret_event = [ \"ros2*\" ] caret_light = True for arg in sys . argv : if arg . startswith ( \"caret_session:=\" ): caret_session = arg . split ( \":=\" )[ 1 ] elif arg . startswith ( \"caret_light:=\" ): try : caret_light = strtobool ( arg . split ( \":=\" )[ 1 ]) # 0 or 1 except : print ( \"Invalid arguments 'caret_light'.\" ) print ( \"Start tracing with 'ros2*'.\" ) if caret_light : caret_event = [ \"ros2:*callback*\" , \"ros2:dispatch*\" , \"ros2:rclcpp*\" , \"ros2_caret:rmw*\" , \"*callback_group*\" , \"ros2_caret:*executor\" , \"ros2_caret:dds_bind*\" , \"ros2:rcl_*init\" ] if caret_session == \"\" : dt_now = datetime . datetime . now () caret_session = \"autoware_launch_trace_\" + dt_now . strftime ( \"%Y%m %d -%H%M%S\" ) return launch . LaunchDescription ([ Trace ( session_name = caret_session , events_kernel = [], events_ust = caret_event ), launch_ros . actions . Node ( package = 'caret_demos' , executable = 'end_to_end_sample' , output = 'screen' ), ])","title":"Advanced: Useful settings for launch file"},{"location":"recording/sim_time/","text":"ROS time (sim_time) support # Introduction # CARET uses system time to analyze trace data by default. It may be inconvenient, especially when treating trace data recorded with rosbag. These are examples: The flow of time in analysis results (e.g., time series graph) is different from that of ROS when playing rosbag with [-r RATE] option. For instance, 10 Hz becomes 2 Hz when rosbag was played with [-r 0.2] but analysis uses system time Time becomes different at every recording even if you use the same rosbag file, which makes comparing experimental results difficult This page explains how to use sim_time. Recording /clock topic # /clock topic needs to be recorded in trace data. /clock topis is recorded as ros2_caret:sim_time event in trace data. Open a new terminal and run the following commands before recording and running a target application. Info Remember to set use_sim_time=true for each node when launching a target application Remember to add --clock option when playing rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder You can check whether /clock is successfully recorded by the following command. babeltrace <path-to-trace-data> | cut -d ' ' -f 4 | sort -u | grep sim_time ---Expected output text as below--- ros2_caret:sim_time: Visualization using sim_time # By setting use_sim_time=True or xaxis_type='sim_time' , sim_time is used instead of system time for the following APIs. def callback_sched ( target : CallbackGroupTypes , lstrip_s : float = 0 , rstrip_s : float = 0 , coloring_rule : str = 'callback' , use_sim_time : bool = False , export_path : Optional [ str ] = None ) -> Figure : def message_flow ( path : Path , export_path : Optional [ str ] = None , granularity : Optional [ str ] = None , treat_drop_as_delay = False , lstrip_s : float = 0 , rstrip_s : float = 0 , use_sim_time : bool = False ) -> Figure : def show ( self , xaxis_type : str = 'system_time' , ywheel_zoom : bool = True , full_legends : bool = False , export_path : Optional [ str ] = None ) -> Figure : In case /clock topic is not recorded in trace data, the following error will occur. InvalidArgumentError : Failed to load sim_time . Please measure again with clock_recorder running . Sample to use sim_time # Explanation below assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws . Record rosbag # The following steps can be performed either with or without CARET. If you have built a target application without CARET, you don't need to set environment for CARET and LD_PRELOAD. Open a terminal to run a target application to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 run caret_demos end_to_end_sample Open another terminal to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag record /topic1 /drive Here, /topic1 and /drive are source topics of the sample application. You can check if rosbag is successfully recorded. ros2 bag info rosbag2_2022_09_30-10_57_06 Files: rosbag2_2022_09_30-10_57_06_0.db3 Bag size: 29 .3 KiB Storage id: sqlite3 Duration: 9 .601s Start: Sep 30 2022 10 :57:08.952 ( 1664503028 .952 ) End: Sep 30 2022 10 :57:18.554 ( 1664503038 .554 ) Messages: 194 Topic information: Topic: /drive | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr Topic: /topic1 | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr Record trace data # Open another terminal and run the following commands source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder Open another terminal to run a target application to record trace data with CARET In the launch file, use_sim_time is set to true and source nodes are disabled. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 launch caret_demos end_to_end_sample_with_lttng_session_use_sim.launch.py use_sim_time: = true use_rosbag: = true Open another terminal to play the rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag play rosbag2_2022_09_30-10_57_06 --clock -r 0 .2 Stop the application and the rosbag Check if /clock topic is recorded in trace data as sim_time babeltrace ~/ros2_ws/evaluate/e2e_sample | cut -d ' ' -f 4 | sort -u | grep sim_time ros2_caret:sim_time: Visualize results using sim_time # Launch Jupyter Notebook in ~/ros2_ws/evaluate and run the following scripts Reference: the tutorial from bokeh.plotting import output_notebook output_notebook () from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import Plot , message_flow # Read trace data arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) # Search and add path paths = arch . search_paths ( '/filter_node' , '/message_driven_node' ) arch . add_path ( 'target_path' , paths [ 0 ]) app = Application ( arch , lttng ) # Draw message_flow path = app . get_path ( 'target_path' ) message_flow ( path , use_sim_time = True ) # Draw node info node = app . get_node ( '/filter_node' ) plot = Plot . create_callback_period_plot ( node ) plot . show ( 'sim_time' )","title":"ROS time (sim_time) support"},{"location":"recording/sim_time/#ros-time-sim_time-support","text":"","title":"ROS time (sim_time) support"},{"location":"recording/sim_time/#introduction","text":"CARET uses system time to analyze trace data by default. It may be inconvenient, especially when treating trace data recorded with rosbag. These are examples: The flow of time in analysis results (e.g., time series graph) is different from that of ROS when playing rosbag with [-r RATE] option. For instance, 10 Hz becomes 2 Hz when rosbag was played with [-r 0.2] but analysis uses system time Time becomes different at every recording even if you use the same rosbag file, which makes comparing experimental results difficult This page explains how to use sim_time.","title":"Introduction"},{"location":"recording/sim_time/#recording-clock-topic","text":"/clock topic needs to be recorded in trace data. /clock topis is recorded as ros2_caret:sim_time event in trace data. Open a new terminal and run the following commands before recording and running a target application. Info Remember to set use_sim_time=true for each node when launching a target application Remember to add --clock option when playing rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder You can check whether /clock is successfully recorded by the following command. babeltrace <path-to-trace-data> | cut -d ' ' -f 4 | sort -u | grep sim_time ---Expected output text as below--- ros2_caret:sim_time:","title":"Recording /clock topic"},{"location":"recording/sim_time/#visualization-using-sim_time","text":"By setting use_sim_time=True or xaxis_type='sim_time' , sim_time is used instead of system time for the following APIs. def callback_sched ( target : CallbackGroupTypes , lstrip_s : float = 0 , rstrip_s : float = 0 , coloring_rule : str = 'callback' , use_sim_time : bool = False , export_path : Optional [ str ] = None ) -> Figure : def message_flow ( path : Path , export_path : Optional [ str ] = None , granularity : Optional [ str ] = None , treat_drop_as_delay = False , lstrip_s : float = 0 , rstrip_s : float = 0 , use_sim_time : bool = False ) -> Figure : def show ( self , xaxis_type : str = 'system_time' , ywheel_zoom : bool = True , full_legends : bool = False , export_path : Optional [ str ] = None ) -> Figure : In case /clock topic is not recorded in trace data, the following error will occur. InvalidArgumentError : Failed to load sim_time . Please measure again with clock_recorder running .","title":"Visualization using sim_time"},{"location":"recording/sim_time/#sample-to-use-sim_time","text":"Explanation below assumes CARET is installed to ~/ros2_caret_ws and the sample application used in the tutorial section is located in ~/ros2_ws .","title":"Sample to use sim_time"},{"location":"recording/sim_time/#record-rosbag","text":"The following steps can be performed either with or without CARET. If you have built a target application without CARET, you don't need to set environment for CARET and LD_PRELOAD. Open a terminal to run a target application to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 run caret_demos end_to_end_sample Open another terminal to record rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag record /topic1 /drive Here, /topic1 and /drive are source topics of the sample application. You can check if rosbag is successfully recorded. ros2 bag info rosbag2_2022_09_30-10_57_06 Files: rosbag2_2022_09_30-10_57_06_0.db3 Bag size: 29 .3 KiB Storage id: sqlite3 Duration: 9 .601s Start: Sep 30 2022 10 :57:08.952 ( 1664503028 .952 ) End: Sep 30 2022 10 :57:18.554 ( 1664503038 .554 ) Messages: 194 Topic information: Topic: /drive | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr Topic: /topic1 | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr","title":"Record rosbag"},{"location":"recording/sim_time/#record-trace-data","text":"Open another terminal and run the following commands source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash ros2 run caret_trace clock_recorder Open another terminal to run a target application to record trace data with CARET In the launch file, use_sim_time is set to true and source nodes are disabled. source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) ros2 launch caret_demos end_to_end_sample_with_lttng_session_use_sim.launch.py use_sim_time: = true use_rosbag: = true Open another terminal to play the rosbag source /opt/ros/humble/setup.bash source ~/ros2_ws/install/local_setup.bash ros2 bag play rosbag2_2022_09_30-10_57_06 --clock -r 0 .2 Stop the application and the rosbag Check if /clock topic is recorded in trace data as sim_time babeltrace ~/ros2_ws/evaluate/e2e_sample | cut -d ' ' -f 4 | sort -u | grep sim_time ros2_caret:sim_time:","title":"Record trace data"},{"location":"recording/sim_time/#visualize-results-using-sim_time","text":"Launch Jupyter Notebook in ~/ros2_ws/evaluate and run the following scripts Reference: the tutorial from bokeh.plotting import output_notebook output_notebook () from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import Plot , message_flow # Read trace data arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) # Search and add path paths = arch . search_paths ( '/filter_node' , '/message_driven_node' ) arch . add_path ( 'target_path' , paths [ 0 ]) app = Application ( arch , lttng ) # Draw message_flow path = app . get_path ( 'target_path' ) message_flow ( path , use_sim_time = True ) # Draw node info node = app . get_node ( '/filter_node' ) plot = Plot . create_callback_period_plot ( node ) plot . show ( 'sim_time' )","title":"Visualize results using sim_time"},{"location":"recording/trace_filtering/","text":"Trace filtering # Trace filtering # CARET provides a trace filtering function to exclude specific nodes and topics. Trace data may be discarded when recording a large application like Autoware due to too many data to be recorded, and a warning will occur when validating/analyzing the recorded trace data (See validating ). By applying trace filter, unconcerned events like /tf are ignored and the size of recorded data decreases. Trace filter configuration # Trace filter configuration is performed by setting the following environment variables CARET_SELECT_NODES : node names to be recorded CARET_IGNORE_NODES : node names to be ignored CARET_SELECT_TOPICS : topic names to be recorded CARET_IGNORE_TOPICS : topic names to be ignored \"SELECT\" settings override \"IGNORE\" settings if both are used Colon \" : \" is used to set more than one nodes/topics Regular expressions are supported These variables need to be set in the same terminal as a target application running In most cases, nodes related to /rviz , /clock topic and /parameter_events topic are unnecessary to analyze an application. It's recommended to ignore these nodes/topics The following shows sample settings export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" Info Trace filter doesn't exclude all events of the specified nodes/topics. Events in certain layers, especially DDS layer, won't be ignored.It is one of limitations with current implementation. Trace filter setting file # It will be handy to prepare a trace filter setting file like the following. # caret_topic_filter.bash #!/bin/bash export CARET_IGNORE_NODES = \\ \"\\ /rviz*\\ \" export CARET_IGNORE_TOPICS = \\ \"\\ /clock:\\ /parameter_events\\ \" # if you want to select nodes or topics, # please remove comment out of the followings. # export CARET_SELECT_NODES=\\ # \"\\ # /rviz*\\ # \" # export CARET_SELECT_TOPICS=\\ # \"\\ # /clock:\\ # /parameter_events\\ # \"","title":"Trace filtering"},{"location":"recording/trace_filtering/#trace-filtering","text":"","title":"Trace filtering"},{"location":"recording/trace_filtering/#trace-filtering_1","text":"CARET provides a trace filtering function to exclude specific nodes and topics. Trace data may be discarded when recording a large application like Autoware due to too many data to be recorded, and a warning will occur when validating/analyzing the recorded trace data (See validating ). By applying trace filter, unconcerned events like /tf are ignored and the size of recorded data decreases.","title":"Trace filtering"},{"location":"recording/trace_filtering/#trace-filter-configuration","text":"Trace filter configuration is performed by setting the following environment variables CARET_SELECT_NODES : node names to be recorded CARET_IGNORE_NODES : node names to be ignored CARET_SELECT_TOPICS : topic names to be recorded CARET_IGNORE_TOPICS : topic names to be ignored \"SELECT\" settings override \"IGNORE\" settings if both are used Colon \" : \" is used to set more than one nodes/topics Regular expressions are supported These variables need to be set in the same terminal as a target application running In most cases, nodes related to /rviz , /clock topic and /parameter_events topic are unnecessary to analyze an application. It's recommended to ignore these nodes/topics The following shows sample settings export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" Info Trace filter doesn't exclude all events of the specified nodes/topics. Events in certain layers, especially DDS layer, won't be ignored.It is one of limitations with current implementation.","title":"Trace filter configuration"},{"location":"recording/trace_filtering/#trace-filter-setting-file","text":"It will be handy to prepare a trace filter setting file like the following. # caret_topic_filter.bash #!/bin/bash export CARET_IGNORE_NODES = \\ \"\\ /rviz*\\ \" export CARET_IGNORE_TOPICS = \\ \"\\ /clock:\\ /parameter_events\\ \" # if you want to select nodes or topics, # please remove comment out of the followings. # export CARET_SELECT_NODES=\\ # \"\\ # /rviz*\\ # \" # export CARET_SELECT_TOPICS=\\ # \"\\ # /clock:\\ # /parameter_events\\ # \"","title":"Trace filter setting file"},{"location":"recording/use_sim_time/","text":"sim_time \u3067\u306e\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u8a55\u4fa1 # CARET \u306e\u30c7\u30d5\u30a9\u30eb\u30c8\uff08LTTng\uff09\u3067\u306f\u3001\u30b7\u30b9\u30c6\u30e0\u6642\u9593\u3067\u6e2c\u5b9a\u7d50\u679c\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002 \u3053\u306e\u5834\u5408\u3001\u540c\u3058\u6761\u4ef6\u3067\u7e70\u308a\u8fd4\u3057\u6e2c\u5b9a\u3059\u308b\u5834\u5408\u306a\u3069\u3067\u306f\u3001\u6642\u9593\u304c\u30ba\u30ec\u3066\u3057\u307e\u3044\u3001\u4e26\u3079\u3066\u6bd4\u8f03\u3059\u308b\u306e\u304c\u56f0\u96e3\u3067\u3059\u3002 \u305d\u306e\u3088\u3046\u306a\u5834\u5408\u306b\u306f\u3001sim_time \u3067\u6642\u523b\u3092\u4e00\u81f4\u3055\u305b\u308b\u3053\u3068\u3067\u3001\u540c\u6761\u4ef6\u4e0b\u3067\u306e\u8a55\u4fa1\u304c\u53ef\u80fd\u306b\u306a\u308a\u307e\u3059\u3002 \u672c\u30da\u30fc\u30b8\u3067\u306f\u3001\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306e\u6642\u523b\u3092 sim_time \u306b\u6642\u523b\u3092\u63c3\u3048\u3066\u8a55\u4fa1\u3059\u308b\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u307e\u3059\u3002 sim_time \u306e\u8a18\u9332 # sim_time \u3092\u4f7f\u3063\u305f\u8a55\u4fa1\u3092\u884c\u3046\u969b\u306b\u306f\u3001\u6e2c\u5b9a\u6642\u306b\u7279\u5b9a\u306e\u30ce\u30fc\u30c9\u3092\u5b9f\u884c\u3055\u305b\u3066\u304a\u304f\u5fc5\u8981\u304c\u6709\u308a\u307e\u3059\u3002 ros2 run caret_trace clock_recorder clock_recorder \u30ce\u30fc\u30c9\u3092\u8d77\u52d5\u3055\u305b\u3066\u304a\u304f\u3053\u3068\u3067\u3001 ros2_caret:simime \u30c8\u30ec\u30fc\u30b9\u304c\u6709\u52b9\u306b\u306a\u308a\u307e\u3059\u3002 \u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u3067\u3001\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u304c\u8a18\u9332\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002 $ babeltrace ~/.ros/tracing/ctf_path | cut -d ' ' -f 4 | sort -u | grep sim_time ros2_caret:sim_time: \u306a\u304a\u3001sim_time \u306f /clock \u30c8\u30d4\u30c3\u30af\u304c publish \u3055\u308c\u3066\u3044\u308b\u9593\u306e\u307f\u8a18\u9332\u3055\u308c\u307e\u3059\u3002 sim_time \u3092\u4f7f\u3063\u305f\u53ef\u8996\u5316 # caret_analyze.plot \u914d\u4e0b\u306e\u53ef\u8996\u5316\u3067\u306f\u3001\u6642\u9593\u8ef8\u3092 sim_time \u306b\u3057\u305f\u53ef\u8996\u5316\u304c\u53ef\u80fd\u3067\u3059\u3002 \u6700\u65b0\u7248 v.0.2.1 \u3067\u306f\u3001 callback_sched \u3068 message_flow \u304c sim_time \u306e\u6642\u523b\u3092\u4f7f\u7528\u3057\u305f\u53ef\u8996\u5316\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\u3002 def callback_sched ( target : Union [ Node , CallbackGroup , Executor ], lstrip_s : float = 0 , rstrip_s : float = 0 , coloring_rule = 'callback' , use_sim_time : bool = False ) ): def message_flow ( path : Path , export_path : Optional [ str ] = None , granularity : Optional [ str ] = None , lstrip_s : float = 0 , rstrip_s : float = 0 , use_sim_time : bool = False ) \u30aa\u30d7\u30b7\u30e7\u30f3\u5f15\u6570\u306e use_sim_time = True \u3068\u3059\u308b\u3053\u3068\u3067\u3001\u6a2a\u8ef8\u304c sim_time \u306e\u30b0\u30e9\u30d5\u3092\u63cf\u753b\u3067\u304d\u307e\u3059\u3002 \u306a\u304a\u3001 ros2_caret:sim_time \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u306b\u306f\u3001\u30a8\u30e9\u30fc\u304c\u51fa\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002","title":"sim_time \u3067\u306e\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u8a55\u4fa1"},{"location":"recording/use_sim_time/#sim_time","text":"CARET \u306e\u30c7\u30d5\u30a9\u30eb\u30c8\uff08LTTng\uff09\u3067\u306f\u3001\u30b7\u30b9\u30c6\u30e0\u6642\u9593\u3067\u6e2c\u5b9a\u7d50\u679c\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002 \u3053\u306e\u5834\u5408\u3001\u540c\u3058\u6761\u4ef6\u3067\u7e70\u308a\u8fd4\u3057\u6e2c\u5b9a\u3059\u308b\u5834\u5408\u306a\u3069\u3067\u306f\u3001\u6642\u9593\u304c\u30ba\u30ec\u3066\u3057\u307e\u3044\u3001\u4e26\u3079\u3066\u6bd4\u8f03\u3059\u308b\u306e\u304c\u56f0\u96e3\u3067\u3059\u3002 \u305d\u306e\u3088\u3046\u306a\u5834\u5408\u306b\u306f\u3001sim_time \u3067\u6642\u523b\u3092\u4e00\u81f4\u3055\u305b\u308b\u3053\u3068\u3067\u3001\u540c\u6761\u4ef6\u4e0b\u3067\u306e\u8a55\u4fa1\u304c\u53ef\u80fd\u306b\u306a\u308a\u307e\u3059\u3002 \u672c\u30da\u30fc\u30b8\u3067\u306f\u3001\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u306e\u6642\u523b\u3092 sim_time \u306b\u6642\u523b\u3092\u63c3\u3048\u3066\u8a55\u4fa1\u3059\u308b\u65b9\u6cd5\u3092\u8aac\u660e\u3057\u307e\u3059\u3002","title":"sim_time \u3067\u306e\u6642\u7cfb\u5217\u30c7\u30fc\u30bf\u8a55\u4fa1"},{"location":"recording/use_sim_time/#sim_time_1","text":"sim_time \u3092\u4f7f\u3063\u305f\u8a55\u4fa1\u3092\u884c\u3046\u969b\u306b\u306f\u3001\u6e2c\u5b9a\u6642\u306b\u7279\u5b9a\u306e\u30ce\u30fc\u30c9\u3092\u5b9f\u884c\u3055\u305b\u3066\u304a\u304f\u5fc5\u8981\u304c\u6709\u308a\u307e\u3059\u3002 ros2 run caret_trace clock_recorder clock_recorder \u30ce\u30fc\u30c9\u3092\u8d77\u52d5\u3055\u305b\u3066\u304a\u304f\u3053\u3068\u3067\u3001 ros2_caret:simime \u30c8\u30ec\u30fc\u30b9\u304c\u6709\u52b9\u306b\u306a\u308a\u307e\u3059\u3002 \u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u3067\u3001\u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u304c\u8a18\u9332\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002 $ babeltrace ~/.ros/tracing/ctf_path | cut -d ' ' -f 4 | sort -u | grep sim_time ros2_caret:sim_time: \u306a\u304a\u3001sim_time \u306f /clock \u30c8\u30d4\u30c3\u30af\u304c publish \u3055\u308c\u3066\u3044\u308b\u9593\u306e\u307f\u8a18\u9332\u3055\u308c\u307e\u3059\u3002","title":"sim_time \u306e\u8a18\u9332"},{"location":"recording/use_sim_time/#sim_time_2","text":"caret_analyze.plot \u914d\u4e0b\u306e\u53ef\u8996\u5316\u3067\u306f\u3001\u6642\u9593\u8ef8\u3092 sim_time \u306b\u3057\u305f\u53ef\u8996\u5316\u304c\u53ef\u80fd\u3067\u3059\u3002 \u6700\u65b0\u7248 v.0.2.1 \u3067\u306f\u3001 callback_sched \u3068 message_flow \u304c sim_time \u306e\u6642\u523b\u3092\u4f7f\u7528\u3057\u305f\u53ef\u8996\u5316\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\u3002 def callback_sched ( target : Union [ Node , CallbackGroup , Executor ], lstrip_s : float = 0 , rstrip_s : float = 0 , coloring_rule = 'callback' , use_sim_time : bool = False ) ): def message_flow ( path : Path , export_path : Optional [ str ] = None , granularity : Optional [ str ] = None , lstrip_s : float = 0 , rstrip_s : float = 0 , use_sim_time : bool = False ) \u30aa\u30d7\u30b7\u30e7\u30f3\u5f15\u6570\u306e use_sim_time = True \u3068\u3059\u308b\u3053\u3068\u3067\u3001\u6a2a\u8ef8\u304c sim_time \u306e\u30b0\u30e9\u30d5\u3092\u63cf\u753b\u3067\u304d\u307e\u3059\u3002 \u306a\u304a\u3001 ros2_caret:sim_time \u30c8\u30ec\u30fc\u30b9\u30dd\u30a4\u30f3\u30c8\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u306b\u306f\u3001\u30a8\u30e9\u30fc\u304c\u51fa\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002","title":"sim_time \u3092\u4f7f\u3063\u305f\u53ef\u8996\u5316"},{"location":"recording/validating/","text":"Validating trace data # Validating trace data # You can check whether a recording is successful with ros2 caret check_ctf command. ros2 caret check_ctf -d <path-to-trace-data> Info Executing the ros2 caret check_ctf command for long recorded data or recorded data of a large application takes a long time. Therefore, it is recommended to execute the ros2 caret check_ctf command on a short duration of recorded data before long-time recording. Also, It's recommended to record and validate trace data when you build a target application, so that you can modify code to avoid the following warnings. Info You can ignore warnings caused by Python and libraries Warnings due to wrong procedure # Failed to find trace point added by caret-rclcpp # Cause CARET/rclcpp is not applied when you built a target application Solution Build the application with CARET (See build section ) Failed to find trace point added by LD_PRELOAD # Cause Hooked tracepoints were not found. LD_PRELOAD may be missed Solution Set LD_PRELOAD before running the application (See recording section ) Tracer discarded # Cause Trace data lost occurred while recording due to too many trace data This warning will be observed in some case, especially when applying CARET to a large application Details LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents . After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded. Solution Apply trace filter, or modify trace filter setting to ignore more topics/nodes (See trace filtering section ) especially, filtering highly-frequent nodes and topics is effective highly-frequent nodes/topics can be identified by checking the summary of trace data Increase size of ring-buffer in CARET if a target device has enough memory example Warnings due to CARET limitations # CARET identifies callback functions using the following parameters. In case a node has several callback functions whose parameters are identical, such node is ignored because CARET cannot analyze it. Timer callback functions: timer period Subscription callback functions: topic name Duplicate parameter callback found # Cause Several timer callback functions which have the same timer period exist in a node In other words, rclcpp::create_timer() with the same timer period is called more than once Solution (workaround) Modify code to avoid using the same timer period (You can slightly change timer period value) Or, this warning can be ignored unless the node needs to be analyzed Failed to identify subscription. Several candidates were found # Cause Several subscription callback functions which have the same topic name exist in a node In other words, rclcpp::create_subscription() with the same topic name is called more than once Solution (workaround) Modify code to avoid creating more than one subscription callback function with the same topic name Multiple executors using the same callback group were detected # Cause A callback group is added to several executors Solution There is no solution at the moment. CARET uses the last executor to analyze. This warning can be ignored in most cases Failed to find callback group # Cause CARET failed to bind callback groups, callbacks and executors. It mainly because of ROS 2 \"service\". \"Service\" is not supported by CARET Solution There is no solution at the moment. This warning can be ignored in most cases","title":"Validating"},{"location":"recording/validating/#validating-trace-data","text":"","title":"Validating trace data"},{"location":"recording/validating/#validating-trace-data_1","text":"You can check whether a recording is successful with ros2 caret check_ctf command. ros2 caret check_ctf -d <path-to-trace-data> Info Executing the ros2 caret check_ctf command for long recorded data or recorded data of a large application takes a long time. Therefore, it is recommended to execute the ros2 caret check_ctf command on a short duration of recorded data before long-time recording. Also, It's recommended to record and validate trace data when you build a target application, so that you can modify code to avoid the following warnings. Info You can ignore warnings caused by Python and libraries","title":"Validating trace data"},{"location":"recording/validating/#warnings-due-to-wrong-procedure","text":"","title":"Warnings due to wrong procedure"},{"location":"recording/validating/#failed-to-find-trace-point-added-by-caret-rclcpp","text":"Cause CARET/rclcpp is not applied when you built a target application Solution Build the application with CARET (See build section )","title":"Failed to find trace point added by caret-rclcpp"},{"location":"recording/validating/#failed-to-find-trace-point-added-by-ld_preload","text":"Cause Hooked tracepoints were not found. LD_PRELOAD may be missed Solution Set LD_PRELOAD before running the application (See recording section )","title":"Failed to find trace point added by LD_PRELOAD"},{"location":"recording/validating/#tracer-discarded","text":"Cause Trace data lost occurred while recording due to too many trace data This warning will be observed in some case, especially when applying CARET to a large application Details LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents . After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded. Solution Apply trace filter, or modify trace filter setting to ignore more topics/nodes (See trace filtering section ) especially, filtering highly-frequent nodes and topics is effective highly-frequent nodes/topics can be identified by checking the summary of trace data Increase size of ring-buffer in CARET if a target device has enough memory example","title":"Tracer discarded"},{"location":"recording/validating/#warnings-due-to-caret-limitations","text":"CARET identifies callback functions using the following parameters. In case a node has several callback functions whose parameters are identical, such node is ignored because CARET cannot analyze it. Timer callback functions: timer period Subscription callback functions: topic name","title":"Warnings due to CARET limitations"},{"location":"recording/validating/#duplicate-parameter-callback-found","text":"Cause Several timer callback functions which have the same timer period exist in a node In other words, rclcpp::create_timer() with the same timer period is called more than once Solution (workaround) Modify code to avoid using the same timer period (You can slightly change timer period value) Or, this warning can be ignored unless the node needs to be analyzed","title":"Duplicate parameter callback found"},{"location":"recording/validating/#failed-to-identify-subscription-several-candidates-were-found","text":"Cause Several subscription callback functions which have the same topic name exist in a node In other words, rclcpp::create_subscription() with the same topic name is called more than once Solution (workaround) Modify code to avoid creating more than one subscription callback function with the same topic name","title":"Failed to identify subscription. Several candidates were found"},{"location":"recording/validating/#multiple-executors-using-the-same-callback-group-were-detected","text":"Cause A callback group is added to several executors Solution There is no solution at the moment. CARET uses the last executor to analyze. This warning can be ignored in most cases","title":"Multiple executors using the same callback group were detected"},{"location":"recording/validating/#failed-to-find-callback-group","text":"Cause CARET failed to bind callback groups, callbacks and executors. It mainly because of ROS 2 \"service\". \"Service\" is not supported by CARET Solution There is no solution at the moment. This warning can be ignored in most cases","title":"Failed to find callback group"},{"location":"tutorials/configuration/","text":"Configuration for measuring node and path latency # CARET can observe as following: callback latency communication latency (inter-node) node latency (intra-node) path latency (intra-node & inter-node) The following figure shows definition of node latency and path latency. Callback latency can be defined as execution time of a callback function and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in a application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configuration file, called \" architecture file \". Overview of an architecture file # An architecture file has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can create a template architecture file including only application structure section. The application structure section remains same unless the structure is changed or component is renamed. On the other hand, latency definition section in the template architecture file is empty just before users add any definition. Users are expected to add definitions of node latency and path latency in the template file. CARET helps users to add definition of path latency with Python API. However, users have to add definition of node latency manually with editing the architecture file. The following sections explains how to create an architecture file and add latency definition. How to generate an architecture file # This section explains how to generate an architecture file which has minimum description. Launch Jupyter Notebook (Jupyter Lab) mkdir -p ~/ros2_ws/evaluate && cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab Generate an architecture file from recorded data as below from caret_analyze import Architecture # Read description of application's architecture from recorded data arch = Architecture ( 'lttng' , './e2e_sample' ) # Save description as an architecture file arch . export ( 'architecture.yaml' ) # Check if the architecture file is created ! readlink - f ./ architecture . yaml # /home/user/ros2_caret_ws/eval/architecture.yaml How to define a target path # Load the yaml-based architecture file as below from caret_analyze import Architecture , check_procedure arch = Architecture ( 'yaml' , './architecture.yaml' ) Choose source node and destination node in a path arch.search_paths extract all candidates of the path paths = arch . search_paths ( '/sensor_dummy_node' , # source node '/actuator_dummy_node' ) # destination node If a target application is large and complicated, arch.search_paths method may consume time more than 1 minute. For decreasing consumed time, you can ignore nodes and topics and specify depth of search. Refer to \u30d1\u30b9\u306e\u63a2\u7d22\u65b9\u6cd5 for more details. Check the path as you expected You will find multiple candidates of the path. You can check which candidate is expected as target. The following code is an example for users to check path = paths [ 0 ] path . summary . pprint () --- Output text as below --- path : - message_context : null # for definition of node latency node : / sensor_dummy_node - topic : / topic1 - message_context : publisher_topic_name : / topic2 subscription_topic_name : / topic1 type : callback_chain node : / filter_node - topic : / topic2 - message_context : null node : / message_driven_node - topic : / topic3 - message_context : null node : / timer_driven_node - topic : / topic4 - message_context : null node : / actuator_dummy_node Give a name to selected path and update architecture file arch . add_path ( 'target_path' , path ) arch . export ( './architecture.yaml' , force = True ) The updated architecture file describes the path named as target_path . named_paths : - path_name : target_path node_chain : - node_name : /sensor_dummy_node publish_topic_name : /topic1 subscribe_topic_name : UNDEFINED - node_name : /filter_node publish_topic_name : /topic2 subscribe_topic_name : /topic1 - node_name : /message_driven_node publish_topic_name : /topic3 subscribe_topic_name : /topic2 - node_name : /timer_driven_node publish_topic_name : /topic4 subscribe_topic_name : /topic3 - node_name : /actuator_dummy_node publish_topic_name : UNDEFINED subscribe_topic_name : /topic4 How to define latency of a single node # Latency of a single node, so called \"node latency\", is defined as elapsed time from 1. starting time to 2. publishing time as below. starting time when node subscribes topic message and invokes a corresponding callback function publishing time when node publishes topic message Definition of node latency depends on implementation pattern. Some nodes subscribe input messages and invoke callback function where they publish output messages. These nodes has direct relationship between input and output. Other nodes subscribe input messages and invoke callback functions where they buffer them, and invoke different callback functions consume input messages and publish output message. In the latter cases, relationship of input and output is indirect, and intra-node communication is performed with using multiple callback functions. message_filters is another cause to increase the number of implementation patterns. Therefore, CARET has to deal with several types of node implementation to measure node latency. CARET serve a function to define node latency with an architecture file. An architecture file has an item of message_context , which indicates relation between input message and output message. This item should be defined by users as below. Check which node latency should be configured path.verify() method, as shown in the following example, tells you which node latency should be defined. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () --- Output text as below --- WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 In the example, path.verify() tells you two nodes have undefined relationships of input and output. input /topic2 and output /topic3 in node /message_driven_node input /topic3 and output /topic4 in node /timer_driven_node Their relationships must be explicit with corresponding message_context items in the architecture file. Define relationship between input and output You have to change message_contexts items as below for the sample. # in /message_driven_node message_contexts : - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic2 publisher_topic_name : /topic3 # in /timer_driven_node message_contexts :\u3000 - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic3 publisher_topic_name : /topic4 Check if node latency is defined path.verify() tells you that there is no undefined node latency in the path. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () If path.verify() returns True , CARET can calculate latency of the path. Otherwise, there is any lack of definition to calculate latency. Todo We'll provide the sample architecture file here, but it's not ready. Sorry for inconvenience.","title":"Configuration"},{"location":"tutorials/configuration/#configuration-for-measuring-node-and-path-latency","text":"CARET can observe as following: callback latency communication latency (inter-node) node latency (intra-node) path latency (intra-node & inter-node) The following figure shows definition of node latency and path latency. Callback latency can be defined as execution time of a callback function and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in a application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configuration file, called \" architecture file \".","title":"Configuration for measuring node and path latency"},{"location":"tutorials/configuration/#overview-of-an-architecture-file","text":"An architecture file has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can create a template architecture file including only application structure section. The application structure section remains same unless the structure is changed or component is renamed. On the other hand, latency definition section in the template architecture file is empty just before users add any definition. Users are expected to add definitions of node latency and path latency in the template file. CARET helps users to add definition of path latency with Python API. However, users have to add definition of node latency manually with editing the architecture file. The following sections explains how to create an architecture file and add latency definition.","title":"Overview of an architecture file"},{"location":"tutorials/configuration/#how-to-generate-an-architecture-file","text":"This section explains how to generate an architecture file which has minimum description. Launch Jupyter Notebook (Jupyter Lab) mkdir -p ~/ros2_ws/evaluate && cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab Generate an architecture file from recorded data as below from caret_analyze import Architecture # Read description of application's architecture from recorded data arch = Architecture ( 'lttng' , './e2e_sample' ) # Save description as an architecture file arch . export ( 'architecture.yaml' ) # Check if the architecture file is created ! readlink - f ./ architecture . yaml # /home/user/ros2_caret_ws/eval/architecture.yaml","title":"How to generate an architecture file"},{"location":"tutorials/configuration/#how-to-define-a-target-path","text":"Load the yaml-based architecture file as below from caret_analyze import Architecture , check_procedure arch = Architecture ( 'yaml' , './architecture.yaml' ) Choose source node and destination node in a path arch.search_paths extract all candidates of the path paths = arch . search_paths ( '/sensor_dummy_node' , # source node '/actuator_dummy_node' ) # destination node If a target application is large and complicated, arch.search_paths method may consume time more than 1 minute. For decreasing consumed time, you can ignore nodes and topics and specify depth of search. Refer to \u30d1\u30b9\u306e\u63a2\u7d22\u65b9\u6cd5 for more details. Check the path as you expected You will find multiple candidates of the path. You can check which candidate is expected as target. The following code is an example for users to check path = paths [ 0 ] path . summary . pprint () --- Output text as below --- path : - message_context : null # for definition of node latency node : / sensor_dummy_node - topic : / topic1 - message_context : publisher_topic_name : / topic2 subscription_topic_name : / topic1 type : callback_chain node : / filter_node - topic : / topic2 - message_context : null node : / message_driven_node - topic : / topic3 - message_context : null node : / timer_driven_node - topic : / topic4 - message_context : null node : / actuator_dummy_node Give a name to selected path and update architecture file arch . add_path ( 'target_path' , path ) arch . export ( './architecture.yaml' , force = True ) The updated architecture file describes the path named as target_path . named_paths : - path_name : target_path node_chain : - node_name : /sensor_dummy_node publish_topic_name : /topic1 subscribe_topic_name : UNDEFINED - node_name : /filter_node publish_topic_name : /topic2 subscribe_topic_name : /topic1 - node_name : /message_driven_node publish_topic_name : /topic3 subscribe_topic_name : /topic2 - node_name : /timer_driven_node publish_topic_name : /topic4 subscribe_topic_name : /topic3 - node_name : /actuator_dummy_node publish_topic_name : UNDEFINED subscribe_topic_name : /topic4","title":"How to define a target path"},{"location":"tutorials/configuration/#how-to-define-latency-of-a-single-node","text":"Latency of a single node, so called \"node latency\", is defined as elapsed time from 1. starting time to 2. publishing time as below. starting time when node subscribes topic message and invokes a corresponding callback function publishing time when node publishes topic message Definition of node latency depends on implementation pattern. Some nodes subscribe input messages and invoke callback function where they publish output messages. These nodes has direct relationship between input and output. Other nodes subscribe input messages and invoke callback functions where they buffer them, and invoke different callback functions consume input messages and publish output message. In the latter cases, relationship of input and output is indirect, and intra-node communication is performed with using multiple callback functions. message_filters is another cause to increase the number of implementation patterns. Therefore, CARET has to deal with several types of node implementation to measure node latency. CARET serve a function to define node latency with an architecture file. An architecture file has an item of message_context , which indicates relation between input message and output message. This item should be defined by users as below. Check which node latency should be configured path.verify() method, as shown in the following example, tells you which node latency should be defined. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () --- Output text as below --- WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/message_driven_node' ) message_context : null node : / message_driven_node publish_topic_name : / topic3 subscribe_topic_name : / topic2 WARNING : 2021 - 12 - 20 19 : 14 : 03 | Detected \"message_contest is None\" . Correct these node_path definitions . To see node definition and procedure , execute : >> check_procedure ( 'yaml' , '/path/to/yaml' , arch , '/timer_driven_node' ) message_context : null node : / timer_driven_node publish_topic_name : / topic4 subscribe_topic_name : / topic3 In the example, path.verify() tells you two nodes have undefined relationships of input and output. input /topic2 and output /topic3 in node /message_driven_node input /topic3 and output /topic4 in node /timer_driven_node Their relationships must be explicit with corresponding message_context items in the architecture file. Define relationship between input and output You have to change message_contexts items as below for the sample. # in /message_driven_node message_contexts : - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic2 publisher_topic_name : /topic3 # in /timer_driven_node message_contexts :\u3000 - context_type : use_latest_message # changed from 'UNDEFINED' to 'use_latest_message' subscription_topic_name : /topic3 publisher_topic_name : /topic4 Check if node latency is defined path.verify() tells you that there is no undefined node latency in the path. from caret_analyze import Architecture arch = Architecture ( 'yaml' , './architecture.yaml' ) path = arch . get_path ( 'target_path' ) path . verify () If path.verify() returns True , CARET can calculate latency of the path. Otherwise, there is any lack of definition to calculate latency. Todo We'll provide the sample architecture file here, but it's not ready. Sorry for inconvenience.","title":"How to define latency of a single node"},{"location":"tutorials/recording/","text":"Recording with CARET # This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository. Building application with CARET # To trace a target application, the target should be built with CARET/rclcpp. CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash' colcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING = OFF Info Reason to build the target with CARET/rclcpp is explained here. Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application. In order to apply rclcpp which has the additional tracepoints, the target have to be built with CARET/rclcpp again. Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as demo_nodes_cpp . If you want to trace such pre-build packages, please build them again from source code. Info Reason for giving -DBUILD_TESTING=OFF. To use CARET, you need to use forked shared libraries and headers such as caret-rclcpp. In the test codes, caret-rclcpp is not available due to loading priority issues for headers. Depending on the version of CARET, conflicts may occur between the shared libraries of ros-rclcpp and the headers of cadret-rclcpp, resulting in compile errors. Therefore, the test codes are excluded from building. Tracing the sample application with CARET # Starting LTTng session # CARET depends on LTTng for tracing applications. LTTng session has to be executed while a target application runs. You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing. source /opt/ros/humble/setup.bash # set a destination directory. ~/.ros/tracing is default. mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key # with \"-s\" option, you can give session name # the recorded data will be stored into ~/ros_ws/evaluate/e2e_sample in this sample Note that if you execute the target application before executing LTTng session will result in a lack of trace points. You can execute LTTng session via ROS launch system. If you are interested in this topic, please refer to LTTng \u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u958b\u59cb\u65b9\u6cd5 . When you execute a LTTng session in one terminal, you have to open another terminal for executing the target application. Operating multiple terminals is laborious for users. Launch LTTng session along with application by ros2 launch is a reasonable way to apply CARET repeatedly. Launching the target application # Open new terminal and run the target as shown in the following On the new terminal, as the target refers to CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash # keep the order as below source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash Check whether CARET/rclcpp is applied to each package The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables. # In case there are packages to which CARET/rclcpp is not applied ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ # The following message will be outputted WARNING : 2022 -06-12 12 :25:26 | The following packages have not been built using caret-rclcpp: demo_nodes_cpp caret_demos intra_process_demo # In case CARET/rclcpp is applied to all packages ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ INFO : 2022 -06-12 12 :26:49 | All packages are built using caret-rclcpp. Set LD_PRELOAD for adding tracepoints provided by function hook # Enable tracepoints which are defined hooked functions. export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) (Optional) Exclude nodes and topics which you are not concerned with export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" CARET serves trace filtering (in Japanese). With configuration of trace filtering, CARET can ignore nodes and topics. This function is useful for a large application. Launch the target application, demos_end_to_end_sample ros2 launch caret_demos end_to_end_sample.launch.py ^C # Finish with Ctrl+C after several seconds [ WARNING ] [ launch ] : user interrupted with ctrl-c ( SIGINT ) [ end_to_end_sample-1 ] [ INFO ] [ 1631481246 .160958444 ] [ rclcpp ] : signal_handler ( signal_value = 2 ) [ INFO ] [ end_to_end_sample-1 ] : process has finished cleanly [ pid 722356 ] You can finish the target application and LTTng session. LTTng session will be closed if you push Enter key on the terminal where the LTTng session runs. Info You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with ulimit -n command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; ulimit -n 65536 . Validating recorded data briefly # You can check whether tracing is successful or not with ros2 caret check_ctf command before analyzing recorded data. ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/ # If there are problems with the recorded data, warning messages will be displayed. Info Executing the ros2 caret check_ctf command for long recorded data or recorded data of a large application takes a long time to complete execution. Therefore, it is recommended to execute the ros2 caret check_ctf command on a short duration of recorded data before long-time recording. Tracer discarded error # Tracer discarded will be observed in some case, especially when applying CARET to a large application. If you find this error, CARET has failed in sampling tracepoints. WARNING : 2022 -04-27 08 :29:08 | Tracer discarded 42 events between 1650854449589056449 and 1650854449603217243 . WARNING : 2022 -04-27 08 :29:14 | Tracer discarded 29 events between 1650854463006767890 and 1650854463024865609 . WARNING : 2022 -04-27 08 :29:14 | Tracer discarded 12 events between 1650854463026376513 and 1650854463044841704 . LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents . After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded. You can avoid this error with the following two approach. to filter topics and nodes which can be ignored with trace filtering explained in the previous section especially, filtering highly-frequent nodes and topics is effective highly-frequent nodes/topics can be identified by checking the summary of trace data to increase size of ring buffer defined in lttng_impl.py","title":"Recording"},{"location":"tutorials/recording/#recording-with-caret","text":"This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository.","title":"Recording with CARET"},{"location":"tutorials/recording/#building-application-with-caret","text":"To trace a target application, the target should be built with CARET/rclcpp. CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash' colcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING = OFF Info Reason to build the target with CARET/rclcpp is explained here. Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application. In order to apply rclcpp which has the additional tracepoints, the target have to be built with CARET/rclcpp again. Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as demo_nodes_cpp . If you want to trace such pre-build packages, please build them again from source code. Info Reason for giving -DBUILD_TESTING=OFF. To use CARET, you need to use forked shared libraries and headers such as caret-rclcpp. In the test codes, caret-rclcpp is not available due to loading priority issues for headers. Depending on the version of CARET, conflicts may occur between the shared libraries of ros-rclcpp and the headers of cadret-rclcpp, resulting in compile errors. Therefore, the test codes are excluded from building.","title":"Building application with CARET"},{"location":"tutorials/recording/#tracing-the-sample-application-with-caret","text":"","title":"Tracing the sample application with CARET"},{"location":"tutorials/recording/#starting-lttng-session","text":"CARET depends on LTTng for tracing applications. LTTng session has to be executed while a target application runs. You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing. source /opt/ros/humble/setup.bash # set a destination directory. ~/.ros/tracing is default. mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key # with \"-s\" option, you can give session name # the recorded data will be stored into ~/ros_ws/evaluate/e2e_sample in this sample Note that if you execute the target application before executing LTTng session will result in a lack of trace points. You can execute LTTng session via ROS launch system. If you are interested in this topic, please refer to LTTng \u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u958b\u59cb\u65b9\u6cd5 . When you execute a LTTng session in one terminal, you have to open another terminal for executing the target application. Operating multiple terminals is laborious for users. Launch LTTng session along with application by ros2 launch is a reasonable way to apply CARET repeatedly.","title":"Starting LTTng session"},{"location":"tutorials/recording/#launching-the-target-application","text":"Open new terminal and run the target as shown in the following On the new terminal, as the target refers to CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash # keep the order as below source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash Check whether CARET/rclcpp is applied to each package The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables. # In case there are packages to which CARET/rclcpp is not applied ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ # The following message will be outputted WARNING : 2022 -06-12 12 :25:26 | The following packages have not been built using caret-rclcpp: demo_nodes_cpp caret_demos intra_process_demo # In case CARET/rclcpp is applied to all packages ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ INFO : 2022 -06-12 12 :26:49 | All packages are built using caret-rclcpp. Set LD_PRELOAD for adding tracepoints provided by function hook # Enable tracepoints which are defined hooked functions. export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) (Optional) Exclude nodes and topics which you are not concerned with export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" CARET serves trace filtering (in Japanese). With configuration of trace filtering, CARET can ignore nodes and topics. This function is useful for a large application. Launch the target application, demos_end_to_end_sample ros2 launch caret_demos end_to_end_sample.launch.py ^C # Finish with Ctrl+C after several seconds [ WARNING ] [ launch ] : user interrupted with ctrl-c ( SIGINT ) [ end_to_end_sample-1 ] [ INFO ] [ 1631481246 .160958444 ] [ rclcpp ] : signal_handler ( signal_value = 2 ) [ INFO ] [ end_to_end_sample-1 ] : process has finished cleanly [ pid 722356 ] You can finish the target application and LTTng session. LTTng session will be closed if you push Enter key on the terminal where the LTTng session runs. Info You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with ulimit -n command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; ulimit -n 65536 .","title":"Launching the target application"},{"location":"tutorials/recording/#validating-recorded-data-briefly","text":"You can check whether tracing is successful or not with ros2 caret check_ctf command before analyzing recorded data. ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/ # If there are problems with the recorded data, warning messages will be displayed. Info Executing the ros2 caret check_ctf command for long recorded data or recorded data of a large application takes a long time to complete execution. Therefore, it is recommended to execute the ros2 caret check_ctf command on a short duration of recorded data before long-time recording.","title":"Validating recorded data briefly"},{"location":"tutorials/recording/#tracer-discarded-error","text":"Tracer discarded will be observed in some case, especially when applying CARET to a large application. If you find this error, CARET has failed in sampling tracepoints. WARNING : 2022 -04-27 08 :29:08 | Tracer discarded 42 events between 1650854449589056449 and 1650854449603217243 . WARNING : 2022 -04-27 08 :29:14 | Tracer discarded 29 events between 1650854463006767890 and 1650854463024865609 . WARNING : 2022 -04-27 08 :29:14 | Tracer discarded 12 events between 1650854463026376513 and 1650854463044841704 . LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents . After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded. You can avoid this error with the following two approach. to filter topics and nodes which can be ignored with trace filtering explained in the previous section especially, filtering highly-frequent nodes and topics is effective highly-frequent nodes/topics can be identified by checking the summary of trace data to increase size of ring buffer defined in lttng_impl.py","title":"Tracer discarded error"},{"location":"tutorials/recording_modified/","text":"Recording with CARET # This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository. See Recording to find more details. Building application with CARET # To trace a target application, the target should be built with CARET/rclcpp. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash' colcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING = OFF The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables. ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ # Expected output. CARET/rclcpp is applied to all packages INFO : 2022 -06-12 12 :26:49 | All packages are built using caret-rclcpp. # In case there are packages to which CARET/rclcpp is not applied # The following message will be outputted WARNING : 2022 -06-12 12 :25:26 | The following packages have not been built using caret-rclcpp: demo_nodes_cpp caret_demos intra_process_demo Tracing the sample application with CARET # Starting LTTng session # CARET depends on LTTng for tracing applications. LTTng session has to be started before a target application runs. Note that if you execute the target application before starting LTTng session, it will result in a lack of trace points. You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing. source /opt/ros/humble/setup.bash # set a destination directory. ~/.ros/tracing is default. mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key Launching the target application # Open a new terminal and run the target as shown in the following # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash # Enable tracepoints which are defined hooked functions. export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) # (Optional) Exclude nodes and topics which you are not concerned with export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Launch the target application, demos_end_to_end_sample ros2 launch caret_demos end_to_end_sample.launch.py ^C # Finish with Ctrl+C after several seconds [ WARNING ] [ launch ] : user interrupted with ctrl-c ( SIGINT ) [ end_to_end_sample-1 ] [ INFO ] [ 1631481246 .160958444 ] [ rclcpp ] : signal_handler ( signal_value = 2 ) [ INFO ] [ end_to_end_sample-1 ] : process has finished cleanly [ pid 722356 ] You can finish the target application and LTTng session. LTTng session will be closed if you push Enter key on the terminal where the LTTng session runs. Validating recorded data briefly # You can check whether tracing is successful or not with ros2 caret check_ctf command before analyzing recorded data. ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/ # If there are problems with the recorded data, warning messages will be displayed.","title":"Recording with CARET"},{"location":"tutorials/recording_modified/#recording-with-caret","text":"This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository. See Recording to find more details.","title":"Recording with CARET"},{"location":"tutorials/recording_modified/#building-application-with-caret","text":"To trace a target application, the target should be built with CARET/rclcpp. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's local_setup.bash should be applied along with ROS 2's setup.bash as shown below. mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash' colcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING = OFF The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables. ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/ # Expected output. CARET/rclcpp is applied to all packages INFO : 2022 -06-12 12 :26:49 | All packages are built using caret-rclcpp. # In case there are packages to which CARET/rclcpp is not applied # The following message will be outputted WARNING : 2022 -06-12 12 :25:26 | The following packages have not been built using caret-rclcpp: demo_nodes_cpp caret_demos intra_process_demo","title":"Building application with CARET"},{"location":"tutorials/recording_modified/#tracing-the-sample-application-with-caret","text":"","title":"Tracing the sample application with CARET"},{"location":"tutorials/recording_modified/#starting-lttng-session","text":"CARET depends on LTTng for tracing applications. LTTng session has to be started before a target application runs. Note that if you execute the target application before starting LTTng session, it will result in a lack of trace points. You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing. source /opt/ros/humble/setup.bash # set a destination directory. ~/.ros/tracing is default. mkdir -p ~/ros2_ws/evaluate export ROS_TRACE_DIR = ~/ros2_ws/evaluate ros2 trace -s e2e_sample -k -u \"ros2*\" # Start session with pressing Enter key","title":"Starting LTTng session"},{"location":"tutorials/recording_modified/#launching-the-target-application","text":"Open a new terminal and run the target as shown in the following # Environment settings (keep the order as below) source /opt/ros/humble/setup.bash source ~/ros2_caret_ws/install/local_setup.bash source ~/ros2_ws/install/local_setup.bash # Enable tracepoints which are defined hooked functions. export LD_PRELOAD = $( readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so ) # (Optional) Exclude nodes and topics which you are not concerned with export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" # Launch the target application, demos_end_to_end_sample ros2 launch caret_demos end_to_end_sample.launch.py ^C # Finish with Ctrl+C after several seconds [ WARNING ] [ launch ] : user interrupted with ctrl-c ( SIGINT ) [ end_to_end_sample-1 ] [ INFO ] [ 1631481246 .160958444 ] [ rclcpp ] : signal_handler ( signal_value = 2 ) [ INFO ] [ end_to_end_sample-1 ] : process has finished cleanly [ pid 722356 ] You can finish the target application and LTTng session. LTTng session will be closed if you push Enter key on the terminal where the LTTng session runs.","title":"Launching the target application"},{"location":"tutorials/recording_modified/#validating-recorded-data-briefly","text":"You can check whether tracing is successful or not with ros2 caret check_ctf command before analyzing recorded data. ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/ # If there are problems with the recorded data, warning messages will be displayed.","title":"Validating recorded data briefly"},{"location":"tutorials/visualization/","text":"Performance visualization # CARET serves Python APIs to visualize trace data for users to analyze applications' performance. This section will show basic flow to visualize data with Jupyter notebook. How to locate trace data on Jupyter notebook # Launching jupyter-lab Launch jupyter-lab at first for learning how to visualize recorded data. cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab CARET uses bokeh for some visualization APIs. Execute the following code for loading bokeh from bokeh.plotting import output_notebook output_notebook () Loading trace data onto Jupyter notebook Locate trace data on Jupyter notebook as well as the architecture file. from caret_analyze import Architecture , Application , Lttng # load the architecture file which is created in the previous page arch = Architecture ( 'yaml' , './architecture.yaml' ) # load recorded data by CARET lttng = Lttng ( './e2e_sample' ) # map the application architecture to recorded data app = Application ( arch , lttng ) After execution of the code, users will often refer to the app object defined as Application class. The app objects provides users latency of callbacks, communication, and paths. Application class is similar to Architecture class which describes structure of the application and their interfaces are similar. In addition, Application class has interfaces to get latency. Basic API to get latency # This section will explain APIs to get callback latency. The following code is one of examples to get callback latency. # Get a callback instance, which has latency information, from app callback = app . get_callback ( '/timer_driven_node/callback_0' ) # Get time-series variation of latency t , latency_ns = callback . to_timeseries () # Get histogram of latency bins , latency_ns = callback . to_histogram () Though this example shows callback latency, CARET serves API to get communication latency. callback.to_dataframe() will provides pandas.DataFrame based object including raw timestamps which is obtained from tracepoints. Todo Sorry for not providing CARET's API list, but we'll provide it in the near future. Visualizing latency of node chain with message flow # CARET provides some APIs to visualize measured data. With message flow, which is one of effective visualizations, users can understand what happens and where is bottleneck in target applications. Execute the following code for visualization with message flow. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path ) The following figure will appear if message_flow method is successful. The horizontal axis shows time line. On the other hand, the vertical axis shows elements of the node chain ( target_path ), which include callback functions and topic messages from input to output. Each colorful line shows how a certain input message is propagated to callback functions and topic communications. Gray rectangles show execution timing of callback functions. If your mouse pointer is put over one of gray rectangles, latency of callback functions will be shown. You can find latency of a target node chain as well if you put the mouse pointer onto one of colorful lines. CARET serves other APIs for visualization. Refer to \u30ae\u30e3\u30e9\u30ea\u30fc for more details.","title":"Visualization"},{"location":"tutorials/visualization/#performance-visualization","text":"CARET serves Python APIs to visualize trace data for users to analyze applications' performance. This section will show basic flow to visualize data with Jupyter notebook.","title":"Performance visualization"},{"location":"tutorials/visualization/#how-to-locate-trace-data-on-jupyter-notebook","text":"Launching jupyter-lab Launch jupyter-lab at first for learning how to visualize recorded data. cd ~/ros2_ws/evaluate source ~/ros2_caret_ws/install/setup.bash jupyter-lab CARET uses bokeh for some visualization APIs. Execute the following code for loading bokeh from bokeh.plotting import output_notebook output_notebook () Loading trace data onto Jupyter notebook Locate trace data on Jupyter notebook as well as the architecture file. from caret_analyze import Architecture , Application , Lttng # load the architecture file which is created in the previous page arch = Architecture ( 'yaml' , './architecture.yaml' ) # load recorded data by CARET lttng = Lttng ( './e2e_sample' ) # map the application architecture to recorded data app = Application ( arch , lttng ) After execution of the code, users will often refer to the app object defined as Application class. The app objects provides users latency of callbacks, communication, and paths. Application class is similar to Architecture class which describes structure of the application and their interfaces are similar. In addition, Application class has interfaces to get latency.","title":"How to locate trace data on Jupyter notebook"},{"location":"tutorials/visualization/#basic-api-to-get-latency","text":"This section will explain APIs to get callback latency. The following code is one of examples to get callback latency. # Get a callback instance, which has latency information, from app callback = app . get_callback ( '/timer_driven_node/callback_0' ) # Get time-series variation of latency t , latency_ns = callback . to_timeseries () # Get histogram of latency bins , latency_ns = callback . to_histogram () Though this example shows callback latency, CARET serves API to get communication latency. callback.to_dataframe() will provides pandas.DataFrame based object including raw timestamps which is obtained from tracepoints. Todo Sorry for not providing CARET's API list, but we'll provide it in the near future.","title":"Basic API to get latency"},{"location":"tutorials/visualization/#visualizing-latency-of-node-chain-with-message-flow","text":"CARET provides some APIs to visualize measured data. With message flow, which is one of effective visualizations, users can understand what happens and where is bottleneck in target applications. Execute the following code for visualization with message flow. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path ) The following figure will appear if message_flow method is successful. The horizontal axis shows time line. On the other hand, the vertical axis shows elements of the node chain ( target_path ), which include callback functions and topic messages from input to output. Each colorful line shows how a certain input message is propagated to callback functions and topic communications. Gray rectangles show execution timing of callback functions. If your mouse pointer is put over one of gray rectangles, latency of callback functions will be shown. You can find latency of a target node chain as well if you put the mouse pointer onto one of colorful lines. CARET serves other APIs for visualization. Refer to \u30ae\u30e3\u30e9\u30ea\u30fc for more details.","title":"Visualizing latency of node chain with message flow"},{"location":"visualization/","text":"Visualization # Basic APIs Concept # Basic APIs Concept provided by CARET Provided APIs # APIs in Plot Class # create_callback_frequency_plot create_callback_period_plot create_callback_latency_plot create_publish_subscription_period_plot create_publish_subscription_frequency_plot create_communication_latency_plot create_communication_frequency_plot create_communication_period_plot create_response_time_histogram_plot APIs in other than Plot Class # Note: These APIs will be implemented to Plot Class. message_flow callback_sched Investigation APIs # CARET provides some APIs to investigate more detail. LTTngEventFilter get_callbacks Note: Investigation APIs are written in CARET analyze API document .","title":"Visualization"},{"location":"visualization/#visualization","text":"","title":"Visualization"},{"location":"visualization/#basic-apis-concept","text":"Basic APIs Concept provided by CARET","title":"Basic APIs Concept"},{"location":"visualization/#provided-apis","text":"","title":"Provided APIs"},{"location":"visualization/#apis-in-plot-class","text":"create_callback_frequency_plot create_callback_period_plot create_callback_latency_plot create_publish_subscription_period_plot create_publish_subscription_frequency_plot create_communication_latency_plot create_communication_frequency_plot create_communication_period_plot create_response_time_histogram_plot","title":"APIs in Plot Class"},{"location":"visualization/#apis-in-other-than-plot-class","text":"Note: These APIs will be implemented to Plot Class. message_flow callback_sched","title":"APIs in other than Plot Class"},{"location":"visualization/#investigation-apis","text":"CARET provides some APIs to investigate more detail. LTTngEventFilter get_callbacks Note: Investigation APIs are written in CARET analyze API document .","title":"Investigation APIs"},{"location":"visualization/API_to_get_info_of_callback/","text":"API to get information about each callback # CARET can visualize execution frequency, period and latency along time for each callback and provide them in the pandas DataFrame format. Several sets of sample program and output are shown in subsequent sections. In each example, the following commands are executed in advance. from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import Plot arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) app = Application ( arch , lttng ) Please see CARET analyze API document for details on the arguments of this API.","title":"API to get information about each callback"},{"location":"visualization/API_to_get_info_of_callback/#api-to-get-information-about-each-callback","text":"CARET can visualize execution frequency, period and latency along time for each callback and provide them in the pandas DataFrame format. Several sets of sample program and output are shown in subsequent sections. In each example, the following commands are executed in advance. from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import Plot arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) app = Application ( arch , lttng ) Please see CARET analyze API document for details on the arguments of this API.","title":"API to get information about each callback"},{"location":"visualization/trouble_shooting/","text":"Troubleshooting # Problems during visualization, such as message flow not being displayed # The following causes are possible Environment variable LD_PRELOAD is not set No logs were recorded at the time of initialization. When logging with the ros2 tracing command, user needs to execute the ros2 tracing command by pressing the Enter key to start, then it is necessary to execute the application to be measured. Target application is not rebuilt with rclcpp with tracepoints added caret adds some trace points to the ros layer. To enable these trace points, the application must be rebuilt as follows mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos --recursive source ~/ros2_caret_ws/install/local_setup.bash colcon build --symlink-install The measurement results are wrong # The following causes are possible Trace results are not saved in time and are lost Execute the following command and confirm that no error output is generated. babeltrace autoware > /dev/null [ warning ] Tracer discarded 3435 events between [ 15 :05:22.967846940 ] and [ 15 :05:23.025356129 ] in trace UUID 236d978f8bde4cbc9460b0f4e008081, at path: \"autoware/ust/uid/1000/64-bit\" , within stream id 0 , at relative path: \"ros2_12\" . You should consider recording a new trace with larger buffers or with fewer events enabled. [ warning ] Tracer discarded 3910 events between [ 15 :05:22.972199681 ] and [ 15 :05:23.024463592 ] in trace UUID 236d978f8bde4cbc9460b0f4e008081, at path: \"autoware/ust/uid/1000/64-bit\" , within stream id 0 , at relative path: \"ros2_6\" . You should consider recording a new trace with larger buffers or with fewer events enabled. If you see Tracer discarded 3435 events as above, the measurement result may not be correct. If the trace results are not saved in time, set the environment variables as follows and measure again. export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" For more information about settings, see the trace filtering . TraceResultAnalyzeError: Failed to find # This is an error that occurs when the information in the architecture file is not found in the trace results. It refers to a mismatch between the architecture file and the trace results. Please review the architecture file or measurement method with reference to the error statement displayed. Example TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)() Callback information not found. node_name\uff1a/localization/pose_twist_fusion_filter/ekf_localizer callback_name\uff1atimer_callback_0 period_ns\uff1a19999999 symbol\uff1avoid (EKFLocalizer::?)() Only certain nodes are not being measured # The phenomenon of missing some trace points, which may cause the problem. We are currently finding a problem where trace points added to a forked ROS layer are not being measured correctly. This is due to the forked rclcpp not being referenced when building. If you are missing trace points in the above procedure, please add the following line after find_package in CMakeLists.txt. include_directories ( SYSTEM /home/autoware/ros2_caret_ws/install/rclcpp/include ) For tracepoints added with forked rclcpp, see Trace Point Definition . The items which the implementation method is \"rclcpp package new addition\" are the forked added tracepoints. Message flow diagram stops in the middle #","title":"Trouble shooting"},{"location":"visualization/trouble_shooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"visualization/trouble_shooting/#problems-during-visualization-such-as-message-flow-not-being-displayed","text":"The following causes are possible Environment variable LD_PRELOAD is not set No logs were recorded at the time of initialization. When logging with the ros2 tracing command, user needs to execute the ros2 tracing command by pressing the Enter key to start, then it is necessary to execute the application to be measured. Target application is not rebuilt with rclcpp with tracepoints added caret adds some trace points to the ros layer. To enable these trace points, the application must be rebuilt as follows mkdir -p ~/ros2_ws/src cd ~/ros2_ws git clone https://github.com/tier4/CARET_demos.git src/CARET_demos --recursive source ~/ros2_caret_ws/install/local_setup.bash colcon build --symlink-install","title":"Problems during visualization, such as message flow not being displayed"},{"location":"visualization/trouble_shooting/#the-measurement-results-are-wrong","text":"The following causes are possible Trace results are not saved in time and are lost Execute the following command and confirm that no error output is generated. babeltrace autoware > /dev/null [ warning ] Tracer discarded 3435 events between [ 15 :05:22.967846940 ] and [ 15 :05:23.025356129 ] in trace UUID 236d978f8bde4cbc9460b0f4e008081, at path: \"autoware/ust/uid/1000/64-bit\" , within stream id 0 , at relative path: \"ros2_12\" . You should consider recording a new trace with larger buffers or with fewer events enabled. [ warning ] Tracer discarded 3910 events between [ 15 :05:22.972199681 ] and [ 15 :05:23.024463592 ] in trace UUID 236d978f8bde4cbc9460b0f4e008081, at path: \"autoware/ust/uid/1000/64-bit\" , within stream id 0 , at relative path: \"ros2_6\" . You should consider recording a new trace with larger buffers or with fewer events enabled. If you see Tracer discarded 3435 events as above, the measurement result may not be correct. If the trace results are not saved in time, set the environment variables as follows and measure again. export CARET_IGNORE_NODES = \"/rviz*\" export CARET_IGNORE_TOPICS = \"/clock:/parameter_events\" For more information about settings, see the trace filtering .","title":"The measurement results are wrong"},{"location":"visualization/trouble_shooting/#traceresultanalyzeerror-failed-to-find","text":"This is an error that occurs when the information in the architecture file is not found in the trace results. It refers to a mismatch between the architecture file and the trace results. Please review the architecture file or measurement method with reference to the error statement displayed. Example TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)() Callback information not found. node_name\uff1a/localization/pose_twist_fusion_filter/ekf_localizer callback_name\uff1atimer_callback_0 period_ns\uff1a19999999 symbol\uff1avoid (EKFLocalizer::?)()","title":"TraceResultAnalyzeError: Failed to find"},{"location":"visualization/trouble_shooting/#only-certain-nodes-are-not-being-measured","text":"The phenomenon of missing some trace points, which may cause the problem. We are currently finding a problem where trace points added to a forked ROS layer are not being measured correctly. This is due to the forked rclcpp not being referenced when building. If you are missing trace points in the above procedure, please add the following line after find_package in CMakeLists.txt. include_directories ( SYSTEM /home/autoware/ros2_caret_ws/install/rclcpp/include ) For tracepoints added with forked rclcpp, see Trace Point Definition . The items which the implementation method is \"rclcpp package new addition\" are the forked added tracepoints.","title":"Only certain nodes are not being measured"},{"location":"visualization/trouble_shooting/#message-flow-diagram-stops-in-the-middle","text":"","title":"Message flow diagram stops in the middle"},{"location":"visualization/concept/basic_api_concept/","text":"Basic APIs Concept # The main basic design of the Plot class # The visualization tools provided by CARET are implemented in the Plot class. The usage of each API of the Plot class is unified as follows: from caret_analyze.plot import Plot ... # Processing input data plot = Plot . create_ [ metrics ] _ [ graph_type ] _plot ( data ) plot . show () plot . to_dataframe () The variable \"plot\" has two functions, show() and to_dataframe(). The function \"show()\" outputs a figure and returns the figure's handler. The function \"to_dataframe()\" returns a table summarizing the data. This function is mainly used to analyze based on specific figures. Note: For detailed input/output options, see TimeSeriesPlot .","title":"Basic APIs Concept"},{"location":"visualization/concept/basic_api_concept/#basic-apis-concept","text":"","title":"Basic APIs Concept"},{"location":"visualization/concept/basic_api_concept/#the-main-basic-design-of-the-plot-class","text":"The visualization tools provided by CARET are implemented in the Plot class. The usage of each API of the Plot class is unified as follows: from caret_analyze.plot import Plot ... # Processing input data plot = Plot . create_ [ metrics ] _ [ graph_type ] _plot ( data ) plot . show () plot . to_dataframe () The variable \"plot\" has two functions, show() and to_dataframe(). The function \"show()\" outputs a figure and returns the figure's handler. The function \"to_dataframe()\" returns a table summarizing the data. This function is mainly used to analyze based on specific figures. Note: For detailed input/output options, see TimeSeriesPlot .","title":"The main basic design of the Plot class"},{"location":"visualization/investigation_api/investigate_behavior/","text":"Detailed Behavior Investigation Methods # CARET provides a ROS-friendly class structure that allows the following classes to obtain detailed execution information. Executor Node CallbackGroup Callback Publisher Subscription Timer Please refer to the API documentation for information on what information can be obtained the target class. This section describes how to obtain the targeted class. Description of get_callback # The 'get_callback()' is a function that returns callback information such as callback name, callback period[ns], callback type. API # # def get_callback(self, callback_name: str) -> CallbackBase The 'get_callback()' function returns single callback that match the argument string and callback name (callback name defined in architecture file). If no matching callbacks are found, get_callback raises a exception. Usage # from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callback ( 'timer_driven_node/callback_0' ) callback2 = app . get_callback ( 'timer_driven_node/callback_1' ) Description of get_callbacks # The get_callbacks() is a function that gets callback information. Callbacks information includes callback name, callback period[ns], callback type. API # # def get_callbacks(self, *callback_names: str) -> List[CallbackBase] The 'get_callbacks()' function gets callbacks that match the argument string and callback name (callback name defined in architecture file). If concrete callback names are given and there is no match callbacks, The 'get_callbacks()' function warns and may notify similar callbacks name. The 'get_callbacks()' function can recognize UNIX filename pattern such as '*' or '?'. If patterns are given, get_callbacks doesn't raise any exception, and returns empty list. Usage # from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callbacks ( 'timer_driven_node/callback_0' ) callback2 = app . get_callbacks ( 'timer_driven_node/callback_?' ) callback3 = app . get_callbacks ( 'timer_driven_node/*' )","title":"Detailed Behavior Investigation Methods"},{"location":"visualization/investigation_api/investigate_behavior/#detailed-behavior-investigation-methods","text":"CARET provides a ROS-friendly class structure that allows the following classes to obtain detailed execution information. Executor Node CallbackGroup Callback Publisher Subscription Timer Please refer to the API documentation for information on what information can be obtained the target class. This section describes how to obtain the targeted class.","title":"Detailed Behavior Investigation Methods"},{"location":"visualization/investigation_api/investigate_behavior/#description-of-get_callback","text":"The 'get_callback()' is a function that returns callback information such as callback name, callback period[ns], callback type.","title":"Description of get_callback"},{"location":"visualization/investigation_api/investigate_behavior/#api","text":"# def get_callback(self, callback_name: str) -> CallbackBase The 'get_callback()' function returns single callback that match the argument string and callback name (callback name defined in architecture file). If no matching callbacks are found, get_callback raises a exception.","title":"API"},{"location":"visualization/investigation_api/investigate_behavior/#usage","text":"from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callback ( 'timer_driven_node/callback_0' ) callback2 = app . get_callback ( 'timer_driven_node/callback_1' )","title":"Usage"},{"location":"visualization/investigation_api/investigate_behavior/#description-of-get_callbacks","text":"The get_callbacks() is a function that gets callback information. Callbacks information includes callback name, callback period[ns], callback type.","title":"Description of get_callbacks"},{"location":"visualization/investigation_api/investigate_behavior/#api_1","text":"# def get_callbacks(self, *callback_names: str) -> List[CallbackBase] The 'get_callbacks()' function gets callbacks that match the argument string and callback name (callback name defined in architecture file). If concrete callback names are given and there is no match callbacks, The 'get_callbacks()' function warns and may notify similar callbacks name. The 'get_callbacks()' function can recognize UNIX filename pattern such as '*' or '?'. If patterns are given, get_callbacks doesn't raise any exception, and returns empty list.","title":"API"},{"location":"visualization/investigation_api/investigate_behavior/#usage_1","text":"from caret_analyze import Architecture , Application , Lttng callback1 = app . get_callbacks ( 'timer_driven_node/callback_0' ) callback2 = app . get_callbacks ( 'timer_driven_node/callback_?' ) callback3 = app . get_callbacks ( 'timer_driven_node/*' )","title":"Usage"},{"location":"visualization/investigation_api/lttng_event_filter/","text":"Usage of LTTngEventFilter # CARET can handle measurements and analysis up to several minutes. Memory usage, analysis time, and visualization time, etc., will be issues when leveraging measurement results of longer duration. Therefore, CARET has an API (LTTngEventFilter) to omit unnecessary measurement results when reading LTTng. This section describes how to use the LTTngEventFilter. LTTngEventFilter has the following filters init_pass_filter duration_filter strip_filter API Description # LttngEventFilter . init_pass_filter () Filter the trace points at initialization LttngEventFilter . duration_filter ( duration_s : float , offset_s : float ) [duration_s] : Measure durtion [offset_s] : Ignore seconds from start LttngEventFilter . strip_filter ( lsplit_s : Optional [ float ], rsplit_s : Optional [ float ]) Ignore measurement results for [lsplit_s] from the start of the measurement Ignore measurement results for [rsplit_s] seconds before measurement ends Use cases # from caret_analyze import Lttng , LttngEventFilter lttng = Lttng ( '/path/to/ctf' , event_filters = [ LttngEventFilter . duration_filter ( 10 , 5 ) ]) # Filtering from 5 seconds to 10 seconds after the start of the measurement Multiple event_filters can be specified. If you include more than one, all filters will be filtered to the specified interval only.","title":"Usage of LTTngEventFilter"},{"location":"visualization/investigation_api/lttng_event_filter/#usage-of-lttngeventfilter","text":"CARET can handle measurements and analysis up to several minutes. Memory usage, analysis time, and visualization time, etc., will be issues when leveraging measurement results of longer duration. Therefore, CARET has an API (LTTngEventFilter) to omit unnecessary measurement results when reading LTTng. This section describes how to use the LTTngEventFilter. LTTngEventFilter has the following filters init_pass_filter duration_filter strip_filter","title":"Usage of LTTngEventFilter"},{"location":"visualization/investigation_api/lttng_event_filter/#api-description","text":"LttngEventFilter . init_pass_filter () Filter the trace points at initialization LttngEventFilter . duration_filter ( duration_s : float , offset_s : float ) [duration_s] : Measure durtion [offset_s] : Ignore seconds from start LttngEventFilter . strip_filter ( lsplit_s : Optional [ float ], rsplit_s : Optional [ float ]) Ignore measurement results for [lsplit_s] from the start of the measurement Ignore measurement results for [rsplit_s] seconds before measurement ends","title":"API Description"},{"location":"visualization/investigation_api/lttng_event_filter/#use-cases","text":"from caret_analyze import Lttng , LttngEventFilter lttng = Lttng ( '/path/to/ctf' , event_filters = [ LttngEventFilter . duration_filter ( 10 , 5 ) ]) # Filtering from 5 seconds to 10 seconds after the start of the measurement Multiple event_filters can be specified. If you include more than one, all filters will be filtered to the specified interval only.","title":"Use cases"},{"location":"visualization/investigation_api/path_verify/","text":"Error detection using path.verify() # CARET requires some setup and configuration that users should do. path.verify() method can check the settings are completed. If any error or warning occurs, message from path.verify() give you some instruction to tackle it. Usage # from caret_analyze import Architecture , Application , Lttng # read architecture file. arch = Architecture ( 'yaml' , '/path/to/architecture_file.yaml' ) # read trace result. lttng = Lttng ( '/path/to/trace_data' ) # map architecture information to trace result. app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) path . verify () What path.verify() checks # Check whether using caret/rclcpp [path.verify()] Your applications need to be built with rclcpp provided by CARET, not ROS 2. path.verify() command checks which rclcpp is used for building your application. If caret/rclcpp is not applied, the following warning message is outputted on your terminal or Jupyter notebook. WARNING : 2022 -03-18 12 :53:54 | 'caret/rclcpp' may not be used in subscriber of '/localization/pose_estimator/ndt_scan_matcher' . Check if node latency can be calculated with referring to message_context","title":"Error detection using `path.verify()`"},{"location":"visualization/investigation_api/path_verify/#error-detection-using-pathverify","text":"CARET requires some setup and configuration that users should do. path.verify() method can check the settings are completed. If any error or warning occurs, message from path.verify() give you some instruction to tackle it.","title":"Error detection using path.verify()"},{"location":"visualization/investigation_api/path_verify/#usage","text":"from caret_analyze import Architecture , Application , Lttng # read architecture file. arch = Architecture ( 'yaml' , '/path/to/architecture_file.yaml' ) # read trace result. lttng = Lttng ( '/path/to/trace_data' ) # map architecture information to trace result. app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) path . verify ()","title":"Usage"},{"location":"visualization/investigation_api/path_verify/#what-pathverify-checks","text":"Check whether using caret/rclcpp [path.verify()] Your applications need to be built with rclcpp provided by CARET, not ROS 2. path.verify() command checks which rclcpp is used for building your application. If caret/rclcpp is not applied, the following warning message is outputted on your terminal or Jupyter notebook. WARNING : 2022 -03-18 12 :53:54 | 'caret/rclcpp' may not be used in subscriber of '/localization/pose_estimator/ndt_scan_matcher' . Check if node latency can be calculated with referring to message_context","title":"What path.verify() checks"},{"location":"visualization/visualization_api/callback_information/","text":"Callback Information # Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) Execution frequency # # get dataframe plot = Plot . create_callback_frequency_plot ( app ) frequency_df = plot . to_dataframe () frequency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_frequency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below--- Period # # get dataframe plot = Plot . create_callback_period_plot ( app ) period_df = plot . to_dataframe () period_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_period_plot ( app ) plot . show () # ---Output in jupyter-notebook as below--- Latency # # get dataframe plot = Plot . create_callback_latency_plot ( app ) latency_df = plot . to_dataframe () latency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_latency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Callback Information"},{"location":"visualization/visualization_api/callback_information/#callback-information","text":"Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng )","title":"Callback Information"},{"location":"visualization/visualization_api/callback_information/#execution-frequency","text":"# get dataframe plot = Plot . create_callback_frequency_plot ( app ) frequency_df = plot . to_dataframe () frequency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_frequency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Execution frequency"},{"location":"visualization/visualization_api/callback_information/#period","text":"# get dataframe plot = Plot . create_callback_period_plot ( app ) period_df = plot . to_dataframe () period_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_period_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Period"},{"location":"visualization/visualization_api/callback_information/#latency","text":"# get dataframe plot = Plot . create_callback_latency_plot ( app ) latency_df = plot . to_dataframe () latency_df # ---Output in jupyter-notebook as below--- # show time-line plot = Plot . create_callback_latency_plot ( app ) plot . show () # ---Output in jupyter-notebook as below---","title":"Latency"},{"location":"visualization/visualization_api/callback_scheduling_visualization/","text":"Callback Scheduling Visualization # Callback Scheduling Visualization will show you callback scheduling of targets such as a Node, Executor, and Callbackgroup. from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import callback_sched arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) app = Application ( arch , lttng ) # target: node node = app . get_node ( 'node_name' ) # get node object callback_sched ( node ) # target: executor executor = app . get_executor ( 'executor_name' ) # get executor object callback_sched ( executor ) # target: executor cbg = app . get_callback_group ( 'cbg_name' ) # get callback group object callback_sched ( cbg ) Callback Scheduling Visualization Short rectangles indicate the callback execution time When the mouse cursor hovers over the long rectangular, a tooltip containing information about the callback will be displayed Timer Event Visualization Arrows shows expected timing of invocation of timer callback When invocations of timer callback are delayed for expected, arrows turns red; otherwise, arrows are white If invocations are late for more 5 ms after expected, they are regarded as delayed","title":"Callback Scheduling Visualization"},{"location":"visualization/visualization_api/callback_scheduling_visualization/#callback-scheduling-visualization","text":"Callback Scheduling Visualization will show you callback scheduling of targets such as a Node, Executor, and Callbackgroup. from caret_analyze import Architecture , Application , Lttng from caret_analyze.plot import callback_sched arch = Architecture ( 'lttng' , './e2e_sample' ) lttng = Lttng ( './e2e_sample' ) app = Application ( arch , lttng ) # target: node node = app . get_node ( 'node_name' ) # get node object callback_sched ( node ) # target: executor executor = app . get_executor ( 'executor_name' ) # get executor object callback_sched ( executor ) # target: executor cbg = app . get_callback_group ( 'cbg_name' ) # get callback group object callback_sched ( cbg ) Callback Scheduling Visualization Short rectangles indicate the callback execution time When the mouse cursor hovers over the long rectangular, a tooltip containing information about the callback will be displayed Timer Event Visualization Arrows shows expected timing of invocation of timer callback When invocations of timer callback are delayed for expected, arrows turns red; otherwise, arrows are white If invocations are late for more 5 ms after expected, they are regarded as delayed","title":"Callback Scheduling Visualization"},{"location":"visualization/visualization_api/chain_latency/","text":"Chain latency # Chain latency can show the latency of each node in the end-to-end path and the communication time between nodes. from caret_analyze.plot import chain_latency path = app . get_path ( 'target_path' ) chain_latency ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 )","title":"Chain latency"},{"location":"visualization/visualization_api/chain_latency/#chain-latency","text":"Chain latency can show the latency of each node in the end-to-end path and the communication time between nodes. from caret_analyze.plot import chain_latency path = app . get_path ( 'target_path' ) chain_latency ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 )","title":"Chain latency"},{"location":"visualization/visualization_api/communication_information/","text":"Communication Information # Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) comm = app . get_communications ( 'topic_name' ) comm = comm [ 0 ] # or comm = app.get_communication('pub_node', 'sub_node', 'topic_name') Frequency # plot = Plot . create_communication_frequency_plot ( comm ) plot . show () Period # plot = Plot . create_communication_period_plot ( comm ) plot . show () Latency # plot = Plot . create_communication_latency_plot ( comm ) plot . show ()","title":"Communication Information"},{"location":"visualization/visualization_api/communication_information/#communication-information","text":"Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) comm = app . get_communications ( 'topic_name' ) comm = comm [ 0 ] # or comm = app.get_communication('pub_node', 'sub_node', 'topic_name')","title":"Communication Information"},{"location":"visualization/visualization_api/communication_information/#frequency","text":"plot = Plot . create_communication_frequency_plot ( comm ) plot . show ()","title":"Frequency"},{"location":"visualization/visualization_api/communication_information/#period","text":"plot = Plot . create_communication_period_plot ( comm ) plot . show ()","title":"Period"},{"location":"visualization/visualization_api/communication_information/#latency","text":"plot = Plot . create_communication_latency_plot ( comm ) plot . show ()","title":"Latency"},{"location":"visualization/visualization_api/latency_histogram/","text":"Latency histogram # Histograms can be visualized as follows bins , hist = path . to_histogram () p = figure () p . step ( hist [ 1 :], bins ) show ( p )","title":"Latency histogram"},{"location":"visualization/visualization_api/latency_histogram/#latency-histogram","text":"Histograms can be visualized as follows bins , hist = path . to_histogram () p = figure () p . step ( hist [ 1 :], bins ) show ( p )","title":"Latency histogram"},{"location":"visualization/visualization_api/latency_time_series/","text":"Latency timeseries # t , latency_ns = path . to_timeseries ( remove_dropped = False ) latency_ms = latency_ns * 1.0e-6 p = figure () p . line ( t , latency_ms ) show ( p )","title":"Latency timeseries"},{"location":"visualization/visualization_api/latency_time_series/#latency-timeseries","text":"t , latency_ns = path . to_timeseries ( remove_dropped = False ) latency_ms = latency_ns * 1.0e-6 p = figure () p . line ( t , latency_ms ) show ( p )","title":"Latency timeseries"},{"location":"visualization/visualization_api/message_flow/","text":"Message flow # Visualizing the processing of each message at any point in time. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 ) The vertical axis goes from top to bottom, corresponding to the beginning to the end of the path. Each line represents a message flow. The gray rectangular area indicates the callback execution time. In addition to the basic operations of bokeh, the message flow diagram allows the following operations Scale adjustment of xaxis/yaxis Scale adjustments can be made only on the X-axis or only on the Y-axis by operating the wheel on the axis labels. View detailed information Move the cursor over the lines in the message flow or the gray rectangular area can see the detail information of callback and message.","title":"Message flow"},{"location":"visualization/visualization_api/message_flow/#message-flow","text":"Visualizing the processing of each message at any point in time. from caret_analyze.plot import message_flow path = app . get_path ( 'target_path' ) message_flow ( path , granularity = 'node' , lstrip_s = 1 , rstrip_s = 1 ) The vertical axis goes from top to bottom, corresponding to the beginning to the end of the path. Each line represents a message flow. The gray rectangular area indicates the callback execution time. In addition to the basic operations of bokeh, the message flow diagram allows the following operations Scale adjustment of xaxis/yaxis Scale adjustments can be made only on the X-axis or only on the Y-axis by operating the wheel on the axis labels. View detailed information Move the cursor over the lines in the message flow or the gray rectangular area can see the detail information of callback and message.","title":"Message flow"},{"location":"visualization/visualization_api/pub_sub_information/","text":"Publish/Subscription Information # Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) pub = app . get_publishers ( 'topic_name' ) pub = pub [ 0 ] # or sub = app.get_subscirber('pub_node', 'sub_node', 'topic_name') Frequency # plot = Plot . create_publish_subscription_frequency_plot ( publish ) plot . show () Period # plot = Plot . create_publish_subscription_period_plot ( publish ) plot . show ()","title":"Publish/Subscription Information"},{"location":"visualization/visualization_api/pub_sub_information/#publishsubscription-information","text":"Execute these commands in advance. from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) pub = app . get_publishers ( 'topic_name' ) pub = pub [ 0 ] # or sub = app.get_subscirber('pub_node', 'sub_node', 'topic_name')","title":"Publish/Subscription Information"},{"location":"visualization/visualization_api/pub_sub_information/#frequency","text":"plot = Plot . create_publish_subscription_frequency_plot ( publish ) plot . show ()","title":"Frequency"},{"location":"visualization/visualization_api/pub_sub_information/#period","text":"plot = Plot . create_publish_subscription_period_plot ( publish ) plot . show ()","title":"Period"},{"location":"visualization/visualization_api/response_time/","text":"Plot Response Time # Response Time is shown in Histogram. Response Time has 3 cases ([default, best, worst]). The difference is described in Here . from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) plot = Plot . create_response_time_histogram_plot ( path ) plot . show () plot = Plot . create_response_time_histogram_plot ( path , case = 'best' ) plot . show () plot = Plot . create_response_time_histogram_plot ( path , case = 'worst' ) plot . show ()","title":"Plot Response Time"},{"location":"visualization/visualization_api/response_time/#plot-response-time","text":"Response Time is shown in Histogram. Response Time has 3 cases ([default, best, worst]). The difference is described in Here . from caret_analyze.plot import Plot from caret_analyze import Application , Architecture , Lttng from bokeh.plotting import output_notebook , figure , show output_notebook () arch = Architecture ( 'yaml' , '/path/to/architecture_file' ) lttng = Lttng ( '/path/to/trace_data' ) app = Application ( arch , lttng ) path = app . get_path ( 'target_path' ) plot = Plot . create_response_time_histogram_plot ( path ) plot . show () plot = Plot . create_response_time_histogram_plot ( path , case = 'best' ) plot . show () plot = Plot . create_response_time_histogram_plot ( path , case = 'worst' ) plot . show ()","title":"Plot Response Time"}]}