{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chain-Aware ROS Evaluation Tool (CARET)","text":"<p>CARET is one of performance analysis tool dedicated with ROS 2 applications. It is able to measure not only callback latency and communication latency, but also path latency, in other words, chain of node or callback. As additional tracepoints are introduced by function hook, tracing resolution is improved.</p> <p>Features and capabilities are shown below.</p> <p>Features:</p> <ul> <li>Low overhead with LTTng-based tracepoints for sampling events in ROS/DDS layer</li> <li>Flexible tracepoints added by function hooking with LD_PRELOAD</li> <li>Python-based API for flexible data analysis and visualization</li> <li>Application-layer events tracing by cooperation with TILDE, runtime message tracer</li> </ul> <p>Capabilities:</p> <ul> <li>Performance measurement from several aspects<ul> <li>Callback latency, frequency, and period</li> <li>Topic communication latency, frequency, and period</li> <li>Node latency</li> <li>Path latency<ul> <li>End-to-end latency of software if path from input to output is selected</li> </ul> </li> </ul> </li> <li>Visualization of scheduling for callback execution</li> <li>Filtering function to ignore specific nodes and topics</li> <li>Search of target paths to trace</li> <li>Trace of application events like consumption of buffered topic message<ul> <li><code>/tf</code> (planned for v0.3.x release)</li> <li><code>message_filters</code> (supported by TILDE)</li> <li><code>image_transport</code> (supported by TILDE)</li> </ul> </li> </ul>"},{"location":"#tracing-flow-with-caret","title":"Tracing flow with CARET","text":"<p>CARET gives you capability of tracing your application with introducing new tracepoints to ROS and DDS layer while it utilized original tracepoints for <code>ros2_tracing</code>.</p> <p>CARET is served as only source code, but not as <code>apt</code> package, so far. CARET hooks dedicated functions to those defined in dynamic library in order to add tracepoints. The fork of rclcpp which has CARET-dedicated tracepoints is delivered. You have to build CARET and your application if you want to use.</p> <p>After you run your application with CARET, you will get recorded data which includes events, metadata and timestamp. You have to write a configuration file, called architecture file, in which you defines node latency and target path, before you analyze the data set.</p> <p>You will visualize trace data with the architecture file and <code>caret_analyze</code> package, including API for data analysis. <code>caret_analyze</code> is designed on assumption that users analyze trace data on Jupyter Notebook.</p>"},{"location":"#contents-list","title":"Contents list","text":""},{"location":"#installation","title":"Installation","text":"<p>Installation with Ansible is provided as the following page shows.</p> <ul> <li>Installation</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Refer to these page if you want to try.</p> <ul> <li>Recording</li> <li>Configuration</li> <li>Visualization</li> </ul>"},{"location":"#design","title":"Design","text":"<ul> <li>Index</li> <li>Software architecture</li> <li>Processing trace data</li> <li>Runtime processing</li> <li>Tracepoints</li> <li>Configuration</li> <li>Limits and constraints</li> </ul>"},{"location":"#details-of-each-step-for-analysis","title":"Details of each step for analysis","text":"<p>CARET serves helpful functions for you to analyze your application efficiently. Please refer to detailed explanation of each step for analysis.</p> <ul> <li>Recording</li> <li>Configuration</li> <li>Visualization</li> </ul>"},{"location":"#api-list","title":"API list","text":"<p>CARET serves powerful API to visualize and analyze performance. API list is located on the other repository, <code>caret_analyze</code>.</p> <ul> <li>API list (external link)</li> </ul> <p>There are two types of APIs: for user and for developer.</p>"},{"location":"#related-repositories","title":"Related repositories","text":"<p>CARET is constructed of the following packages</p> <ul> <li>caret_trace \uff5c Define tracepoints added by function hooking</li> <li>caret_analyze \uff5c Library for scripts to analyze and visualize data</li> <li>caret_analyze_cpp_impl \uff5c Efficient helper functions to analyze trace data written in C++</li> <li>ros2caret \uff5c CLI commands like <code>ros2 caret</code></li> <li>caret_demos \uff5c Demo programs for CARET</li> <li>caret_doc \uff5c Documentation</li> <li>rclcpp \uff5c the forked <code>rclcpp</code> including CARET-dedicated tracepoints</li> <li>ros2_tracing\uff5c the forked <code>ros2_tracing</code> including definition of CARET-dedicated tracepoints</li> </ul> <p>This software is based on results obtained from a project subsidized by the New Energy and Industrial Technology Development Organization (NEDO).</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#caret","title":"CARET","text":""},{"location":"changelog/#id","title":"v0.4.19 _ Oct 31, 2023","text":"<ul> <li>Update: Improvement of option specification of ros2 caret command. (ros2caret #129), (caret_doc #287), (caret #176)</li> </ul> <ul> <li>Update: Version update support for multimethod. (caret_analyze #403), (caret_analyze #398)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.18 _ Oct 16, 2023","text":"<ul> <li>New: Supported for iron tracepoint. (caret_analyze #318), (caret_trace #150), (ros2caret #84), (ros2caret #86)<ul> <li>Humble trace data and its analysis will still be available in later versions.</li> </ul> </li> <li>New: Added immediate recoding option to <code>ros2caret</code>. (ros2caret #123)</li> <li>New: Added an option to ros2caret to specify the size of the Lttng buffer. (ros2caret #85)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.17 _ Oct 03, 2023","text":"<ul> <li>Update: Improved <code>case</code> option for calculating the elapsed time specified for functions that graph response time. (caret_analyze #339), (caret_analyze #355)<ul> <li>Added new \"all\" option, which uses all input times in the same cycle to calculate the elapsed time.</li> <li>Renamed \"worst\" option to \"worst-with-external-latency\".</li> <li>Added new \"worst\" option, which uses the worst of all input times in the same cycle to calculate the elapsed time.</li> </ul> </li> </ul> CARET&lt;0.4.17 CARET&gt;=v0.4.7 N/A \"all\" \"best\" \"best\" N/A \"worst\" \"worst\" \"worst-with-external-latency\" <ul> <li>Update: Added <code>create_response_time_histogram_plot</code> function to graph response time as histogram. (caret_analyze #349)</li> <li>Fix: Improved measurement leaks in the first measurement after the host machine has been started up. (caret #142)</li> <li>Removed unnecessary dependent modules from caret_analyze_cpp_impl. (caret_analyze_cpp_impl #142), (caret_analyze #332)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.16.1 _ Sep 21, 2023","text":"<ul> <li>Fix: Fixed an issue that prevented CARETmeasurement when using cyclonedds 0.10.x. (caret #121)</li> <li>New: Added API to plot the response time of Paths as timeseries. (caret_analyze #322)</li> <li>Changed to temporarily specify the version of <code>setuptools</code> to be installed, as the latest <code>setuptools</code> causes error during CARET building. (caret_analyze #330)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.15 _ Sep 4, 2023","text":"<ul> <li>Updated the version of humble branch in tier4/rclcpp repository, which is forked from ros2/rclcpp, from 16.0.1 to 16.0.5. (rclcpp #4)</li> <li>Refactored and added APIs to calculate response time, these are a preparation to add options for visualizing graph in the future update. (caret_analyze #310), (caret_analyze #313), (caret_analyze #319)</li> <li>Fixed typo in CMakeLists.txt. (caret_analyze_cpp_impl #131)</li> <li>Specified Pandas library version as '&lt;2.1.0' to avoid problems with the Pandas library 2.1.0. (caret_analyze #324)</li> <li>Fixed to force loading process to ignore the second and subsequent callbacks even if \"Duplicated callback id\" occurs during CARET analyzing. (caret_analyze #314)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.14 _ Aug 21, 2023","text":"<ul> <li>Supported for function argument changes in <code>ros/ros2_tracing</code>. This support is in preparation for functionality improvements that will make rebuilding of the measurement application unnecessary. (rclcpp #2), (ros2_tracing #5), (caret_trace #136), (caret_analyze #302), (caret_doc #204)<ul> <li>This change affects trace data compatibility. However, this only affects cases where trace data captured after this update is analyzed by caret_analyze before this update. Please see the table below for the supported combinations.</li> </ul> </li> </ul> trace data (&lt;=0.4.13) trace data (&gt;=v0.4.14) caret_analyze (&lt;=v0.4.13) Supported Unsupported caret_analyze (&gt;=v0.4.14) Supported Supported <ul> <li>Adjusted Lttng buffer size to appropriate value. (ros2_tracing #6)</li> <li>Fixed a build error that occurred in environments older than Python 3.10. (ros2caret #81)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.13 _ Jul 24, 2023","text":"<ul> <li>Fixed a bug that delayed starting a measurement after <code>caret record</code> is launched depending on the time elapsed after the application being measured was launched. (caret_trace #129)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.12 _ Jul 10, 2023","text":"<ul> <li>Fixed a bug in the Plot class API that could not create graphs correctly when the <code>xaxis_type='sim_time'</code> option was specified. (caret_analyze #276), (caret_analyze #306)</li> <li>Fixed a bug that caused incorrect warnings to be output when using <code>ros2 caret check_ctf</code>. (caret_analyze #308)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.11 _ Jun 26, 2023","text":"<ul> <li>Applied to the type hinting for generics in standard collections adopted from Python 3.9. (caret_analyze #294), (caret_analyze #299)</li> <li>Fixed a segmentation fault problem that occurred depending on the condition of the data analyzed by caret_analyze. (caret_analyze_cpp_impl #79)</li> <li>Added <code>ros2 caret version</code> command to get the CARET version. (ros2caret #69)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.10 _ Jun 12, 2023","text":"<ul> <li>Update: Changed trace points used to tie records of inter-process communication. This change affects trace data compatibility. However, this only affects cases where trace data captured after this update is analyzed by caret_analyze before this update. In that case, update caret_analyze (caret_analyze #296), (caret_trace #113), (caret_doc #191), (ros2caret #70)<ul> <li>Please see the table below for the supported combinations</li> </ul> </li> </ul> trace data (&lt;=0.4.9) trace data (&gt;=v0.4.10) caret_analyze (&lt;=v0.4.9) Supported Unsupported caret_analyze (&gt;=v0.4.10) Supported Supported <ul> <li>Added remove functions to modify intra-node data path: <code>remove_variable_passing</code> and <code>remove_publisher_callback</code> (caret_analyze #297)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.9 _ May 15, 2023","text":"<ul> <li>Update:Improved path analysis to analyze paths that contain the same symbol object (caret_analyze #261), (caret_doc #183)</li> <li>Improved Plot class not to plot on a graph when communication is not established (caret_analyze #291), (caret_doc #184)</li> <li>Removed old modules: <code>node_graph</code> and <code>callback_graph</code> (caret_analyze #290)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.8 _ May 1, 2023","text":"<ul> <li>Removed deprecated interface such as <code>message_flow</code> (caret_analyze #179), (caret_analyze #274), (caret_analyze #282)</li> <li>Reduced warnings when loading trace data (caret_analyze #284)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.7 _ Apr 17, 2023","text":"<ul> <li>Refactored the Plot package design (caret_analyze #267), (caret_analyze #275), (caret_analyze #277), (caret_analyze #278), (caret_analyze #279), (caret_analyze #280)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.6 _ Apr 3, 2023","text":"<ul> <li>New: Added function to visualize response time with the stacked bar graph(caret_analyze #265, caret_analyze #259, caret_doc #169)</li> <li>Update: Added selective path definition to include or exclude first and last callback execution (caret_analyze #263, caret_analyze #271, caret_analyze #272, caret_analyze #273)</li> <li>Added a new function to get difference between two Architecture objects (caret_analyze #245, caret_doc #168)</li> <li>Removed deprecated interface such as <code>callback_sched</code> and <code>Plot.create_*_plot</code> (caret_analyze #266)</li> <li>Refactored visualization API such as <code>message_flow</code> (caret_analyze #267)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.5 _ Mar 20, 2023","text":"<ul> <li>Enhanced the trace filtering to exclude selected DDS events (caret_trace #101)</li> <li>Added the unit to the label of y-axis on time-series graph (caret_analyze #256)</li> <li>Refactored the Plot package (caret_analyze #257, caret_analyze #258)</li> <li>Added the docstring for explaining rename methods for Architecture object (caret_analyze #253)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.4 _ Feb 21, 2023","text":"<ul> <li>Fixed the time format of the time-series graphs (caret_analyze #255)</li> <li>Added the design documentation for trace filtering to exclude events in DDS-layer (caret_doc #158)</li> <li>Moved <code>get_range()</code> function to <code>record</code> package (caret_analyze #254)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.3 _ Feb 10, 2023","text":"<ul> <li>Fixed the bug preventing <code>check_ctf</code> from running properly after supporting activation/deactivation on runtime (caret_analyze #251)</li> <li>Suppressed update frequency of progress bar from <code>tqdm</code> when reading trace data (caret_analyze #248)</li> <li>Fixed incorrect annotation from <code>list</code> to <code>List</code> (caret_analyze #252)</li> <li>Changed <code>setup_caret.bash</code> script to prompt users to install the packages (caret #72)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.2 _ Jan 23, 2023","text":"<ul> <li>Added lightweight recording option to <code>ros2caret</code> (ros2caret #63)</li> <li>Removed old interface of <code>Plot.create_callback_jitter_plot</code> (caret_analyze #231)</li> <li>Refactored <code>Plot.create_callback_scheduling_plot</code> (caret_analyze #240)</li> <li>Added new API to combine two paths found by <code>Architecture.search_paths()</code> (caret_analyze #224)</li> <li>Fixed the bug in <code>Records</code> class (caret_analyze #246)</li> <li>Applied minor refactoring (caret_analyze #244, caret_analyze #243, caret_analyze #237, caret_analyze #234)</li> <li>Suppressed warning message outputted during runtime recording (caret_analyze #238, caret_analyze #236)</li> <li>Added <code>construction_order</code> item to identify multiple callbacks which have common symbol (caret_analyze #225)</li> </ul>"},{"location":"changelog/#id","title":"v0.4.1 _ Dec 26, 2022","text":"<ul> <li>New: Added functions to assign intra-node data path with <code>message_context</code> (caret_analyze #196)</li> <li>Update: Changed design of visualization API for refactoring to avoid usage of Pandas (caret_analyze #116, caret_analyze #167, caret_analyze #168, caret_analyze #170)</li> <li>Added configure file to control log level to suppress warning message (caret_analyze #220)</li> <li>Changed behavior of visualization to output empty graph if inputted data does not have any data rather than raising exception (caret_analyze #223)</li> <li>Fixed <code>ValueError</code>, when <code>create_publish_subscription_frequency_plot</code> is called with being inputted empty object (caret_analyze #227)</li> <li>Added metric name to tooltip for identifying plots on a graph</li> </ul>"},{"location":"changelog/#id","title":"v0.4.0 _ Dec 16, 2022","text":"<ul> <li>New: Added a new feature to start, stop, and resume even recording whenever users want to (caret_trace #68, caret_analyze #190, ros2caret #48, and caret_doc #126)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.4 _ Dec 12, 2022","text":"<ul> <li>New: Added functions to rename subsystems in Architecture object like executor, node, callback and topic (caret_analyze#156)</li> <li>Suppressed warning messages, which are outputted because <code>service</code> event is not supported, during trace data loading (caret_analyze#192)</li> <li>Fixed bug which calculated incorrect period or frequency (caret_analyze#213)</li> <li>Fixed error messages from <code>Mypy</code> (caret_analyze#211)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.3 _ Nov 28, 2022","text":"<ul> <li>Added guidances for a beginner to avoid getting stuck in unexpected cases (caret_analyze #200 and caret_analyze #186)</li> <li>Added <code>publishers</code> and <code>subscriptions</code> properties to <code>Architecture</code> and <code>Application</code> classes (caret_analyze #179, caret_analyze #180)</li> <li>Added function to update cache file named as <code>caret_converted</code> (caret_analyze#189)</li> <li>Suppressed unnecessary warnings in <code>check_caret_rclcpp</code> (ros2caret #53, ros2caret #54)</li> <li>Improved documentation of installation (caret_doc #111), configuration (caret_doc #112), visualization (caret_doc #98), and design (caret_doc#106)</li> <li>Fixed a bug which makes incorrect graphs (caret_analyze #201)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.2 _ Nov 14, 2022","text":"<ul> <li>Improved warning messages of caret_analyze (caret_analyze #144, caret_analyze #158, caret_analyze #162, caret_analyze #172, caret_analyze #182)</li> <li>Added properties of <code>publishers</code> and <code>subscriptions</code> to <code>Application</code> and <code>Architecture</code> object(caret_analyze #179)</li> <li>Improved ros2caret(ros2caret #44, ros2caret #50)</li> <li>Enlarged buffer size(ros2_tracing #2)</li> <li>Added some minor changes (caret_analyze #183, caret_analyze #187)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.1 _ Oct 31, 2022","text":"<ul> <li>Added record function to ros2caret for upcoming feature. (ros2caret #38)</li> <li>Added function to display histogram for response time (caret_analyze #165)</li> <li>Added API to calculate period and latency (caret_analyze #167, caret_analyze #168)</li> <li>Fixed some bugs (caret_analyze #141, caret_analyze #153, caret_analyze #157)</li> <li>Refactored <code>Architecture</code> object interface (caret_analyze)</li> <li>Added some minor changes (caret_analyze #139, caret_analyze #146, caret_analyze #147, caret_analyze #151, caret_analyze #159, caret_analyze #162, caret_analyze #165, caret_analyze#171)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.0 _ Sept 26, 2022","text":"<ul> <li>Supported OS: Ubuntu 22.04</li> <li>Supported ROS Dist.: ROS Humble</li> <li>Imported to Ubuntu 22.04 and ROS Humble</li> <li>Added new feature to show response time (caret_analyze #96)</li> <li>Added new APIs to visualize frequency, period, and latency of publishes, subscriptions, and communications (caret_analyze #124, #130, #133, #134, #136, #140)</li> <li>Reduced memory consumption wasted for recorded data (caret_analyze #100)</li> <li>Launched caret_analyze API document</li> <li>Added small fixes<ul> <li>caret_analyze #107</li> <li>caret_analyze #107</li> <li>caret_analyze #108</li> <li>caret_analyze #109</li> <li>caret_analyze #112</li> <li>caret_analyze #115</li> </ul> </li> </ul>"},{"location":"changelog/#id","title":"v0.2.3 _ July 14, 2022","text":"<ul> <li>Supported OS: Ubuntu 20.04</li> <li>Supported ROS Dist.: ROS Galactic</li> <li>Improved output message from <code>path.verify()</code> method</li> <li>Improved view of graphs</li> <li>Added wildcard support for <code>Architecture.callbacks()</code> method</li> <li>Added command line function to check trace data</li> <li>Fixed specification of <code>Architecture.search_paths()</code> method</li> <li>Added function to extract duplicated timer callback</li> </ul>"},{"location":"changelog/#id","title":"v0.2.2 _ May 2, 2022","text":"<ul> <li>Supported OS: Ubuntu 20.04</li> <li>Supported ROS Dist.: ROS Galactic</li> <li>Added feature to measure complicated node path</li> <li>Added feature to choose optional trace points</li> <li>Added <code>Architecture.search_paths()</code> method</li> <li>Improved trace filtering function</li> </ul>"},{"location":"gallery/","title":"Gallery","text":"<p>This page shows examples of figures that can be visualized in CARET. If you find what you are interested in, please access to a link embedded in a headline.</p>"},{"location":"gallery/#callback","title":"Callback","text":""},{"location":"gallery/#execution-frequency","title":"Execution frequency","text":""},{"location":"gallery/#timestamp-tables","title":"Timestamp tables","text":""},{"location":"gallery/#time-series-graph","title":"Time-series graph","text":""},{"location":"gallery/#execution-period","title":"Execution period","text":""},{"location":"gallery/#timestamp-tables_1","title":"Timestamp tables","text":""},{"location":"gallery/#time-series-graph_1","title":"Time-series graph","text":""},{"location":"gallery/#latency-or-execution-time","title":"Latency (or Execution time)","text":""},{"location":"gallery/#timestamp-tables_2","title":"Timestamp tables","text":""},{"location":"gallery/#time-series-graph_2","title":"Time-series graph","text":""},{"location":"gallery/#callback-scheduling-visualization","title":"Callback Scheduling Visualization","text":""},{"location":"gallery/#timing-chart-of-callback-scheduling","title":"Timing chart of callback scheduling","text":""},{"location":"gallery/#communication","title":"Communication","text":""},{"location":"gallery/#frequency","title":"Frequency","text":""},{"location":"gallery/#period","title":"Period","text":""},{"location":"gallery/#latency","title":"Latency","text":""},{"location":"gallery/#publishsubscribe-frequency","title":"Publish/Subscribe Frequency","text":""},{"location":"gallery/#publishsubscribe-period","title":"Publish/Subscribe Period","text":""},{"location":"gallery/#path","title":"Path","text":""},{"location":"gallery/#message-flow","title":"Message flow","text":""},{"location":"gallery/#response-time-histogram","title":"Response Time Histogram","text":""},{"location":"gallery/#chain-latency","title":"Chain latency","text":""},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#introduction","title":"Introduction","text":"<p>Configuration is a phase where users tell CARET which data path is targeted for visualization.</p> <p>CARET is capable of recording enormous numbers of events even when a large application runs. The large application may have lots of data paths, but most users must not want to observe all of data paths. If CARET kindly shows analysis results for all of possible data paths, users will be overwhelmed and exhausted to deal with large amount of results.</p> <p>For delivering efficient analysis, CARET is designed to show analysis results on demand. CARET serves user functions to select target data paths to fulfill their interests.</p> <p>In addition to defining targeted path, CARET will ask users to define node latency before users analyze their application with visualization.</p> <p>The rest of this chapter will explain the following two types of sections;</p> <ul> <li>The detailed background of configuration</li> <li>The basic procedure for preparing desired configuration</li> </ul> <p>In detail, the following sections are listed as below.</p> <ul> <li>Background of configuration section will explain detailed background of configuration phase</li> <li>How to load and save section will tell you how to load and save configuration</li> <li>How to define inter-node data path section will tell you how to use <code>architecture.search_paths()</code></li> <li>How to define intra-node data path will let you know what <code>message_context</code> is. This is advanced topic than others</li> <li>How to rename sub-objects section will tell you how to use <code>rename_XXX()</code></li> <li>How to get difference of two architectures will tell you how to use <code>diff_XXX_YYY()</code> functions</li> <li>Practical example with caret_demos will demonstrates configuration process on <code>caret_demos</code> Visualization of application structure will be prepared as an appendix which shows another usage of an architecture object. CARET can show structure of a targeted application while it is a performance analysis tool. This appendix will be disclosed in the near future also.</li> </ul>"},{"location":"configuration/architecture_diff_func/","title":"How to get differences of architectures","text":"<p>An architecture object has structure of a target application. It is useful when you want to find the structure. In some cases, you want to check difference between the current version and the previous one of the target application. The difference tells you which executor, node, callback, or topic is updated. CARET serves the function to get difference between two architecture objects. This function is called <code>diff</code> function in the following.</p> <p>The <code>diff</code> function can be used to find the difference between two architecture objects. Specifically, the <code>diff</code> functions can find data that exist only in one of the architectures, such as node, published topics, subscribed topics, and etc. There are several <code>diff</code> functions, which can be divided into functions that compare the entire architecture and functions that compare nodes within the architecture.</p> <p>The <code>diff</code> function is explained in the following sections. Before using the <code>diff</code> functions, the two architecture objects are loaded onto memory beforehand, as shown in the following script.</p> <pre><code>from caret_analyze import Architecture\nleft_arch = Architecture('yaml', 'old_architecture.yaml')\nright_arch = Architecture('yaml', 'new_architecture.yaml')\n</code></pre>"},{"location":"configuration/architecture_diff_func/#how-to-compare-architecture","title":"How to compare architecture","text":"<p>The functions <code>diff_node_names()</code> and <code>diff_topic_names()</code> compare two architecture objects by finding the node names and topic names, respectively, that exist only in one of the two objects. <code>diff_node_names()</code> will show you which node is added or deleted in the new version of the target application. <code>diff_topic_names()</code> shows you which topic is added or deleted.</p>"},{"location":"configuration/architecture_diff_func/#diff_node_names","title":"diff_node_names()","text":"<p>The <code>diff_node_names()</code> function returns the name of the node whose name appears only in one of the two given architecture objects.</p> <pre><code># sample_1\n\n# get node names that are only in left_arch and right_arch respectively\nleft_only_node_names, right_only_node_names = Architecture.diff_node_names(left_arch, right_arch)\n\n# display differences\nprint(left_only_node_names)\nprint(right_only_node_names)\n</code></pre> <p>Two architectures are given to <code>diff_node_names()</code>. Two tuples containing node names are returned if they have any different nodes. If they are have the same nodes at all, <code>diff_node_names()</code> returns two empty tuples.</p>"},{"location":"configuration/architecture_diff_func/#diff_topic_names","title":"diff_topic_names()","text":"<p>The <code>diff_topic_names()</code> function returns the name of the topic whose name appears only in one of the two given architecture objects.</p> <pre><code># sample_2\n\n# get topic names that are only in left_arch and right_arch respectively\nleft_only_topics, right_only_topics = Architecture.diff_topic_names(left_arch, right_arch)\n\n# display differences\nprint(left_only_topics)\nprint(right_only_topics)\n</code></pre> <p>Two architectures are given to <code>diff_topic_names()</code>. Two tuples containing topic names are returned if they have any different topics. If they are have the same topics at all, <code>diff_topic_names()</code> returns two empty tuples.</p> <p> <p>Info</p> <p>The architecture object has other elements such as Executor and Callback. However, the functions that get the difference of Executors or Callbacks are not yet implemented. Please contact the developers if needed.</p> <p>"},{"location":"configuration/architecture_diff_func/#how-to-compare-node-in-architecture","title":"How to compare node in architecture","text":"<p>The <code>diff_node_pubs()</code> and <code>diff_node_subs()</code> function find the published and subscribed topics, respectively, that exist only in one of the two nodes. <code>diff_node_pubs()</code> will show you which publishing topic is added or deleted in the new version of the target node. <code>diff_node_subs()</code> shows you which subscribed topic is added or deleted.</p>"},{"location":"configuration/architecture_diff_func/#diff_node_pubs","title":"diff_node_pubs()","text":"<p>The <code>diff_node_pubs()</code> function returns the name of the published topic whose name appears only in one of the two nodes.</p> <pre><code># sample_3\n\nleft_node = left_arch.get_node('node1')\nright_node = right_arch.get_node('node1')\n\n# get publish topic names that are only in left_node and right_node respectively\nleft_only_pub_topics, right_only_pub_topics = Architecture.diff_node_pubs(left_node, right_node)\n\n# display differences\nprint(left_only_pub_topics)\nprint(right_only_pub_topics)\n</code></pre> <p>Two nodes, whose types are <code>NodeStructValue</code>, are given to <code>diff_node_pubs()</code>. Two tuples containing topic names are returned if they have any different published topics. If they are have the same topics at all, <code>diff_node_pubs()</code> returns two empty tuples.</p>"},{"location":"configuration/architecture_diff_func/#diff_node_subs","title":"diff_node_subs()","text":"<p>The <code>diff_node_subs()</code> function returns the name of the subscribed topic whose name appears only in one of the two nodes.</p> <pre><code># sample_4\n\nleft_node = left_arch.get_node('node1')\nright_node = right_arch.get_node('node1')\n\n# get subscribe topic names that are only in left_node and right_node respectively\nleft_only_sub_topics, right_only_sub_topics = Architecture.diff_node_subs(left_node, right_node)\n\n# display differences\nprint(left_only_sub_topics)\nprint(right_only_sub_topics)\n</code></pre> <p>Two nodes, whose types are <code>NodeStructValue</code>, are given to <code>diff_node_subs()</code>. Two tuples containing topic names are returned if they have any different subscribed topics. If they are have the same topics at all, <code>diff_node_subs()</code> returns two empty tuples.</p>"},{"location":"configuration/background/","title":"Background","text":"<p>CARET is mainly capable of showing the following 4 latency:</p> <ul> <li>callback latency</li> <li>communication latency (inter-node)</li> <li>node latency (intra-node)</li> <li>path latency (intra-node &amp; inter-node)</li> </ul> <p>The following figure shows definition of node latency and path latency.</p> <p></p> <p>Callback latency is defined as execution time of a callback function, and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in an application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configurable object , called \"architecture object\".</p>"},{"location":"configuration/background/#architecture-object","title":"Architecture object","text":"<p>An architecture object has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can load an architecture object including only application structure section from CTF-based recorded data. The application structure section remains same unless the structure is changed or component is renamed.</p> <p>On the other hand, latency definition section in the original architecture object is empty just before users add any definition. Users are expected to add definitions of node latency and path latency to the original architecture object. CARET helps users to add definition of node and path latency.</p> <p>The following sections explain how to load an architecture object and add latency definition.</p>"},{"location":"configuration/inter_node_data_path/","title":"How to define inter-nodes data path","text":"<p>Latency definition section is empty just after an architecture object is loaded from a set of CTF-based recorded data. If you want to observe data flow on targeted paths, you should add the target paths to the architecture object. As a path is combination of multiple nodes and topics, it may be laborious to list their names. To mitigate such burden, CARET serves a function to search the targeted path. The targeted path is added to the architecture object via Python API.</p>"},{"location":"configuration/inter_node_data_path/#basic-usage-to-find-and-add-target-path","title":"Basic usage to find and add target path","text":"<p>Listing nodes and topics by their names is laborious. CARET serve a helpful method, <code>arch.search_paths</code>, to search candidates that you want to observe.</p> <p>The following sample code shows usage of <code>arch.search_paths</code> method.</p> <pre><code># Architecture object is loaded to variable of arch\n\npaths = arch.search_paths('source_node',\n                          'destination_node')\n\ntype(paths) # list of multiple paths\npaths[0].summary.pprint() # shows nodes and topics in paths[0]\n</code></pre> <p>In the sample, <code>paths</code> is a list including all possible paths between <code>source_node</code> and <code>destination_node</code>, whose type is <code>PathStructValue</code>. If you are satisfied with output from <code>paths[0].summary.pprint()</code>, you have to add <code>paths[0]</code> to the <code>arch</code> object as below.</p> <pre><code>arch.add_path('target_path', paths[0])\n\narch.export('new_architecture_with_path.yaml')\n</code></pre> <p>In the above sample, <code>paths[0]</code> is named as <code>target_path</code> and registered to the <code>arch</code> object. <code>arch</code> object is exported to a new architecture file for reuse.</p> <p>If you want to restore the <code>paths[0]</code> object with <code>new_architecture_with_path.yaml</code> file, <code>arch.get_path()</code> method will help you to do so.</p> <pre><code>arch = Architecture('yaml', 'new_architecture_with_path.yaml')\n\npath = arch.get_path('target_path') # path object is same as paths[0] in the previous sample\n</code></pre>"},{"location":"configuration/inter_node_data_path/#efficient-target-path-search","title":"Efficient target path search","text":"<p>As explained above, <code>Architecture.search_paths()</code> returns list of multiple paths. The list size will be too large to find target path if application has large numbers of nodes and distance between source and destination node is long. In worse case, <code>Architecture.search_paths()</code> keep searching and does not return <code>paths</code> variable after hours passes.</p> <p><code>Architecture.search_paths()</code> method serves four options to narrow down possible paths as below.</p> <ol> <li>Additional nodes as variable length arguments</li> <li>Limiting maximum number of nodes between given nodes with <code>max_node_depth</code></li> <li>Node filter which excludes paths including specific nodes</li> <li>Communication filter which excludes paths including specific topics</li> </ol> <p>In short, <code>Architecture.search_paths</code> is defined as follows.</p> <pre><code>search_paths(\n    *node_names: 'str',\n    max_node_depth: 'Optional[int]' = None,\n    node_filter: 'Optional[Callable[[str], bool]]' = None,\n    communication_filter: 'Optional[Callable[[str], bool]]' = None\n) -&gt; 'List[PathStructValue]'\n</code></pre> <p>The following sub-sections will explain their roles and usages in details.</p>"},{"location":"configuration/inter_node_data_path/#additional-nodes","title":"Additional nodes","text":"<p>In the previous example, <code>Architecture.search_paths()</code> had two arguments <code>source_node</code> and <code>destination_node</code>. However, the number of nodes given to <code>Architecture.search_paths()</code> is variable and not always two. You can add other nodes to <code>Architecture.search_paths()</code> as below, and you will get a list including multiple paths which passes all given nodes.</p> <pre><code># Architecture object is loaded to variable of arch\n\npaths = arch.search_paths('source_node',\n                          'intermediate_node_1',\n                          'intermediate_node_2',\n                          'destination_node')\n</code></pre> <p><code>paths</code> is a list including multiple paths which pass <code>source_node</code>, <code>intermediate_node_1</code>, <code>intermediate_node_2</code>, and <code>destination_node</code>. They are allowed to pass another node, but all chosen nodes are passed in order.</p>"},{"location":"configuration/inter_node_data_path/#limiting-maximum-number-of-nodes","title":"Limiting maximum number of nodes","text":"<p><code>Architecture.search_paths()</code> will scan all paths as possible if you don't give <code>max_node_depth</code> argument. <code>max_node_depth</code> means maximum number between given nodes. The number of candidate paths will be suppressed by this argument.</p> <p>This argument will be helpful When you waste much time for <code>Architecture.search_paths()</code>.</p> <p>The usage is shown as below. This can be used with another approach to filter candidates.</p> <pre><code># Architecture object is loaded to variable of arch\n\npaths = arch.search_paths('source_node',\n                          'intermediate_node_1',\n                          'destination_node',\n                          max_node_depth=10)\n</code></pre> <p><code>max_node_depth</code> does not always limit the maximum number of nodes between source and destination. If you give 3 nodes to <code>arch.search_paths</code> as shown above, <code>max_node_depth</code> does not limits the maximum number of nodes between <code>source_node</code> and <code>destination_node</code>. In this example, <code>max_node_depth</code> limits the number of nodes between <code>source_node</code> and <code>intermediate_node_1</code>, and that between <code>intermediate_node_1</code> and <code>destination_node</code>.</p>"},{"location":"configuration/inter_node_data_path/#node-and-topic-filter","title":"Node and topic filter","text":"<p>As node filter is similar to communication filter, they are explained together in this section.</p> <p>With node filter and communication filter, <code>Architecture.search_paths()</code> excludes paths which includes selected nodes or topics. They support regular expression.</p> <p>The following sample code shows usage.</p> <pre><code>import re\n\n# name list of nodes to be excluded\nnode_filters = [\n    re.compile(r'/_ros2cli_/*'),\n    re.compile(r'/launch_ros_*'),\n]\n\n# name list of topics to be excluded\ncomm_filters = [\n    re.compile(r'/tf/*'),\n]\ndef comm_filter(topic_name: str) -&gt; bool:\n    can_pass = True\n    for comm_filter in comm_filters:\n        can_pass &amp;= not bool(comm_filter.search(topic_name))\n    return can_pass\n\ndef node_filter(node_name: str) -&gt; bool:\n    can_pass = True\n    for node_filter in node_filters:\n        can_pass &amp;= not bool(node_filter.search(node_name))\n    return can_pass\n\npaths = arch.search_paths(\n    '/start_node',\n    '/intermediate_node'\n    '/end_node',\n    max_node_depth=30,\n    node_filter = node_filter,\n    communication_filter = comm_filter)\n</code></pre>"},{"location":"configuration/inter_node_data_path/#path-combining","title":"Path combining","text":"<p><code>Architecture.combine_path()</code> combines two paths which are found by <code>Architecture.search_paths()</code>. By searching short paths and combining them repeatedly, you can get a target path. It is sometimes more efficient than searching a longer path directly according to \"divide-and-conquer\" method.</p> <p>Usage of <code>Architecture.combine_path()</code> is as following.</p> <pre><code>paths_1 = arch.search_paths('source_node',\n                            'intermediate_node')\npaths_2 = arch.search_paths('intermediate_node',\n                            'destination_node')\ntarget_path = arch.combine_path(paths_1[0], paths_2[0])\n\narch.add_path('combined_path_name', target_path)\narch.export('new_architecture.yaml')\n</code></pre> <p>An exception is raised for pairs that cannot be combined.</p>"},{"location":"configuration/inter_node_data_path/#considering-firstlast-callback","title":"Considering first/last callback","text":"<p>In CARET, the path is defined as <code>[node_name]-[topic_name]-... -[topic_name]-[node_name]</code> (for more information in Path). In the default configuration, the path analysis does not include the callback processing time either at the first node or at the last node of the above path. The following two processing times are not included by default in path analysis.</p> <ul> <li>Processing time in the first node; from <code>callback_start</code> to <code>rclcpp_publish</code> or <code>rclcpp_intra_publish</code></li> <li>Processing time in the last node; from <code>callback_start</code> to <code>callback_end</code></li> </ul> <p>These processing times are evaluated using the following options.</p> <ul> <li><code>Path.include_first_callback</code><ul> <li>Default: <code>False</code></li> <li>If <code>True</code>, the processing time in the first node is included in the path analysis. The callback_start in the first node is that of a trace data whose timestamp is the closest to publish and thread id (tid) is the same as publish. Note that a callback object of the callback_start in the first node can vary if the node has several callbacks and any of them runs before publish.</li> </ul> </li> <li><code>Path.include_last_callback</code><ul> <li>Default: <code>False</code></li> <li>If <code>True</code>, the processing time in the last node is included in the path analysis.</li> </ul> </li> </ul> <p>Usage of <code>Path.include_first_callback/include_last_callback</code> is as following.</p> <pre><code>app = Application(arch, lttng)\n\npath_name = 'target_path'\ntarget_path = app.get_path(path_name)\n\ntarget_path.include_first_callback = True     # Include first callback in path analysis.\ntarget_path.include_last_callback = True      # Include last callback in path analysis.\n</code></pre>"},{"location":"configuration/intra_node_data_path/","title":"How to define intra-node data path","text":"<p>In the previous section, you learned how to define inter-node data path. CARET can calculate response time for a simple path using only inter-node data path definition. However, when a target application or path becomes complicated, intra-node-data path needs to be defined as well as inter-node data path.</p> <p>CARET assume that intra-node data path is mapping of topic subscription and publish in a node. This is not defined simply because the definition depends on implementation.</p> <p>This section will explain how to find which intra-node data path you have to define, and how to define it.</p>"},{"location":"configuration/intra_node_data_path/#find-which-intra-node-data-path-to-define","title":"Find which intra-node data path to define","text":"<p>Before defining intra-node data path, you have to check whether latency of the target path is calculable. This can be checked with <code>Path.verify()</code> method as the following sample code shows.</p> <pre><code>arch = Architecture('yaml', '/path/to/architecture.yaml')\n\npath = arch.get_path('target_path')\npath.verify()\n</code></pre> <p>Here, <code>path.verify()</code> returns <code>True</code> if path latency for <code>path</code> is calculable. Otherwise, you will confront with warning messages as shown below.</p> <p>Example 1.</p> <pre><code>WARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/message_driven_node')\nmessage_context: null\nnode: /message_driven_node\npublish_topic_name: /topic3\nsubscribe_topic_name: /topic2\n\nWARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/timer_driven_node')\nmessage_context: null\nnode: /timer_driven_node\npublish_topic_name: /topic4\nsubscribe_topic_name: /topic3\n</code></pre> <p>Example 2.</p> <pre><code>WARNING : 2022-03-18 12:53:54 | 'caret/rclcpp' may not be used in subscriber of '/topic/name'.\n</code></pre> <p>On the sample warning message of <code>Example 1</code>, <code>/message_driven_node</code> and <code>/timer_driven_node</code> have undefined intra-node data path. You will add the intra-node data path in next step.</p> <p>On the other message, <code>Example 2</code>, the node which subscribes <code>/topic/name</code> topic has not compiled with caret/rclcpp. Please check here.</p>"},{"location":"configuration/intra_node_data_path/#message-context","title":"Message Context","text":"<p>CARET assumes that node latency is defined as duration from subscription time to publish time. The definition looks simple, but node latency is difficult to define mechanically because some nodes have multiple inputs or multiple outputs.</p> <p>CARET require users to define <code>message_context</code> to calculate node latency. One of the following policies is acceptable for <code>message_context</code>.</p> <ul> <li><code>use_latest_message</code></li> <li><code>callback_chain</code></li> </ul> <p>They have different capability to measure node latency, and the selected <code>message_context</code> policy decides how to calculate node latency. However, <code>message_context</code> is a little difficult for CARET beginners without any example. The subsequence section introduces an example issue before explaining the policies.</p> <p>These two policies are not enough to cover the arbitrary node latency, and some implementations have node latency that cannot be measured. For example, message filter is currently unable to measure.</p>"},{"location":"configuration/intra_node_data_path/#example-issue","title":"Example issue","text":"<p>An example issue on <code>/ping_node</code> and <code>/pong_node</code> is given as the below figure shows.</p> <p></p> <p>Next items are explaining <code>/ping_node</code> and <code>/pong_node</code>.</p> <ul> <li><code>/ping_node</code><ul> <li>it transmit messages of <code>/ping</code> topic to <code>/pong_node</code></li> <li>it is composed of a single callback function</li> </ul> </li> <li><code>/pong_node</code><ul> <li>it transmits message of <code>/pong</code> topic to another node</li> <li>it is composed of two callback functions; <code>subscription_callback_0</code> and <code>timer_callback_1</code></li> <li>it receives messages of <code>/ping</code> topic from <code>/pong_node</code> via <code>subscription_callback_0</code></li> <li><code>subscription_callback_0</code> shares messages <code>/ping</code> topic with <code>timer_callback_1</code> via shared variable</li> <li><code>timer_callback_1</code> produces <code>/pong</code> with the shared messages</li> <li><code>timer_callback_1</code> runs about 8/5 as frequent as <code>timer_callback_0</code></li> </ul> </li> </ul> <p>CARET is concerned which input topic message is mapped to an output message. <code>message_context</code> is provided to map input messages to output messages.</p>"},{"location":"configuration/intra_node_data_path/#use_latest_message","title":"<code>use_latest_message</code>","text":"<p>With <code>use_latest_message</code> policy, CARET will map a most recent input message to output message. CARET focuses on input and output,but is not concerned structure of node structure. The next figure shows how CARET defines node latency with <code>use_latest_message</code> in the example issue.</p> <p></p> <p>In the figure, latest messages of <code>ping</code> topic is mapped to messages of <code>/pong</code> topic mechanically by CARET. It is not still easy to understand with only the block figure, but the provided timing chart below help you to understand what <code>use_latest_message</code> is.</p> <p></p> <p>In the timing chart, colored boxes represent duration of callback running, and bold lines are message flow of topic message. Dotted lines indicates mapping between input messages and outputs. With <code>use_latest_message</code>, CARET assumes that output message is made from the most recent input message. <code>use_latest_message</code> is fairly simple and works well in most cases.</p> <p>In the timing chart, red dotted lines explains a pitfall of <code>use_latest_message</code>. Using <code>use_latest_message</code> policy, CARET believes that input message, which is not even processed completely, is mapped to output message. For example, CARET interprets that <code>/pong[4]</code> is made from <code>/ping[2]</code> because <code>/ping[2]</code> is the recent input message for <code>/pong[4]</code>. However, <code>subscription_callback_0</code> is processing <code>/ping[2]</code> and does not share it with <code>timer_callback_1</code> before publishing <code>/pong[4]</code>. You have to tell CARET the node structure when you find such pitfall.</p>"},{"location":"configuration/intra_node_data_path/#callback_chain","title":"<code>callback_chain</code>","text":"<p><code>callback_chain</code> is introduced for CARET to map input messages to outputs based on inter-operation of multiple callback functions. Input messages are consumed in subscription callbacks and propagated to other nodes. It looks as if input messages passes chains of multiple callbacks to make output messages. With <code>callback_chain</code>, CARET take care of input propagation on callbacks and it is helpful to escape the limitation of <code>use_latest_message</code> as mentioned above.</p> <p>Next figure shows how CARET interprets intra-node data path using <code>callback_chain</code>. Intra-communication between <code>subscription_callback_0</code> and <code>timer_callback_1</code> is taken into account for defining intra-node data path. <code>variable_passings</code> is a tag used in CARET, and represents such intra-communication.</p> <p></p> <p>The following timing chart shows how input messages are mapped to output messages.</p> <p></p> <p>CARET maps mechanically messages of <code>/pong</code> topic to messages of <code>/ping</code> which finish being processed on <code>subscription_callback_0</code>. The unexpected behavior of <code>use_latest_message</code> is improved by <code>callback_chain</code>.</p> <p><code>callback_chain</code> looks the best choice. However, it has several drawbacks.</p> <ul> <li>It is not designed for node which have multiple callbacks running at parallel, and response time might be longer than actual</li> <li>It is not able to detect actual time when buffered data are consumed because only CARET does not trace user code on ROS 2</li> <li>Users are expected to know node structure beforehand</li> </ul> <p> <p>Info</p> <p><code>use_latest_message</code> and <code>callback_chain</code> do not cover all of use cases for CARET. We, CARET development team, continue improvements of intra-node data path definition.</p> <p>"},{"location":"configuration/intra_node_data_path/#define-intra-node-data-path-to-the-architecture-fileobject","title":"Define intra-node data path to the Architecture file/object","text":"<p>In order to measure latency in the inter-node data path, the Architecture file must be edited to match the entity of the application to be measured.</p> <p>There are two ways to define inter-node data path.</p> <ol> <li>Directly editing the architecture file with an editor or similar tools</li> <li>Manipulating the Architecture object using the Python API</li> </ol> <p>Both methods will yield the same results as long as it is defined correctly, so define the data path as you prefer.</p>"},{"location":"configuration/intra_node_data_path/#directly-editing-the-file","title":"Directly editing the file","text":"<p>This section explain how to add intra-node data path definition with editing an architecture file. The example issue above is used for explanation.</p>"},{"location":"configuration/intra_node_data_path/#use_latest_message_1","title":"<code>use_latest_message</code>","text":"<p>Next sample description is required for using <code>use_latest_message</code> on an architecture file. <code>use_latest_message</code> is applied to <code>/pong_node</code> in the next sample description. Essential description is extracted in the following snippet, but you will confront with busy YAML file actually rather than the sample.</p> <p>You have to add <code>use_latest_message</code> as <code>context_types</code> between targeted subscription and publisher.</p> <pre><code>- node_name: /pong_node\n  callbacks:\n    - callback_name: subscription_callback_0\n    - callback_name: timer_callback_1\n  publishes:\n    - topic_name: /pong\n      callback_names:\n        - timer_callback_1 # manually added\n  subscribes:\n    - topic_name: /ping\n      callback_name: subscription_callback_0\n  message_contexts:\n    - context_type: use_latest_message # manually added\n      subscription_topic_name: /ping\n      publisher_topic_name: /pong\n</code></pre>"},{"location":"configuration/intra_node_data_path/#callback_chain_1","title":"<code>callback_chain</code>","text":"<p>On the other hand, CARET requires users to provide the following description if you apply <code>callback_chain</code> to <code>/pong_node</code>.</p> <pre><code>- node_name: /pong_node\n  callbacks:\n    - callback_name: subscription_callback_0\n    - callback_name: timer_callback_1\n  variable_passings:\n    - callback_name_write: subscription_callback_0 # manually added\n      callback_name_read: timer_callback_1 # manually added\n  publishes:\n    - topic_name: /ping\n      callback_names:\n        - timer_callback_1 # manually added\n  subscribes:\n    - topic_name: /pong\n      callback_name: timer_callback_1\n  message_contexts:\n    - context_type: callback_chain # manually added\n      subscription_topic_name: /pong\n      publisher_topic_name: /ping\n</code></pre> <p>User have to fill callback name in <code>variable_passings</code>, <code>publishes</code>'s <code>callback_name</code>. <code>context_type</code> must be set as <code>callback_chain</code>. After editing, use path.verify() described in the beginning of this section to verify that it has been set correctly.</p>"},{"location":"configuration/intra_node_data_path/#manipulating-the-object","title":"Manipulating the object","text":"<p>CARET serves Python APIs to define intra-node data path. The following commands enable the <code>Architecture file editing</code> done in the previous section to be implemented by Python commands.</p> <p>All of the following code snippets can be executed after loading an architecture object using the <code>Architecture('type', 'file_path')</code> method. The architecture object whose sub-objects are renamed is saved to a file as explained in the previous page.</p>"},{"location":"configuration/intra_node_data_path/#use_latest_message_2","title":"<code>use_latest_message</code>","text":"<p>Using the following Python API to use <code>use_latest_message</code> on an architecture object. The examples below follow the previous section.</p> <ul> <li> <p>You can add a callback to a publisher with <code>insert_publisher_callback</code> function in <code>Architecture</code> class.</p> <ul> <li>As arguments, the target node name, publishing topic name and publisher callback name must be specified.</li> </ul> </li> </ul> <ul> <li>You can update <code>context_types</code> to <code>use_latest_message</code> between targeted subscription and publisher with <code>update_message_context</code> function in <code>Architecture</code> class.<ul> <li>As arguments, the target node name, subscription topic name and publisher topic name must be specified.</li> </ul> </li> </ul> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.insert_publisher_callback('/pong_node', '/pong', 'timer_callback_1')\narch.update_message_context('/pong_node', '/ping', '/pong', 'use_latest_message')\n</code></pre> <p>As a result of these processes, the data path is defined as <code>use_latest_message</code>. The edited architecture file is output by <code>arch.export()</code> function.</p> <p>If you want to disable the intra-node data path of <code>use_latest_message</code>, specify 'UNDEFINED' in the message context using the following Python API.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.remove_publisher_callback('/pong_node', '/pong', 'timer_callback_1')\narch.update_message_context('/pong_node', '/ping', '/pong', 'UNDEFINED')\n</code></pre>"},{"location":"configuration/intra_node_data_path/#callback_chain_2","title":"<code>callback_chain</code>","text":"<p>Using the following Python API to use <code>callback_chain</code> on an architecture object. The examples below follow the previous section.</p> <ul> <li> <p>You can add a callback to a publisher with <code>insert_publisher_callback</code> function in <code>Architecture</code> class.</p> <ul> <li>As arguments, the target node name, publishing topic name and publisher callback name must be specified.</li> </ul> </li> </ul> <ul> <li> <p>You can add variable passing with <code>insert_variable_passing</code> function in <code>Architecture</code> class.</p> <ul> <li>As arguments, the target node name, write callback name and read callback name must be specified.</li> </ul> </li> </ul> <ul> <li>You can update <code>context_types</code> to <code>callback_chain</code> between targeted subscription and publisher with <code>update_message_context</code> function in <code>Architecture</code> class.<ul> <li>As arguments, the target node name, subscription topic name and publisher topic name must be specified.</li> </ul> </li> </ul> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.insert_publisher_callback('/pong_node', '/pong', 'timer_callback_1')\narch.insert_variable_passing('/pong_node', 'subscription_callback_0', 'timer_callback_1')\narch.update_message_context('/pong_node', '/ping', '/pong', 'callback_chain')\n</code></pre> <p>As a result of these processes, data path is defined as <code>callback_chain</code>. The edited architecture file is output by <code>arch.export()</code> function.</p> <p>If you want to disable the intra-node data path of <code>callback_chain</code>, specify 'UNDEFINED' in the message context using the following Python API.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.remove_publisher_callback('/pong_node', '/pong', 'timer_callback_1')\narch.remove_variable_passing('/pong_node', 'subscription_callback_0', 'timer_callback_1')\narch.update_message_context('/pong_node', '/ping', '/pong', 'UNDEFINED')\n</code></pre>"},{"location":"configuration/load_and_save/","title":"How to load and save an architecture object","text":"<p>The first step of configuration is to load an architecture object from a set of CTF-based recorded data onto memory. You can update the architecture object as the following section explains. After you finish updating it, you can save it to a yaml-based file, called \"architecture file\" to reuse the updated object.</p> <p>An architecture file has structure of a targeted application. <code>dear_ros_node_viewer</code> help you to comprehend structure of the application with the architecture file.</p>"},{"location":"configuration/load_and_save/#python-api","title":"Python API","text":"<p>CARET serves Python-based APIs to load and save an architecture object.</p> <p>All of the following code snippets can be executed after load environment variables with <code>source /path/to/ros2_caret_ws/install/setup.bash</code>.</p>"},{"location":"configuration/load_and_save/#load-from-a-set-of-ctf-based-recorded-data","title":"Load from a set of CTF-based recorded data","text":"<p>You can load an architecture object with <code>Architecture</code> constructor.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('lttng', '/path/to/ctf-based_recorded_data')\n</code></pre> <p>You will find <code>caret_analyze.architecture.Architecture</code>-based object, named '<code>arch</code>'.</p> <p>Loading an architecture object from CTF-based recorded data tends to be time-consuming task.</p>"},{"location":"configuration/load_and_save/#load-from-a-yaml-based-architecture-file","title":"Load from a YAML-based architecture file","text":"<p>As I mentioned, CARET serves a function to stored an architecture object into YAML-based architecture file for reusability. It can save loading time and preserve update of the object. You can load it from YAML-based file with only replacing '<code>lttng</code>' of the first argument of <code>Architecture</code> constructor by '<code>yaml</code>'.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('yaml', '/path/to/architecture.yaml')\n</code></pre> <p>It is recommended for you to use YAML-based file to benefit from reusability unless structure of targeted application is changed.</p>"},{"location":"configuration/load_and_save/#save","title":"Save","text":"<p>CARET provides <code>Architecture.export</code> method to save an architecture object as follow.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\n\narch.export('/path/to/destination/architecture.yaml')\n\n! readlink -f /path/to/destination//architecture.yaml\n# /path/to/destination/architecture.yaml\n</code></pre> <p>The argument of <code>arch.export()</code> is string type and means file path to store the <code>arch</code> object. In this sample, <code>architecture.yaml</code> will be created in <code>/path/to/destination</code> directory if the destination path is writable or another file of the same name does exist.</p> <p><code>arch.export()</code> has the second argument, <code>force</code>, to allow you to overwrite the <code>arch</code> object into an existing file. The following sample shows how to overwrite.</p> <pre><code>arch.export('/path/to/destination/architecture.yaml', force=True)\n\n! readlink -f /path/to/destination//architecture.yaml\n# /path/to/destination/architecture.yaml\n</code></pre> <p><code>force=True</code> option erases the existing architecture object.</p>"},{"location":"configuration/load_and_save/#cli","title":"CLI","text":""},{"location":"configuration/load_and_save/#create-an-architecture-file-via-cli","title":"Create an architecture file via CLI","text":"<p>With the functions I introduced above, you can create a YAML-based file including an architecture object. CARET serves CLI to create it as well. <code>create_architecture_file</code> command plays role of it.</p> <p>The following sample code shows how to use <code>create_architecture_file</code> command.</p> <pre><code>source /path/to/ros2_caret_ws/install/setup.bash\n\nros2 caret create_architecture_file /path/to/ctf-based_recorded_data -o /path/to/destination/architecture.yaml\n\nreadlink -f /path/to/destination/architecture.yaml\n# /path/to/destination/architecture.yaml\n</code></pre>"},{"location":"configuration/practical_example/","title":"Practical example of configuration","text":"<p>The previous sections have explained what to do in configuration. This section explains you a practical example to let you understand the flow of configuration.</p> <p>This section demonstrates creation of an architecture file for <code>caret_demos</code> on Jupyter Notebook. Defining inter-node and intra-node data path is also demonstrated. The following three steps are explained.</p> <ol> <li>Load an Architecture object on Jupyter Notebook</li> <li>Define an inter-node data path</li> <li>Define an intra-node data path</li> </ol> <p>The architecture file that will be created in the example is provided here.</p>"},{"location":"configuration/practical_example/#load-an-architecture-object-on-jupyter-notebook","title":"Load an Architecture object on Jupyter Notebook","text":"<p>Load an architecture object from recorded data, as explained section of Load and save</p> <ol> <li> <p>Launch Jupyter Notebook (Jupyter Lab)</p> <pre><code>mkdir -p ~/ros2_ws/evaluate &amp;&amp; cd ~/ros2_ws/evaluate\n\nsource ~/ros2_caret_ws/install/setup.bash\njupyter-lab\n</code></pre> </li> <li> <p>Generate an architecture file from recorded data as below</p> <pre><code>from caret_analyze import Architecture\n\n# Read description of application's architecture from recorded data\n#\narch = Architecture('lttng', './e2e_sample')\n\n# Save description as an architecture file\narch.export('architecture.yaml')\n\n# Check if the architecture file is created\n! readlink -f ./architecture.yaml\n# /home/user/ros2_caret_ws/eval/architecture.yaml\n</code></pre> </li> </ol>"},{"location":"configuration/practical_example/#define-an-inter-node-data-path","title":"Define an inter-node data path","text":"<p>Define an inter-node data path on the loaded architecture object as section of Define inter-node data path explained</p> <ol> <li> <p>Load the yaml-based architecture file as below</p> <pre><code>from caret_analyze import Architecture, check_procedure\narch = Architecture('yaml', './architecture.yaml')\n</code></pre> </li> <li> <p>Choose source node and destination node in a path</p> <p><code>arch.search_paths</code> extract all candidates of the path</p> <pre><code>paths = arch.search_paths(\n'/sensor_dummy_node', # source node\n'/actuator_dummy_node') # destination node\n</code></pre> <p>If a target application is large and complicated, <code>arch.search_paths</code> method may consume time more than 1 minute.  For decreasing consumed time, you can ignore nodes and topics and specify depth of search. Refer to Define inter-node data path for more details.</p> </li> <li> <p>Check the path as you expected</p> <p>You will find multiple candidates of the path. You can check which candidate is expected as target. The following code is an example for users to check</p> <pre><code>path = paths[0]\npath.summary.pprint()\n\n---Output text as below---\n\npath:\n  - message_context: null # for definition of node latency\n    node: /sensor_dummy_node\n  - topic: /topic1\n  - message_context:\n      publisher_topic_name: /topic2\n      subscription_topic_name: /topic1\n      type: callback_chain\n    node: /filter_node\n  - topic: /topic2\n  - message_context: null\n    node: /message_driven_node\n  - topic: /topic3\n  - message_context: null\n    node: /timer_driven_node\n  - topic: /topic4\n  - message_context: null\n    node: /actuator_dummy_node\n</code></pre> </li> <li> <p>Give a name to selected path and update architecture file</p> <pre><code>arch.add_path('target', path)\narch.export('./architecture.yaml', force=True)\n</code></pre> <p>The updated architecture file describes the path named as <code>target_path</code>.</p> <pre><code>named_paths:\n- path_name: target_path\nnode_chain:\n- node_name: /sensor_dummy_node\npublish_topic_name: /topic1\nsubscribe_topic_name: UNDEFINED\n- node_name: /filter_node\npublish_topic_name: /topic2\nsubscribe_topic_name: /topic1\n- node_name: /message_driven_node\npublish_topic_name: /topic3\nsubscribe_topic_name: /topic2\n- node_name: /timer_driven_node\npublish_topic_name: /topic4\nsubscribe_topic_name: /topic3\n- node_name: /actuator_dummy_node\npublish_topic_name: UNDEFINED\nsubscribe_topic_name: /topic4\n</code></pre> </li> </ol>"},{"location":"configuration/practical_example/#define-intra-node-data-path","title":"Define intra-node data path","text":"<p>Define an intra-node data path on the loaded architecture object as section of Define intra-node data path explained</p> <ol> <li> <p>Check which node latency should be configured</p> <p><code>path.verify()</code> method, as shown in the following example, tells you which node latency should be defined.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('yaml', './architecture.yaml')\npath = arch.get_path('target_path')\npath.verify()\n\n---Output text as below---\nWARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/message_driven_node')\nmessage_context: null\nnode: /message_driven_node\npublish_topic_name: /topic3\nsubscribe_topic_name: /topic2\n\nWARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/timer_driven_node')\nmessage_context: null\nnode: /timer_driven_node\npublish_topic_name: /topic4\nsubscribe_topic_name: /topic3\n</code></pre> <p>In the example, <code>path.verify()</code> tells you two nodes have undefined relationships of input and output.</p> <ul> <li>input <code>/topic2</code> and output <code>/topic3</code> in node <code>/message_driven_node</code></li> <li>input <code>/topic3</code> and output <code>/topic4</code> in node <code>/timer_driven_node</code></li> </ul> <p>Their relationships must be explicit with corresponding message_context items in the architecture file.</p> </li> <li> <p>Define relationship between input and output</p> <p>You have to change message_contexts items as below for the sample.</p> <pre><code># in /message_driven_node\nmessage_contexts:\n- context_type: use_latest_message # changed from 'UNDEFINED' to 'use_latest_message'\nsubscription_topic_name: /topic2\npublisher_topic_name: /topic3\n</code></pre> <pre><code># in /timer_driven_node\nmessage_contexts:\u3000\n- context_type: use_latest_message # changed from 'UNDEFINED' to 'use_latest_message'\nsubscription_topic_name: /topic3\npublisher_topic_name: /topic4\n</code></pre> </li> <li> <p>Check if node latency is defined</p> <p><code>path.verify()</code> tells you that there is no undefined node latency in the path.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('yaml', './architecture.yaml')\npath = arch.get_path('target_path')\npath.verify()\n</code></pre> <p>If <code>path.verify()</code> returns <code>True</code>, CARET can calculate latency of the path. Otherwise, there is any lack of definition to calculate latency.</p> </li> </ol>"},{"location":"configuration/rename_function/","title":"How to rename sub-objects in an architecture object","text":"<p>An architecture object has several sub-objects such as callbacks, nodes, paths, executors and topics. CARET assigns names to these sub-objects to identify them. These names come from identifiers captured at initialization tracepoints. The target application may assign different identifiers to the sub-objects on each launch or update. It prevents users from reusing the existing architecture object as it is. To enhance the reusability of the architecture object, CARET serves APIs to change the names of these sub-objects.</p> <p>All of the following code snippets can be executed after the <code>Architecture('type', 'file_path')</code> method loads an architecture object. The architecture object whose sub-objects are renamed is saved to a file as explained in the previous page.</p>"},{"location":"configuration/rename_function/#rename-callback_name","title":"Rename <code>callback_name</code>","text":"<p>You can update callback names from <code>src</code> to <code>dst</code> with <code>rename_callback</code> function in <code>Architecture</code> class.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.rename_callback('src', 'dst')\n</code></pre> <p>All <code>callback_name</code> in architecture object where it is <code>src</code> are updated to <code>dst</code>.</p>"},{"location":"configuration/rename_function/#rename-node_name","title":"Rename <code>node_name</code>","text":"<p>You can update node names from <code>src</code> to <code>dst</code> with <code>rename_node</code> function in <code>Architecture</code> class.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.rename_node('src', 'dst')\n</code></pre> <p>All <code>node_name</code> in architecture object where it is <code>src</code> are updated to <code>dst</code>.</p>"},{"location":"configuration/rename_function/#rename-path_name","title":"Rename <code>path_name</code>","text":"<p>You can update path names from <code>src</code> to <code>dst</code> with <code>rename_path</code> function in <code>Architecture</code> class.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.rename_path('src', 'dst')\n</code></pre> <p>All <code>path_name</code> in architecture object where it is <code>src</code> are updated to <code>dst</code>.</p>"},{"location":"configuration/rename_function/#rename-executor_name","title":"Rename <code>executor_name</code>","text":"<p>You can update executor names from <code>src</code> to <code>dst</code> with <code>rename_executor</code> function in <code>Architecture</code> class.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.rename_executor('src', 'dst')\n</code></pre> <p>All <code>executor_name</code> in architecture object where it is <code>src</code> are updated to <code>dst</code>.</p>"},{"location":"configuration/rename_function/#rename-topic_name","title":"Rename <code>topic_name</code>","text":"<p>You can update topic names from <code>src</code> to <code>dst</code> with <code>rename_topic</code> function in <code>Architecture</code> class.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\narch.rename_topic('src', 'dst')\n</code></pre> <p>All <code>topic_name</code> in architecture object where it is <code>src</code> are updated to <code>dst</code>.</p>"},{"location":"configuration/visualize_application_structure/","title":"Visualize application structure","text":"<p>This section is not still available. dear_ros_node_viewer will be introduced.</p>"},{"location":"design/","title":"Design","text":""},{"location":"design/#introduction","title":"Introduction","text":"<p>Design chapter describes details of CARET like architecture overview, tracepoints definition, data visualization. The following figure shows the overview of tracing flow and the related packages.</p> <p></p> <p>CARET records events data, including metadata and timestamps, from tracepoints embedded in user applications, ROS 2 and DDS. The events data are dumped to a set of CTF-based files. The set of files is called \"trace data\" in the context of CARET.</p> <p>CARET load trace data and convert them to graphs and statistics for users to comprehend performance and bottleneck of the application.</p> <p>This chapter describes the design policy and key points as listed below. As the chapter is written for heavy users or developers, most of light users might feel bored.</p> <ul> <li> <p>Design overview on the architecture and the trace points</p> <ol> <li>Software architecture</li> <li>Event and latency definition</li> <li>Limits and constraints</li> </ol> </li> </ul> <ul> <li> <p>Design related to Recording</p> <ol> <li>Runtime processing</li> <li>Tracepoints</li> </ol> </li> </ul> <ul> <li> <p>Design related to [Configuration]</p> <ol> <li>Configuration</li> </ol> </li> </ul> <ul> <li>Design related to [Visualization]<ol> <li>Processing trace data</li> <li>Visualization</li> </ol> </li> </ul> <p>If you are interested in details of implementation, caret_analyze API document might be helpful.</p>"},{"location":"design/configuration/","title":"Configuration","text":"<p>CARET shows response time in a path which constructed of multiple nodes and topic communication. As explained in configuration chapter, CARET is not able to extract definition of data path definition automatically from trace data.</p> <p>This section shows the file format of architecture file.</p>"},{"location":"design/configuration/architecture_file/","title":"Architecture file","text":"<p>An architecture file is a YAML-based file which describes structure of a target application. It contains the following information.</p> <ul> <li>Definition of the data path to be measured</li> <li>Information about the structure of the software to be measured<ul> <li>Executor information</li> <li>Node information (e.g. node latency definition)</li> </ul> </li> </ul>"},{"location":"design/configuration/architecture_file/#file-format","title":"File format","text":"<p>A sample of the architecture file is as follows.</p> Key Type Required? Auto generate?  (Configuration method) Note / Description named_paths List Yes Yes Path definitions to evaluate. \u2003 path_name String Yes No (Edit via Python-API) \u2003 node_chain List Yes No (Edit via Python-API) \u2003 \u2003 node_name String Yes No (Edit via Python-API) \u2003 \u2003 publish_topic_name String Required if node is not end of the path. No (Edit via Python-API) \u2003 \u2003 subscribe_topic_name String Required if node is not start of the path. No (Edit via Python-API) \u2003 \u2003 publisher_construction_order int No No (Edit via Python-API) Zero is used as the default value if not present. \u2003 \u2003 subscription_construction_order int No No (Edit via Python-API) Zero is used as the default value if not present. executors List Yes Yes \u2003 executor_type String Yes Yes single_threaded_executor / multi_threaded_executor \u2003 executor_name String Yes Yes \u2003 callback_group_names List(String) Yes Yes nodes List Yes Yes \u2003 node_name String Yes Yes \u2003 callback_groups List Yes Yes \u2003 \u2003 callback_group_type String Yes Yes mutually_exclusive / reentrant \u2003 \u2003 callback_group_name String Yes Yes \u2003 callbacks List Yes Yes \u2003 \u2003 callback_type String Yes Yes timer_callback / subscription_callback \u2003 \u2003 symbol String Yes Yes symbol for callback function. \u2003 \u2003 period_ns int Required for timer_callback only. Yes \u2003 \u2003 topic_name String Required for subscription_callback only. Yes \u2003 \u2003 construction_order int No Yes Zero is used as the default value if not present. \u2003 variable_passings List No Yes \u2003 \u2003 callback_name_write String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 callback_name_read String No No (Edit architecture file) default value = UNDEFINED \u2003 publishes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_names List(String) No No (Edit architecture file) callbacks which publish the topic. \u2003 \u2003 construction_order int No Yes Zero is used as the default value if not present. \u2003 subscribes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_name String No Yes \u2003 \u2003 construction_order int No Yes Zero is used as the default value if not present. \u2003 message_contexts List No Yes Field to define node latency \u2003 \u2003 context_type String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 subscription_topic_name String No Yes \u2003 \u2003 publisher_topic_name String No Yes \u2003 \u2003 publisher_construction_order int No Yes Zero is used as the default value if not present. \u2003 \u2003 subscription_construction_order int No Yes Zero is used as the default value if not present."},{"location":"design/configuration/architecture_file/#sample","title":"Sample","text":"<p>A sample of the architecture file is as follows.</p> <pre><code>named_paths:\n- path_name: target_path\nnode_chain:\n- node_name: /ping_node\npublish_topic_name: /chatter\nsubscribe_topic_name: UNDEFINED\n- node_name: /pong_node\npublish_topic_name: UNDEFINED\nsubscribe_topic_name: /chatter\nsubscription_construction_order: 1\nexecutors:\n- executor_type: single_threaded_executor\nexecutor_name: executor_0\ncallback_group_names:\n- /ping_node/callback_group_0\n- /pong_node/callback_group_0\nnodes:\n- node_name: /ping_node\ncallback_groups:\n- callback_group_type: mutually_exclusive\ncallback_group_name: /ping_node/callback_group_0\ncallback_names:\n- /ping_node/callback_0\ncallbacks:\n- callback_name: subscription_callback_0\ntype: subscription_callback\ntopic_name: /topic3\nsymbol: Node::{lambda()}\n- callback_name: timer_callback_0\ntype: timer_callback\nperiod_ns: 100000000\nsymbol: Node::{lambda()}\n- callback_name: timer_callback_0\ntype: timer_callback\nperiod_ns: 100000000\nsymbol: Node::{lambda()}\nconstruction_order: 1\nvariable_passings:\n- callback_name_write: subscription_callback_0\ncallback_name_read: timer_callback_0\npublishes:\n- topic_name: /ping\ncallback_names:\n- timer_callback_0\nsubscribes:\n- topic_name: /pong\ncallback_name: timer_callback_0\nmessage_contexts:\n- context_type: use_latest_message\nsubscription_topic_name: /pong\npublisher_topic_name: /ping\n</code></pre>"},{"location":"design/configuration/architecture_file/#callback-identification","title":"Callback identification","text":"<p>It's convenient for users to give a name to a callback function for its identification. However, in the context of ROS 2, only an address is given to a callback.</p> <p>Addresses change with each launch of an application. This makes it difficult to handle callbacks by address when evaluating performance of them. For example, if you want to compare the execution time of a particular callback for each launch, you have to find address to select target callbacks.</p> <p>CARET helps users to give a name to a callback, but it is not directly associated with its address due to the reason as explained above.</p> <p>In order to tackle the issue, CARET associates a name with an address of callback with using combination of following data.</p> <ul> <li><code>node_name</code></li> <li><code>callback_type</code></li> <li><code>period_ns</code> / <code>topic_name</code></li> <li><code>symbol</code></li> <li><code>construction_order</code></li> </ul> <p>By using this information to match <code>callback_name</code> and callback address, each <code>callback_name</code> will always refer to identical callbacks without being aware of callback address.</p>"},{"location":"design/event_and_latency_definitions/","title":"Latency definition","text":"<p>CARET mainly measures the following</p> <ul> <li>Callback latency</li> <li>Communication latency</li> <li>Node latency</li> <li>Path latency</li> </ul> <p>The simplified sequence diagram shown below illustrates each definition.</p> <p></p> <p>Here, the horizontal axis represents time and the vertical axis represents layers. The red line represents message flow. A message is received in the subscription callback and the processed data is published to the next node. In this way, information is propagated from the sensor node to the actuator node.</p> <p>CARET samples events for latency calculation. The following three items are main types of the events.</p> <ul> <li>Callback start</li> <li>Callback end</li> <li>Publish</li> </ul> <p>Difference of timestamp between two events are corresponded to latency.</p> <p>For a more detailed definition, see</p> <ul> <li>Callback</li> <li>Communication</li> <li>Node</li> <li>Path</li> </ul> <p>CARET provides time series data of events through Python objects. Time series data can be retrieved with the Python objects which have to_dataframe API. All objects are capable of retrieving time-series data are listed below.</p> Target Configuration required? Path Yes Node Yes Communication No Callback No Publisher No Subscription No Timer No <p>Here, for Path and Node, definitions must be given manually. For details on setting the definitions, see Configuration.</p>"},{"location":"design/event_and_latency_definitions/#detailed-sequence","title":"Detailed Sequence","text":"<p>Below is a detailed sequence diagram of the SingleThreadedExecutor, from publish in the callback to the execution of the subscription callback.</p> <p></p> <p>Here, each element indicates the following</p> <ul> <li>UserCode is a callback</li> <li>ROS 2 is rclcpp, rcl, and rmw</li> <li>DDS is FastDDS or CycloneDDS</li> <li>LTTng is the output destination for tracepoints</li> </ul> <p>Within the spin of Subscription, the executable callbacks are executed sequentially.</p> <p>In this way, the executor schedules callbacks. If there are multiple executable callbacks, they are executed sequentially, so other callbacks may have to wait.</p> <p> <p>Info</p> <p>There have been many different proposals for schedulers, and the information provided above may not be up-to-date.   Please keep in mind that system performance will vary depending on the scheduler you choose.</p> <p>"},{"location":"design/event_and_latency_definitions/callback/","title":"Callback","text":"<p>Callback latency is defined as duration between beginning and end of callback execution. These events are represented as <code>callback_start</code> and <code>callback_end</code>, respectively.</p>  l_{\\rm{callback}} = t_{\\rm{callback\\ end}} - t_{\\rm{callback\\ start}}  <p>The sequence diagram shows how CARET rclcpp picks up two events; callback_start and callback_end.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description callback_start System time Callback start time callback_end System time Callback end time <p>See also</p> <ul> <li>Trace points | Callback Start</li> <li>Trace points | Callback End</li> <li>RuntimeDataProvider API</li> </ul>"},{"location":"design/event_and_latency_definitions/communication/","title":"Communication","text":"<p>Communication latency is an expression of how much time it takes for a topic message to travel from source callback to next callback.</p>  l_{comm} = t_{sub} - t_{pub}  <p> <p>Info<p>In this definition, communication latency is affected by the scheduling of callbacks, and includes not only the communication latency of the DDS, but also the delay due to scheduling. For example, if multiple callbacks are dispatched simultaneously, the communication latency may include the execution time of other callbacks. For more information on scheduling, see Event and latency_definitions | overview.</p> </p> <p> <p>ROS communication is performed by the subscription side for intra-process communication and inter-process communication. Since ROS communication is capable of many-to-many communication, there are cases where both intra-process and inter-process communication are performed in a single publish. In CARET, communication is divided into 1:1 pairs and latency is calculated.</p>"},{"location":"design/event_and_latency_definitions/communication/#intra-process-communication","title":"Intra process communication","text":"<p>A simplified sequence diagram focusing only on the relevant data flow is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. callback_start_timestamp System time Callback start time <p>See also</p> <ul> <li>Trace points | rclcpp_intra_publish</li> <li>Trace points | dispatch_intra_process_subscription_callback</li> <li>Trace points | callback start</li> <li>Trace points | message_construct</li> <li>RuntimeDataProvider API</li> </ul>"},{"location":"design/event_and_latency_definitions/communication/#inter-process-communication","title":"Inter process communication","text":"<p>A simplified sequence diagram focusing only on the relevant data flow is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. rcl_publish_timestamp System time Publish time in rcl. dds_write_timestamp System time Publish time in rmw. callback_start_timestamp System time Callback start time. <p>See also</p> <ul> <li>Trace points | message_construct</li> <li>Trace points | rclcpp_publish</li> <li>Trace points | rcl_publish</li> <li>Trace points | dds_write</li> <li>Trace points | bind_addr_to_addr</li> <li>Trace points | bind_addr_to_stamp</li> <li>Trace points | callback start</li> <li>Trace points | dispatch_subscription_callback</li> <li>RuntimeDataProvider API</li> </ul>"},{"location":"design/event_and_latency_definitions/node/","title":"Node","text":"<p>Node latency is elapsed time from message reception to message transmission in a node.</p>  l_{node} = t_{transfer} - t_{receive}  <p>As transmission is replaced by publish and reception is subscription in the context of ROS 2, the equation is translated into the next one.</p>  l_{node} = t_{pub} - t_{sub}"},{"location":"design/event_and_latency_definitions/node/#message-context","title":"Message context","text":"<p>A node receives a message, processes it, and then publishes it to a subsequent node. The dependency between the subscribed and published messages is used to define node latency. In the following sections explain the message dependency (message context), which is the concept of node latency.</p> <p>For example, consider the following callback.</p> <pre><code>auto subsription_callback = [](&amp;msg){\nmsg_ = f(msg);\npub.publish(msg_);\n}\n</code></pre> <p>In this case, the received message is processed and published immediately. The dependency of the message at this time is described in chronological order and is expressed as follows.</p> <p></p> <p>Here, the elapsed time from subscription to publish is defined as node latency. In this way, node latency can be calculated when message dependencies are defined.</p> <p>In the previous example, we presented a case where a node is subscribed and immediately published. Actually, the message context can be quite complex because data processing in a node is freely defined by application developers.</p> <p></p> <p>Examples of complex message context are described below.</p> <ul> <li>Buffered, for example, is a buffer delay process.</li> <li>Multiple inputted is for moving average processing, for example. There are multiple candidates for node latency.</li> <li>Unused is a message that has not been published and has not been used. This is evaluated as a kind of message drop.</li> <li>Crossed can occur in cases where messages are retrieved based on the timestamp of the message rather than the system time.</li> </ul> <p>In any of those cases, it is difficult to automatically determine the message context.</p> <p>the message context are given for some cases of them as shown in configuration. For more information, see Configuration for details.</p> <p>To enlarge coverage the others of complex cases, we are considering a mechanism to allow users to describe message dependencies in their user codes. TILDE is one of good candidates to achieve it.</p>"},{"location":"design/event_and_latency_definitions/path/","title":"Path","text":"<p>Path latency is sum of node latency and communication latency included in a certain path. Path represents data flow which is constructed of multiple nodes connected each other.</p>  l_{path} = \\sum_{\\in path} l_{node} + \\sum_{\\in path} l_{comm} \\\\ l_{node} = t_{pub} - t_{sub} \\\\ l_{comm} = t_{sub} - t_{pub} \\\\  <p>In CARET, the path is defined as <code>[node_name]-[topic_name]-... -[topic_name]-[node_name]</code>. For example, in the following case, the path definition is <code>[A]-[/a]-[C]-[/e]-[E]</code>.</p> <p></p> <p> <p>Info</p> <p>In the above definition, the star time of the latency is publish of the initial node and the end time of the latency is subscription of the last node. When trying to measure a actual system, it is desirable to be able to define various start and end times depending on the implementation. For example, the start time might be more appropriately a stamp value in the sensor message. It's current issue to support for such more precise latency.</p> <p>"},{"location":"design/event_and_latency_definitions/publisher/","title":"Publisher","text":"<p><code>Publisher</code>-based object provides a set of timestamps collected during message publish.</p> <p>A simplified sequence diagram focusing only on the relevant events is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description rclcpp_publish_timestamp System time min(rclcpp_intra_publish_timestamp, rclcpp_publish_timestamp) rclcpp_intra_publish_timestamp System time (Optional) Publish time of intra-process communication rclcpp_publish_timestamp System time (Optional) Publish time of inter-process communication in rclcpp rcl_publish_timestamp System time(Optional) Publish time of inter-process communication in rcl dds_write_timestamp System time(Optional) Publish time of inter-process communication in rmw message_timestamp Message data Time of header.stamp. Zero when header is not defined. source timestamp Depends on DDS (Optional) Timestamp to used for binding with subscription. <p>See also</p> <ul> <li>Trace points | rclcpp_intra_publish</li> <li>Trace points | message_construct</li> <li>Trace points | rclcpp_publish</li> <li>Trace points | rcl_publish</li> <li>Trace points | dds_write</li> <li>Trace points | bind_addr_to_addr</li> <li>Trace points | bind_addr_to_stamp</li> </ul>"},{"location":"design/event_and_latency_definitions/subscription/","title":"Subscription","text":"<p>Topic message is received by subscription via inter-process communication or intra-process one. Then, <code>Subscription</code> object has common data fields, but different value is filled in <code>source_timestamp</code> field.</p>"},{"location":"design/event_and_latency_definitions/subscription/#inter-process-communication","title":"Inter process communication","text":"<p>A simplified sequence diagram focusing only on the relevant events is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS Timestamp to used for binding with subscription. <p>See also</p> <ul> <li>Subscription API</li> <li>Trace points | dispatch_subscription_callback</li> <li>Trace points | callback_start</li> </ul>"},{"location":"design/event_and_latency_definitions/subscription/#intra-process-communication","title":"Intra process communication","text":"<p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS (Optional) NaN. <p>See also</p> <ul> <li>Subscription API</li> <li>Trace points | dispatch_intra_process_subscription_callback</li> <li>Trace points | callback_start</li> </ul>"},{"location":"design/event_and_latency_definitions/timer/","title":"Timer","text":"<p>Timer provides the time at which the Timer callback timeout and related information.</p> <p>A simplified sequence diagram focusing only on the relevant events is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description timer_event_timestamp System time Timer timeout. callback_start_timestamp System time Callback start time callback_end_timestamp System time Callback end time <p>Here, the timer firing time is calculated by the following,</p>  t_{timeout} = t_{init} + n \\times t_{period}  <p>See also</p> <ul> <li>Timer API</li> <li>Trace point | callback_start</li> <li>Trace point | callback_end</li> <li>Trace point | rcl_timer_init</li> </ul>"},{"location":"design/limits_and_constraints/","title":"Limits and constraints","text":""},{"location":"design/limits_and_constraints/#environment","title":"Environment","text":"<p>CARET only supports environments as follows.</p> <ul> <li>Support single host</li> <li>Support FastDDS or CycloneDDS</li> <li>Support only Linux, especially Ubuntu</li> <li>Support Galactic and Humble</li> <li>Require rebuilding of an application with CARET libraries</li> </ul>"},{"location":"design/limits_and_constraints/#ros-2-functions","title":"ROS 2 functions","text":"<p>CARET does not support the following functions.</p> <ul> <li>/rosout and /parameter_event topic</li> <li>Services</li> <li>Actions</li> </ul>"},{"location":"design/limits_and_constraints/#implementation","title":"Implementation","text":"<p>CARET does not support implementations as follows.</p> <ul> <li>Multiple nodes whose full-names are same</li> <li>Wrapper for ROS layers</li> <li>Reentrant callback group</li> <li>Other than processing that operates on a node</li> <li>Other than nodes built with rclcpp library</li> </ul>"},{"location":"design/processing_trace_data/","title":"Processing trace data","text":"<p>CARET processes trace data to visualize performance for users. This section describes how CARET processes trace data.</p> <p><code>Records</code> object loads a set of trace data.</p> <ul> <li>Records</li> </ul> <p>The following sections explains how loaded data is processed.</p> <ul> <li>Period</li> <li>Frequency</li> <li>Latency</li> <li>Response time</li> </ul> <p>See also</p> <ul> <li>Event and latency definition</li> <li>caret_analyze</li> <li>Software architecture | caret_analyze</li> </ul>"},{"location":"design/processing_trace_data/records/","title":"Records Object","text":"<p>CARET provides trace data to user. The common format is a table per metric as shown below.</p> callback_start_timestamp callback_end_timestamp 0 0.1 1 1.1 2 2.1 ... ... <p>This table is referred to calculate latency, period, and etc. (See Records Service). The most primitive format is a table per event which picked up by a corresponding tracepoint. Merging multiple event tables makes a new table for metrics. In addition to simple table merging, CARET defines classes which has originally defined merging method for latency calculation.</p> <p>This sections describes the main APIs provided by the record object.</p> <ul> <li>merge</li> <li>merge_sequential</li> <li>merge_sequential_for_addr_track</li> <li>to_dataframe</li> </ul>"},{"location":"design/processing_trace_data/records/#merge","title":"merge","text":"<p>This is an inner join and outer join of general tables. In particular, it is used to join initialization-related trace data that can be bound by address only.</p> <p>See also</p> <ul> <li>API:merge</li> </ul>"},{"location":"design/processing_trace_data/records/#merge_sequential","title":"merge_sequential","text":"<p>This is a chronological merge. It is especially used to merge sequential processing by threads.</p> <p>CARET mainly performs this merging and calculates latency.</p> <p>See also</p> <ul> <li>API:merge</li> <li>Callback Latency Definition</li> </ul>"},{"location":"design/processing_trace_data/records/#merge_sequential_for_addr_track","title":"merge_sequential_for_addr_track","text":"<p>This merge is used when binding is done based on addresses and copying occurs in the middle of the process.</p> <p>See also</p> <ul> <li>API:merge_sequential_for_addr_track</li> </ul> <p> <p>Warning</p> <p>This merge is slow and causes inconsistencies when nodes not using caret-rclcpp are published. As much as possible, trace points should be designed so that merge_sequential is sufficient.</p> <p>"},{"location":"design/processing_trace_data/records/#to_dataframe","title":"to_dataframe","text":"<p>Function to convert to a pandas.DataFrame. This is especially useful for unique visualization and evaluation by developers.</p>"},{"location":"design/processing_trace_data/records_service/","title":"Records service","text":"<p>The Records object holds time-series data such as message flow in a table as shown below.</p> Start timestamp ... End timestamp 0.0 ... 0.1 1.0 ... 1.1 2.0 ... NaN 3.0 ... 2.1 ... ... ... <p>The start timestamp column contains the system time at the starting point. The end timestamp column contains the system time at the end point. Both columns indicate the system time, and if there is no corresponding value for start, the value is NaN.</p> <p>For the intermediate columns, the time at the intermediate point between starting point and end one is represented.</p> <p>This table representation can be used for various measurement targets such as callbacks, nodes, and paths.</p> <p>The rows of the table are visualized as lines in a message flow diagram.</p> <p>The above table is stored by <code>Records</code> object.</p> <ul> <li>Records</li> </ul> <p>The followings are processing using Records object.</p> <ul> <li>Period</li> <li>Frequency</li> <li>Latency</li> <li>Response time</li> </ul> <p>See also</p> <ul> <li>Event and latency definition</li> </ul> <p>See also</p> <ul> <li>Records</li> </ul>"},{"location":"design/processing_trace_data/records_service/#period","title":"Period","text":"<p>Period is metrics defined as the elapsed time between two occurrence of cyclic events. Difference between two neighboring timestamp on the same column is defined as period.</p>      period_n = t_{n} -t_{n-1}"},{"location":"design/processing_trace_data/records_service/#example","title":"Example","text":"<p>Input</p> Start timestamp 0.0 1.0 2.0 3.0 ... <p>Output</p> Timestamp Period 0.0 1.0 1.0 1.0 2.0 1.0 ... ... <p>See also</p> <ul> <li>API Reference | Period</li> </ul>"},{"location":"design/processing_trace_data/records_service/#frequency","title":"Frequency","text":"<p>Frequency is defined as the number of events that occur in one second.</p>"},{"location":"design/processing_trace_data/records_service/#example_1","title":"Example","text":"<p>Input</p> Start timestamp 0.0 0.1 0.5 1.2 1.3 2.3 ... <p>Output</p> Timestamp Period 0.0 3.0 1.0 2.0 ... ..."},{"location":"design/processing_trace_data/records_service/#latency","title":"Latency","text":"<p>Latency is length of time from preceding event to afterward one. It is defined as difference from preceding timestamp to afterward on the same row.</p>  latency_n = t^{end}_{n} - t^{start}_{n}"},{"location":"design/processing_trace_data/records_service/#example_2","title":"Example","text":"<p>Input</p> Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.1 ... ... <p>Output</p> Start timestamp Latency 0.0 0.1 1.0 0.1 3.0 0.1 ... ..."},{"location":"design/processing_trace_data/records_service/#response-time","title":"Response Time","text":"<p>Response time is amount of time it takes for a system to respond to an input.</p> <p>As shown above, latency can be calculated if a table is constructed. Latency is defined as delay from input to any output. This calculation is very simple, but it is not used for evaluating response. If multiple output depends on a single input, latency is not regarded as response time. Moreover, for example, if a sensor is driven at 10 Hz, a latency of up to 100 ms should be considered.</p> <p>CARET serves best-case response time and worst-case response time. The former is roughly equal to latency from an input to a corresponding initial output. CARET provides the latter because it also takes into account the latency until times wake up. For example, this latency is equivalent to a sensor operating at 10 Hz taking a 100 ms delay at maximum.</p>"},{"location":"design/processing_trace_data/records_service/#example_3","title":"Example","text":"<p>Input</p> Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.2 4.0 4.3 ... ... <p>Intermediate Create intermediate data for when the interval in Start timestamp [0.0, 4.0] maps to End timestamp.</p> Start timestamp End timestamp [0.0, 1.0) 1.1 [1.0, 3.0) 3.2 [3.0, 4.0) 4.3 <p>Output</p> Start timestamp Best-case response time Worst-case response time 1.0 0.1 (1.1 - 1.0) 1.1 (1.1 - 0.0) 3.0 0.2 (3.2 - 3.0) 2.3 (3.2 - 1.0) ... ... ... <p>Note that best case response time is equal to Latency, except for the cumbersome cases listed later.</p> <p>Worst-case response time also counts as response time in the case of a drop.</p>"},{"location":"design/processing_trace_data/records_service/#visualize-response-time","title":"Visualize response time","text":"<p>Of the pseudo two message flow diagram as shown above, the upper figure shows latency and the lower explains response time. The upper figure includes cumbersome cases as follows;</p> <ul> <li>Cases where multiple latencies are defined for a single output from multiple inputs</li> <li>Message dropping</li> <li>Crossing</li> <li>Branching</li> </ul> <p>Some of these can be pessimistically large when it comes to latency.</p> <p>The diagram above describes the table as follows</p> Start timestamp End timestamp 0.0 2.0 0.5 2.5 2.0 3.5 3.0 3.5 4.0 5.0 4.5 7.0 5.5 6.0 5.5 6.5 <p>After extracting only the best case flows as shown in the lower figure, the best case is calculated as the latency of the flow and the worst-case as the latency is regarded as delay from the previous input to the output.</p> <p>According to those definitions, the response time is calculated as below.</p> Start timestamp Min response time Max response time 0.0 2.0 2.5 0.5 0.5 3.0 3.0 1.0 2.0 4.0 0.5 2.0 <p>See also</p> <ul> <li>FAQ | How response time is calculated?</li> </ul>"},{"location":"design/runtime_processing/","title":"Runtime processing","text":"<p>CARET serves the following functions at runtime of a target application.</p> <ul> <li>Adding trace points via hooks</li> <li>Filtering unnecessary trace points</li> </ul> <p>Though LTTng provides a variety of functions, CARET specializes ROS-aware functionality.</p> <p>See also the related page; tracepoint.</p>"},{"location":"design/runtime_processing/hook/","title":"Hook","text":"<p>Function hooking is one of the key techniques performed by CARET. This section describes the function hooking introduced to CARET.</p> <p>See also</p> <ul> <li>caret_trace</li> </ul>"},{"location":"design/runtime_processing/hook/#advantage-of-hook","title":"Advantage of Hook","text":"<p>ROS 2 is being developed separately from DDS thanks to RMW. On the other hand, each implementation may be developed for different purposes, which makes it difficult to achieve consistent evaluation of all layers, including DDS. CARET handles these layers across by hooks to add and manage trace points consistently.</p> <p></p> <p>See also</p> <ul> <li>Tracepoints definition</li> </ul> <p> <p>Info</p> <p>If possible, it is better to add tracepoints as built-in rather than hooks for users. However, CARET's priority is to evaluate software running on the current version of ROS rather than to gradually add trace points. For this reason, we have adopted function hooking that allows users to add tracepoints in a flexible manner.</p> <p> <p> <p>Info</p> <p>The advantage of being able to handle all layers across the board is not well utilized in the current CARET. In the future, we plan to use thread local memory to reduce trace points.</p> <p>"},{"location":"design/runtime_processing/hook/#ld_preload","title":"LD_PRELOAD","text":""},{"location":"design/runtime_processing/hook/#advantage-of-ld_preload","title":"Advantage of LD_PRELOAD","text":"<p>LD_PRELOAD can be hooked even if the function is not exposed externally as an API.</p> <p>The trace points themselves, which are built into the ROS layer, can also be hooked. This enables trace filtering.</p> <p>Though you might come up with using eBPF to hook, eBPF requires a context switch from user space to kernel space. Hooking with LD_PRELOAD can be completed in user space, reducing the overhead.</p> <p>See also</p> <ul> <li>Tracepoint filtering</li> </ul>"},{"location":"design/runtime_processing/hook/#limits-of-ld_preload","title":"Limits of LD_PRELOAD","text":"<p>There are some cases that cannot or are difficult to hook with LD_PRELOAD.</p> <ul> <li>Functions with many symbols by cpp template</li> <li>Hooks for functions that are expanded as inline code</li> <li>Hooks for functions implemented in headers</li> </ul> <p>Specifically, intra-process publish cannot be hooked by LD_PRELOAD. In CARET, trace points for intra-process communication are added in the forked rclcpp.</p>"},{"location":"design/runtime_processing/runtime_recording/","title":"Runtime recording","text":"<p>As explained in Tracepoint section, CARET records meta-information at initialization and reduces tracepoint data as much as possible at runtime. This allows for a low overhead at runtime, but recording including meta-information requires a LTTng session before running the application.</p> <p>CARET requires a set of recorded data to have meta-information and timestamps on events. To allow users to start session anytime when they want, CARET stores meta-information into disk when recording session starts. To stop and restart recording session, CARET holds meta-information on memory until a target application is terminated.</p> <p>This section explains the details of runtime recording feature.</p> <p>See also:</p> <ul> <li>Software architecture | caret_trace</li> </ul>"},{"location":"design/runtime_processing/runtime_recording/#basic-idea","title":"Basic idea","text":"<p>Runtime recording is a feature that holds initialization information on memory and stores it to trace data after recording session starts. It let user start recording session anytime.</p> <p>For this feature, each tracepoint has three states as below.</p> <ul> <li>WAIT state<ul> <li>Obtain information on running applications and store trace data in memory.</li> </ul> </li> <li>PREPARE state<ul> <li>Record stored trace data as LTTng tracepoints (delayed recording).</li> </ul> </li> <li>RECORD state<ul> <li>Record runtime trace data as LTTng trace points (synchronous recording).</li> </ul> </li> </ul> <p>A dedicated-node, named as trace node, is executed per ROS 2 process to manage the state. A trace node is executed on a dedicated thread along with threads for ordinary nodes. It is created when application is launched.</p> <p> <p>Notice</p> <p>A trace node runs on a thread created via function hooking. This thread is created even if a ROS 2 process is not implemented with <code>rclcpp</code>. A trace node thread is created if a ROS 2 process is implemented with <code>rclpy</code>, and it control the states as well. Though the trace node runs on a Python-based node, recording events for the node is not performed correctly. Only initialization tracepoints are recorded. Python serves Global Interpreter Lock (GIL) mechanism, but a trace node runs on a asynchronous thead which is not blocked by GIL.</p> <p> <p>Typical use cases are shown as follows.</p> <pre><code># Run a node at Terminal 0 first.\nros2 run pkg node\n</code></pre> <pre><code># Execute \"record\" command with Termial 1 after node startup.\nros2 caret record\n</code></pre> <p>State transition is shown below.</p> <p></p> <p>Refer to the sequence diagram is written in Sequence for further details.</p> <p>A trace node has a topic-based interface as well as an ordinary ROS 2 node. Topic message is used to get state from a trace node or change state of it.</p> <p>Besides, to maintain compatibility of conventional usage, CARET is able to record meta-information and runtime events when session has started in advance.</p> <p></p> <p>Note that meta-information is recorded in each LTTng session.</p> <p>The following state diagram shows state machine of the three states</p> <p></p> <p>Refer to Status for further details of the state machine.</p>"},{"location":"design/runtime_processing/runtime_recording/#topic","title":"Topic","text":"<p>Runtime recording uses the following topic messages.</p> topic name message type role <code>/caret/start_record</code> Start.msg Start recording. Transition to PREPARE state. <code>/caret/end_record</code> End.msg End recording. Transition to WAIT state. <code>/caret/status</code> Status.msg Sync current recording state."},{"location":"design/runtime_processing/runtime_recording/#startmsg","title":"Start.msg","text":"<pre><code>uint32 recording_frequency 100\nstring ignore_nodes  # reserved\nstring ignore_topics # reserved\nstring select_nodes  # reserved\nstring select_topics # reserved\n</code></pre> <p>CARET records sets of meta-information to a LTTng ring-buffer one by one rather than tries to store those meta-information at once. CARET serves a parameter, <code>recording_frequency</code>, to control velocity to record meta-information. <code>recording_frequency</code> is frequency at which each process records meta-information. It decides how many sets of meta-information is stored to the ring-buffer per second. If the frequency is higher, it costs less time to complete meta-information recording, but possibility of tracer discarded is higher.</p> <p><code>ignore_nodes</code> <code>ignore_topics</code> <code>select_nodes</code>, and <code>select_topics</code> are unused fields for the future implementation. They are reserved fields for setting tracepoint filtering at the start of the measurement from CLI.</p> <p> <p>Info</p> <p>Another method to avoid tracer discarded is writing meta-information with blocking mode. LTTng serves a function to apply blocking mode to chosen events, and chosen events are written to disks exactly. Blocking mode will reduce occurrence of data loss. In this moment, <code>recording_frequency</code> is introduced to mitigate data loss because range of influence on implementation is smaller than blocking mode.</p> <p>"},{"location":"design/runtime_processing/runtime_recording/#statusmsg","title":"Status.msg","text":"<pre><code>int8 UNINITIALIZED=0\nint8 WAIT=1\nint8 PREPARE=2\nint8 RECORD=3\n\nstring caret_node_name\nint8 status\nstring[] node_names # reserved\nint64 pid # reserved\n</code></pre> <p>A trace node name is given to <code>caret_node_name</code> field.</p> <p><code>status</code> is the WAIT, PREPARE, or RECORD status.</p> <p><code>node_names</code> field is unused in the present, it will be utilized by a future function. It is a reserved field to represent a list of node names managed by the trace node.</p> <p><code>pid</code> field is also unused because it will be used for an unimplemented feature. It is a reserved field to represent the process ID.</p>"},{"location":"design/runtime_processing/runtime_recording/#endmsg","title":"End.msg","text":"<pre><code>(Empty)\n</code></pre> <p>The End topic is for notification, so its contents are empty.</p>"},{"location":"design/runtime_processing/runtime_recording/#state-definition","title":"State definition","text":"<p>A detailed state transition is shown below.</p> <p></p>"},{"location":"design/runtime_processing/runtime_recording/#wait","title":"WAIT","text":"item description Transition conditions for entering - Start application with no active LTTng session.  - Receive messages from /caret/end_record topic. Transition conditions for exiting - Receive messages from <code>/caret/start_record</code> topic. Initialization trace point - Store in memory.  - Record as LTTng tracepoint (synchronous recording). Runtime trace data - Discard."},{"location":"design/runtime_processing/runtime_recording/#prepare","title":"PREPARE","text":"item description Transition conditions for entering - Receive messages from <code>/caret/start_record</code> topic. Transition conditions for exiting - Receive messages from <code>/caret/end_record</code> topic.  - Finish recording stored initialization trace data. Initialization trace data - Record as LTTng tracepoint (synchronous recording).  - Record stored data as LTTng tracepoint at fixed frequency from trace nodes (delayed recording). Runtime trace data - Discard to prevent discarding initialization trace data. <p>Velocity of storing initialization trace data to a LTTng's ring buffer is adjusted with <code>recording_frequency</code> in <code>Start.msg</code>.</p> <p> <p>Info</p> <p>Initialization trace data are recorded synchronously in all states. In the PREPARE state, the same data are also recorded from trace nodes with delay. In this way, Initialization trace data are recorded as much as possible, even if the LTTng session and the application are started in the opposite order. Especially in the PREPARE state, there are two types of recording: synchronous recording and delayed recording from trace nodes. Therefore, the same data may be stored in duplicate. Duplicate data are handled on the caret_analyze side.</p> <p>"},{"location":"design/runtime_processing/runtime_recording/#record","title":"RECORD","text":"item description Transition conditions for entering - Finish recording stored initialization trace data. Transition conditions for exiting - Start application with active LTTng session.  - Receive messages from <code>/caret/start_record</code> topic.  - Receive messages from <code>/caret/end_record</code> topic. Initialization trace data - Record as LTTng tracepoint (synchronous recording). Runtime trace data - Record as LTTng tracepoint (synchronous recording)."},{"location":"design/runtime_processing/runtime_recording/#sequence","title":"Sequence","text":"<p>Details of the sequence diagram are shown below.</p> <pre><code># Run a node at Terminal 0 first.\nros2 run pkg node\n</code></pre> <pre><code># Execute \"record\" command with Termial 1 after node startup.\nros2 caret record\n</code></pre> <p></p>"},{"location":"design/runtime_processing/runtime_recording/#tracepoint","title":"Tracepoint","text":"<p>Runtime recording feature has delayed recording which supports recording activation anytime after a target application launches. As a timestamp is given when event is recorded, that for initialization trace point is different from actual time when the trace point is called. It is inconvenient for analysis script provided by <code>caret_analyze</code> because it utilizes invocation time of the initialization trace point. For example, expected time when timer callback is invoked is calculated from initialization time and a given period. If only recording time is given, the expected time cannot be calculated correctly.</p> <p>To tackle this inconvenience, all initialization trace points have timestamps given respectively when they are called during launch of a target application.</p> <pre><code>[ros2:rcl_timer_init] (-&gt; [ros2_caret:rcl_timer_init])\n\n(context)\ntime (time that a lttng tracepoint is called.)\n...\n\n(tracepoint data)\nvoid * timer_handle\nint64_t period\nint64_t init_timestamp (timestamp given when trace point is called during )\n</code></pre> <p><code>init_timestamp</code> is an added argument which has original time when initialization trace point is invoked. As the prefix of <code>ros2:</code> is for <code>ros2_tracing</code>, <code>ros2_caret</code> is prefix for representing trace points for CARET.</p>"},{"location":"design/runtime_processing/tracepoint_filtering/","title":"Tracepoint filtering","text":"<p>As measuring a target application such as Autoware composed of many nodes, the amount of data from tracing can be very large.</p> <p>Trace data discarding occurs during a large amount of recording because LTTng is discard mode to minimize effect to the system.</p> <p>CARET provides the ability to disable trace points associated with specific topics or nodes. This makes it possible to exclude from recording only trace data related to rviz nodes or tf topics, allowing CARET measurements even on large systems.</p> <p>This filtering function looks at the instance addresses (e.g. callback or publisher) to see if they are included in the filter. This check is done in O1 order because it uses std::unordered_map.</p> <pre><code>void ros_trace_callback_start(const void * callback, bool is_intra_process) {\n// Record trace data only if current callback is allowed to record\nif (controller.is_allowed_callback(callback)) {\ntracepoint(callback, is_intra_process); // LTTng tracepoint\n}\n}\n</code></pre> <p>See also</p> <ul> <li>caret_trace</li> <li>Tracepoint</li> <li>Recording | trace filtering</li> </ul>"},{"location":"design/runtime_processing/tracepoint_filtering/#tracepoint-filtering-in-dds-layer","title":"Tracepoint filtering in DDS layer","text":"<p>To filter tracepoint, we need an object such as <code>callback</code> and <code>publisher</code> which contains information about node and topic. In DDS layer, such object is not available, which means we cannot filter <code>dds_write</code> and <code>dds_bind_addr_to_stamp</code> in the same way with the tracepoints in ROS 2 layer.</p> <p>To filter these tracepoints, we utilize the fact that <code>rcl_publish</code>, <code>dds_write</code> and <code>dds_bind_addr_to_stamp</code> are always recorded sequentially in the same thread. When <code>rcl_publish</code> is filtered out, subsequent <code>dds_write</code> and <code>dds_bind_addr_to_stamp</code> in the same thread can also be filtered out. When <code>rcl_publish</code> is not filtered out, subsequent <code>dds_write</code> and <code>dds_bind_addr_to_stamp</code> in the same thread cannot be filtered out either.</p> <p>We utilize thread-local storage to transmit if <code>rcl_publish</code> is recorded or not.</p> <pre><code>thread_local bool trace_filter_is_rcl_publish_recorded;\n\nvoid ros_trace_rcl_publish(const void * publisher_handle, const void * message)\n{\n...\n\nif (controller.is_allowed_publisher_handle(publisher_handle) &amp;&amp;\ncontext.is_recording_allowed())\n{\n((functionT) orig_func)(publisher_handle, message);\ntrace_filter_is_rcl_publish_recorded = true;\n} else {\ntrace_filter_is_rcl_publish_recorded = false;\n}\n}\n\nvoid ros_trace_rmw_publish(const void * message)\n{\nif (trace_filter_is_rcl_publish_recorded) {\ntracepoint(TRACEPOINT_PROVIDER, dds_write, message);\n}\n}\n\nint dds_write_impl(void * wr, void * data, long tstamp, int action)\n{\n...\n\nif (context.is_recording_allowed() &amp;&amp; trace_filter_is_rcl_publish_recorded) {\ntracepoint(TRACEPOINT_PROVIDER, dds_bind_addr_to_stamp, data, tstamp);\n}\n\n...\n}\n</code></pre>"},{"location":"design/software_architecture/","title":"Software architecture","text":"<p>This section explains an overview of software architecture.</p> <p></p> <p>CARET serves three phases; recording, configuration and visualization.</p>"},{"location":"design/software_architecture/#recording","title":"Recording","text":"<p>In the recording phase, CARET records events data obtained from tracepoints during application's runtime.</p> <p>CARET adopts LTTng as a tracing mechanism. LTTng session daemon collects events from tracepoints. <code>rclcpp</code> provided by ROS 2 has original tracepoints and CARET uses some of them also. CARET collects its dedicated tracepoints added by function hooking. CARET uses function hooking actively because it does not require changes of existing packages and allow us to add trace points in a flexible way. Only if it is not possible to add tracepoints by function hooking due to some constraints from implementation, tracepoints are added via another approach.</p> <p>All of recorded events are stored to a set of trace data CTF-based. It is visualized for users to observe application's performance and behavior.</p> <p><code>caret_trace</code> is the main package for realizing recording. <code>caret_trace</code> collects events invoked in <code>rclcpp</code>, <code>rcl</code> and DDS. It is inconvenient to see actual time when data is consumed because data is consumed in a user code actually. TILDE serves tracepoints to collect events which happens in a user code. CARET is able to refer to them for diving into events in a user code.</p> <p>See also</p> <ul> <li>Tracepoints</li> <li>Runtime Processing</li> <li>The LTTng Documentation</li> </ul>"},{"location":"design/software_architecture/#configuration","title":"Configuration","text":"<p>In the configuration, CARET expects users to complement structure definitions of a target application before visualizing data. Politely speaking, CARET expects users to define intra-node data paths and inter-node data paths to calculate response time. It's difficult to get their definition mechanically, so that users have to give.</p> <p>Structure data of a targe application is stored in a object which is instantiated from Architecture class defined by <code>caret_analyze</code>. CARET serves Python API to deal with the object to fulfill configuration step by running script. CARET is able to store the object to a YAML-based file to be reused.</p> <p> <p>Info</p> <p>Current implementation of CARET does not support several functions to define some of them. These are defined by editing the YAML-based file directly.</p> <p> <p>A package related to configuration is caret_analyze.</p> <p>See also Configuration.</p>"},{"location":"design/software_architecture/#visualization","title":"Visualization","text":"<p>CARET visualizes trace data and helps users to observe performance and behavior of a target application.</p> <p><code>caret_analyze</code> provides a Python class whose object holds a set of time series data. Users are able to get their desired data for evaluation from the object.</p> <p>CARET serves visualization methods for users to observe performance with graphical view.</p> <p>caret_analyze is a package on visualization.</p> <p>See also</p> <ul> <li>Processing trace data</li> <li>Event and latency definitions</li> <li>Bokeh</li> </ul>"},{"location":"design/software_architecture/#ros-2-packages","title":"ROS 2 Packages","text":"<p>The followings are CARET-related packages.</p> Package Role Repository caret_trace Add tracepoints via function hooking and functions to manage states of tracepoints. https://github.com/tier4/caret_trace/ CARET_rclcpp Add tracepoints by fork https://github.com/tier4/rclcpp ros2caret Provide CARET CLI https://github.com/tier4/ros2caret/ caret_analyze Analyze trace data https://github.com/tier4/caret_analyze/ caret_analyze_cpp_impl Accelerate caret_analyze https://github.com/tier4/caret_analyze_cpp_impl/ TILDE Add tracepoints within the system to be measure https://github.com/tier4/TILDE"},{"location":"design/software_architecture/caret_analyze/","title":"caret_analyze","text":"<p><code>caret_analyze</code> is a set of packages that helps users to load trace data and architecture objects and provides Python APIs for configuration and evaluation.</p> <p>See CARET analyze API document for the definition of each class.</p> <p>The following figure shows data flow in <code>caret_analyze</code>.</p> <p></p> <p>A set of trace data is divided into two sections after being loaded onto memory; architecture object and runtime data.</p> <p>Architecture object includes descriptions of the target application's structure. This object can be reused unless the structure of the target application or names of the components is changed.</p> <p>Runtime data object has data sampled during the execution of the target application. The sampled data includes timestamps, whose values are different per execution, obtained from tracepoints. Runtime data is combined with architecture and provided to developers via Python-API which is easy to evaluate.</p> <p>Architecture object and runtime data are instantiated from respective Python classes. Structure of their classes is designed based on that of ROS applications which are constructed of executors, nodes, callback functions, and topic messages. ROS-based structure makes CARET's API friendly for ROS users.</p> <p><code>caret_analyze</code> is composed of several python packages. Each python packages are as follows.</p> python package role <code>architecture</code> Load and configure an architecture object <code>runtime</code> Provide execution data <code>value_objects</code> Collection of value objects <code>plot</code> Visualization helpers <code>records</code> Implementation of records <code>common</code> Common or helper functions <code>infra</code> Import external files <p>Each of the packages has interrelation with other as shown in the following diagram.</p> <p></p> <p>Architecture object provides APIs to search inter-node paths and define intra-node data paths as mentioned in configuration chapter. The architecture object is reusable after it is saved as a YAML-based file called \"architecture file\".</p> <p>Runtime data provides APIs to retrieve <code>pandas.DataFrame</code>-based objects including callback latency or communication. Users can analyze temporal aspects of their applications, with visualization, as they expect. APIs for visualization are also served by <code>caret_analyze</code> which plays the main role to visualize trace data.</p> <p>In the following sections, each package will be explained in more detail.</p>"},{"location":"design/software_architecture/caret_analyze/#architecture","title":"<code>architecture</code>","text":"<p>The purpose of <code>architecture</code> is to define static information for visualization.</p> <p><code>architecture</code> package serves classes which embody architecture object. Architecture object has one or more sub components. There are several types of components; executor, node, callback and topic. CARET serves a class to each type of component and manages them in <code>architecture</code> package.</p> <p>A target application, which is represented with <code>architecture</code> class, has several sub components. An <code>architecture</code>-based object has several types of sub components as well.</p> <p> <p>Info</p> <p>\"Model\" might be more appropriate than the name \"Architecture\".   Architecture describes all the parameters related to scheduling, such as scheduling and core migration.   Therefore, we're thinking that the architecture can be used for design based on scheduling theory.</p> <p> <p></p> <p>All sub objects retrieved from the Architecture object are constructed from <code>ValueObject</code>, which is suitable for interfacing data with other packages.</p>"},{"location":"design/software_architecture/caret_analyze/#runtime","title":"<code>runtime</code>","text":"<p><code>runtime</code> a package to hold trace data, whose object has similar data structure to that of Architecture object. Objects instantiated from <code>runtime</code> package have function to return time-series data which are used for calculating frequency or latency.</p> <p></p> <p>The following is a list of each class. Some of them are able to return measured data.</p> Class API has measured data definition? Application API list No Executor API list No Node API list No Path API list Yes (Definitions) NodePath API list Yes (Definitions) Communication API list Yes (Definitions) Timer API list Yes (Definitions) Subscription API list Yes (Definitions) Callback API list Yes (Definitions)"},{"location":"design/software_architecture/caret_analyze/#value_objects","title":"<code>value_objects</code>","text":"<p><code>value_objects</code> define classes with equivalence. The Value class has the information for binding, and the StructValue class has the structure of multiple classes after binding.</p>"},{"location":"design/software_architecture/caret_analyze/#plot","title":"<code>plot</code>","text":"<p><code>plot</code> package has classes associated with visualization. The visualization methods provided by <code>caret_analyze</code> depends on <code>bokeh</code> and <code>graphviz</code>.</p>"},{"location":"design/software_architecture/caret_analyze/#records","title":"<code>records</code>","text":"<p>latency is calculated by joining process of tables uniquely defined. <code>records</code> package serves functions to make the tables with their own join processing.</p> <p>See also</p> <ul> <li>Records</li> </ul>"},{"location":"design/software_architecture/caret_analyze/#common","title":"<code>common</code>","text":"<p>Common package implements individual processes are described that can be handled as common in each package.</p>"},{"location":"design/software_architecture/caret_analyze/#infra","title":"<code>infra</code>","text":"<p><code>infra</code> package serves readers for an architecture object and trace data.</p> <p>It contains YAML and LTTng modules which implement <code>ArchitectureReader</code>/<code>RuntimeDataProvider</code> respectively.</p>"},{"location":"design/software_architecture/caret_trace/","title":"caret_trace","text":"<p><code>caret_trace</code> is a package who deliver the following feature during recording.</p> <ol> <li>Defining the tracepoints dedicated to CARET via function hooking</li> <li>Adding state management of tracepoints via function hooking for trace filtering and runtime recording</li> <li>Adding function of recording with <code>sim_time</code></li> </ol> <ul> <li>Tracepoints</li> <li>Hook</li> <li>Runtime recording</li> </ul>"},{"location":"design/software_architecture/caret_trace/#class-structure","title":"Class Structure","text":""},{"location":"design/software_architecture/caret_trace/#implementation-of-tracepoints-with-function-hooking","title":"Implementation of tracepoints with function hooking","text":"<p>CARET adopts function hooking mainly for adding new trace points. On the other hand, existing tracepoints, which are built in ROS 2, are also re-defined by function hooking because CARET adds the function to manage tracepoint state.</p> <p>Here is the pseudo code for hook functions.</p> <pre><code>void ros_trace_callback_start(TRACEPOINT_ARGS) {\n// Record trace data only if current callback is allowed to record\nif (controller.is_allowed(TRACEPOINT_ARGS)) {\ntracepoint(TRACEPOINT_ARGS); // LTTng tracepoint\n}\n}\n\nvoid ros_trace_XXX_init(TRACEPOINT_ARGS)\n{\n// Wrapper function for tracepoint.\n// This function is executed with delay.\n// This function is executed either from the record at the end of this function\n// or from TraceNode's timer callback.\n// Duplicate data are resolved with caret_analyze.\nstatic auto record = [](TRACEPOINT_ARGS, now) {\n// Record trace data only if current callback is allowed to record\nif (controller.is_allowed(TRACEPOINT_ARGS)) {\ntracepoint(TRACEPOINT_ARGS, now); // LTTng tracepoint\n}\n};\n\nauto now = clock.now(); // Measure immediately after function call\n\nif (!data_container.is_assigned_XXX()) {\ndata_container.assign_XXX(record);\n}\n\n// Store TRACEPOINT_ARGS in memory.\ndata_container.store_XXX(TRACEPOINT_ARGS, now);\n\nrecord(TRACEPOINT_ARGS, now);\n}\n</code></pre> <p><code>ros_trace_callback_start</code> is an example of hook functions to trace callback start. It is a kind of trace points for collecting events related to application s behavior, and so called runtime trace point.</p> <p><code>ros_trace_XXX_init</code> is an example of hook function to get identification of application's component. It is expected to be called when application is launched and initialized. The trace point is categorized into initialization trace point.</p> <p>A set of identifications such as a callback address or node name is given as <code>TRACEPOINT_ARGS</code>. Several kinds of initialization trace point are served, and each of them is attached to different kind of component; executor, node, callback, publisher, subscriber, and etc. For example, one is called to collect node's identification while another is called to collect publisher's identification.</p> <p>Identifications collected from different trace points share same addresses or names as elements. By connecting such identifications by the same addresses or names, CARET is able to help you to find application's structure.</p> <p>See Initialization trace points for details.</p>"},{"location":"design/software_architecture/caret_trace/#clock-recorder","title":"clock recorder","text":"<p>CARET can select simulation time, represented as <code>sim_time</code>, for visualization. <code>sim_time</code> can be recorded by running the <code>clock_recorder</code> node, which adds trace points for <code>sim_time</code> recording.</p> <pre><code>ros2 caret trace --record-clock\n</code></pre> <p><code>ClockRecorder</code> node wakes up per second and records a pair of <code>sim_time</code> and system time. The pair is used to convert system time to simulation time.</p>"},{"location":"design/software_architecture/tilde/","title":"TILDE, a framework tools to detect deadline overrun","text":"<p>CARET can cooperate with TILDE, a framework tool to detect deadline overrun. TILDE lets CARET trace events in user applications which cannot be traced from ROS/DDS layer.</p> <p> <p>Notice<p>TILDE is now under development.</p> </p> <p> <p>Since users can implement arbitrary processing on ROS nodes, some defining intra-node path is difficult in some cases.</p> <p>Examples of such difficult cases are listed as below.</p> <ul> <li>Message buffering case between subscribe and publish</li> <li>Using message filter case</li> </ul> <p>the latencies can be observed in only application layer, but CARET cannot observe the events. In such cases, data consumption in user code should be taken into account to define intra-node path. However, CARET does not observe events on user code.</p> <p>To tackle this constraint, CARET is capable of utilizing events from tracepoints added by TILDE while TILDE collects application-layer events. It is able to trace execution of callback function to consume a certain buffered message since it annotate message consumption per single message. TILDE serves CARET such capability to trace consumption of buffered messages.</p> <p>See also</p> <ul> <li>TILDE official page</li> <li>Node latency definition</li> </ul>"},{"location":"design/trace_points/","title":"Tracepoints definition","text":"<p>This section lists all tracepoints and their definitions.</p>"},{"location":"design/trace_points/#tracepoints-category","title":"Tracepoints category","text":"<p>CARET is implemented as an extension of ros2_tracing. CARET uses tracing mechanism of user-space tracing served by LTTng. To reduce overhead at runtime, trace points are divided into two types of tracepoints; initialization tracepoints and runtime tracepoints.</p> <p>Some tracepoints are used for collecting meta-information of executors, nodes, callbacks, and topics during application's initialization. They are called initialization tracepoints. The other tracepoints are embedded for sampling timestamps after completion of initialization, and called runtime tracepoints.</p> <p>By binding these trace data together, CARET can provide when and which callbacks were executed.</p> <p>See also</p> <ul> <li>Initialization tracepoints</li> <li>Runtime tracepoints</li> </ul>"},{"location":"design/trace_points/#implementation-method-category","title":"Implementation method category","text":"<p>Each tracepoint for CARET is added by one of following methods.</p> <p></p> <ul> <li>Built-in tracepoints<ul> <li>tracepoints embedded in original ROS 2 middleware which are utilized by ros2-tracing</li> <li>some of tracepoints, for service, action and lifecycle node, are not utilized by current CARET</li> </ul> </li> <li>Hooked tracepoints<ul> <li>CARET-dedicated tracepoints introduced by function hooking with LD_PRELOAD</li> </ul> </li> <li>Extended tracepoints<ul> <li>CARET-dedicated tracepoints added to the fork of rclcpp</li> </ul> </li> </ul> <p>CARET utilizes some of the tracepoints built-in original ROS 2. Some of the tracepoints are added by hooking with LD_PRELOAD, and rest tracepoints are added to the fork of ROS 2's rclcpp.</p> <p> <p>Info</p> <p>Please read this section if you are interested in CARET-dedicated tracepoints are extended by the forked rclcpp and LD_PRELOAD. CARET would like to add tracepoints by function hooking as possible. LD_PRELOAD is reasonable to hook functions defined in dynamic library, but it cannot be applied to functions by implemented with C++ template. Such template-based implementation is mapped into binary file after it is built or compiled. Builtin rclcpp uses C++ template for some functions like intra-process communication, for example. The forked rclcpp is introduced to add tracepoints to the functions.</p> <p>"},{"location":"design/trace_points/diff/","title":"Differences from original ROS","text":"<p> <p>Note</p> <p>This section explains differences between v0.2 implementation of CARET and implementation of ROS 2 Galactic. The explanation is not up-to-date from viewpoints of implementation, but it is enough for readers to understand differences from viewpoints of design.</p> <p>"},{"location":"design/trace_points/diff/#v02-vs-galactic","title":"v0.2 vs galactic","text":"<p>caret.repos contains the following repositories</p> <ul> <li>https://github.com/ros2/rcl.git</li> <li>https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added</li> <li>https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added</li> </ul> <p>They are cloned from original ROS 2 repositories, respectively. This section describes the differences from originals.</p>"},{"location":"design/trace_points/diff/#rcl","title":"rcl","text":"<p>No source code is changed. This package is cloned because rebuilding is necessary for enabling built-in trace points.</p>"},{"location":"design/trace_points/diff/#rclcpp","title":"rclcpp","text":"<p>This cloning is for adding trace point which cannot added via function hooking with LD_PRELOAD.</p> <p>See also</p> <ul> <li>Tracepoints</li> </ul> <p>It's needed to add include directory of ros2_tracing.</p> <p> <p>Info</p> <p>Reason to add include files of ros2_tracing to rclcpp. LD_PRELOAD allows custom shared libraries to be loaded with priority immediately after the start of execution. On the other hand, tracepoints added to the header as described above require that the tracepoint-added version of the header be loaded first during header searching at build time. An include file is added to ensure that this priority is as expected. When the merging of tracepoints to the ros2 mainframe, the addition of the ros2_tracing include file to rclcpp is not necessary.</p> <p>"},{"location":"design/trace_points/diff/#ros2_tracing","title":"ros2_tracing","text":"<p>This cloning is for defining tracepoints added to rclcpp.</p>"},{"location":"design/trace_points/diff/#v03-vs-humble","title":"v0.3 vs Humble","text":"<p>In v0.3, the trace points used in the Galactic version of CARET have been ported. Some tracepoints have been added in Humble, but they are not currently used by CARET. These tracepoints will be supported in a future version.</p>"},{"location":"design/trace_points/initialization_trace_points/","title":"Initialization trace points","text":"<p>Some tracepoints share same addresses (e.g. node_handle and callback address). By binding these addresses, CARET constructs structures of each trace point relationship.</p>"},{"location":"design/trace_points/initialization_trace_points/#relationships-for-each-initialization-trace-points","title":"Relationships for each initialization trace points","text":"<p>Relationships of each trace point related to a single node are shown as follows.</p> <pre><code>erDiagram\n rcl_init{\n address context_handle\n }\n\n caret_init{\n int64_t clock_offset\n string distribution\n }\n\n rcl_node_init{\n address node_handle\n address rmw_handle\n string node_name\n string node_namespace\n }\n\n rcl_publisher_init{\n address publisher_handle\n address node_handle\n address rmw_publisher_handle\n string topic_name\n size_t queue_depth\n }\n\n rcl_subscription_init{\n address subscription_handle\n address node_handle\n address rmw_subscription_handle\n string topic_name\n size_t queue_depth\n }\n\n rclcpp_subscription_init{\n address subscription_handle\n address subscription\n }\n\n rclcpp_subscription_callback_added{\n address subscription\n address callback\n }\n\n rcl_service_init{\n address service_handle\n address node_handle\n address rmw_service_handle\n string service_name\n }\n\n rclcpp_service_callback_added{\n address service_hadle\n address callback\n }\n\n rcl_timer_init{\n address timer_handle\n int64_t period\n }\n\n rclcpp_timer_callback_added{\n address timer_handle\n address callback\n }\n\n rclcpp_timer_link_node{\n address timer_handle\n address node_handle\n }\n\n rclcpp_callback_register{\n address callback\n string function_symbol\n }\n\n rmw_implementation{\n string rmw_impl\n }\n\n    rcl_node_init ||--o{ rcl_publisher_init : node_handle\n    rcl_node_init ||--o{ rcl_subscription_init : node_handle\n    rcl_node_init ||--o{ rclcpp_timer_link_node : node_handle\n    rcl_node_init ||--o{ rcl_service_init : node_handle\n\n    rcl_publisher_init ||--|| PUBLISHER_HANDLE : node_handle\n    rcl_subscription_init ||--|| SUBSCRIPTION_HANDLE : node_handle\n    rcl_timer_init ||--|| TIMER_HANDLE : node_handle\n    rcl_service_init ||--|| SERVICE_HANDLE : node_handle\n\n    rcl_subscription_init ||--|| rclcpp_subscription_init : subscription_handle\n    rclcpp_subscription_init ||--|| rclcpp_subscription_callback_added : subscription\n\n    rcl_service_init ||--|| rclcpp_service_callback_added : service_handle\n    rclcpp_service_callback_added ||--|| rclcpp_callback_register : callback\n\n    rclcpp_timer_callback_added ||--|| rclcpp_callback_register : callback\n    rclcpp_subscription_callback_added ||--|| rclcpp_callback_register : callback\n\n    rclcpp_timer_callback_added ||--|| rcl_timer_init : timer_handle\n    rclcpp_timer_link_node ||--|| rcl_timer_init: timer_handle\n</code></pre>"},{"location":"design/trace_points/initialization_trace_points/#tracepoints-for-representing-structure-of-executor-and-callback-group","title":"Tracepoints for representing structure of executor and callback group","text":"<p>A handler such as <code>timer_handle</code> or <code>subscription_handle</code> is assigned to a callback group. A callback group belongs to an executor.</p> <p>Relationships of each trace point related to executors are shown as follows.</p> <pre><code>erDiagram\n construct_executor{\n address executor_addr\n string executor_type_name\n }\n\n construct_static_executor{\n address executor_addr\n address entities_collector_addr\n string executor_type_name\n }\n\n add_callback_group{\n address executor_addr\n address callback_group_addr\n string group_type_name\n }\n\n add_callback_group_static_executor{\n address entities_collector_addr\n address callback_group_addr\n string group_type_name\n }\n\n callback_group_add_timer{\n address callback_group_addr\n address timer_handle\n }\n\n callback_group_add_subscription{\n address callback_group_addr\n address subscription_handle\n }\n\n callback_group_add_service{\n address callback_group_addr\n address service_handle\n }\n\n callback_group_add_client{\n address callback_group_addr\n address client_handle\n }\n\n\n construct_executor ||--o{ add_callback_group : executor_addr\n construct_static_executor ||--o{ add_callback_group_static_executor : entities_collector_addr\n\n    add_callback_group_static_executor ||--o{ callback_group_add_timer : callback_group_addr\n    add_callback_group_static_executor ||--o{ callback_group_add_subscription : callback_group_addr\n    add_callback_group_static_executor ||--o{ callback_group_add_service : callback_group_addr\n    add_callback_group_static_executor ||--o{ callback_group_add_client : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_timer : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_subscription : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_service : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_client : callback_group_addr\n\n    callback_group_add_timer ||--|| TIMER_HANDLE : callback_group_addr\n    callback_group_add_subscription ||--|| SUBSCRIPTION_HANDLE : callback_group_addr\n    callback_group_add_service ||--|| SERVICE_HANDLE : callback_group_addr\n    callback_group_add_client ||--|| CLIENT_HANDLE : callback_group_addr\n\n</code></pre>"},{"location":"design/trace_points/initialization_trace_points/#trace-point-definition","title":"Trace point definition","text":"<p>The following shows the definition of trace points. A handler such as <code>timer_handle</code> or <code>subscription_handle</code> is assigned to a callback group. A callback group belongs to an executor.</p> <p>Trace points with <code>(caret_trace added)</code> are hooked and added init_timestamp by caret_trace. See Runtime recording for detail.</p>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_init","title":"ros2:rcl_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * context_handle</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_node_init","title":"ros2:rcl_node_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * node_handle</li> <li>void * rmw_handle</li> <li>char * node_name</li> <li>char * node_namespace</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_publisher_init","title":"ros2:rcl_publisher_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * node_handle</li> <li>void * rmw_publisher_handle</li> <li>char * topic_name</li> <li>size_t queue_depth</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_subscription_init","title":"ros2:rcl_subscription_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * subscription_handle</li> <li>void * node_handle</li> <li>void * rmw_subscription_handle</li> <li>char * topic_name</li> <li>size_t queue_depth</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_subscription_init","title":"ros2:rclcpp_subscription_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * subscription_handle</li> <li>void * subscription</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_subscription_callback_added","title":"ros2:rclcpp_subscription_callback_added","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * subscription</li> <li>void * callback</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_service_init","title":"ros2:rcl_service_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * service_handle</li> <li>void * node_handle</li> <li>void * rmw_service_handle</li> <li>char * service_name</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_service_callback_added","title":"ros2:rclcpp_service_callback_added","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * service_handle</li> <li>void * callback</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_timer_init","title":"ros2:rcl_timer_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * timer_handle</li> <li>int64_t period</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_timer_callback_added","title":"ros2:rclcpp_timer_callback_added","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * timer_handle</li> <li>void * callback</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_timer_link_node","title":"ros2:rclcpp_timer_link_node","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * timer_handle</li> <li>void * node_handle</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_callback_register","title":"ros2:rclcpp_callback_register","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback</li> <li>char * function_symbol</li> <li>int64_t init_timestamp (caret_trace added)</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcaret_init","title":"ros2_caret:caret_init","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>int64_t clock_offset</li> <li>char * distribution</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretrmw_implementation","title":"ros2_caret:rmw_implementation","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>char * rmw_impl</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretconstruct_executor","title":"ros2_caret:construct_executor","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * executor_addr</li> <li>char * executor_type_name</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretconstruct_static_executor","title":"ros2_caret:construct_static_executor","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * executor_addr</li> <li>void * entities_collector_addr</li> <li>char * executor_type_name</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretadd_callback_group","title":"ros2_caret:add_callback_group","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * executor_addr</li> <li>void * callback_group_addr</li> <li>char * group_type_name</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretadd_callback_group_static_executor","title":"ros2_caret:add_callback_group_static_executor","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * entities_collector_addr</li> <li>void * callback_group_addr</li> <li>char * group_type_name</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_timer","title":"ros2_caret:callback_group_add_timer","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * timer_handle</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_subscription","title":"ros2_caret:callback_group_add_subscription","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * subscription_handle</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_service","title":"ros2_caret:callback_group_add_service","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * service_handle</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_client","title":"ros2_caret:callback_group_add_client","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * client_handle</li> <li>int64_t init_timestamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/","title":"Runtime trace points","text":""},{"location":"design/trace_points/runtime_trace_points/#relationships-of-each-runtime-trace-points","title":"Relationships of each runtime trace points","text":"<pre><code>erDiagram\n\n callback_start{\n address callback\n bool is_intra_process\n }\n\n callback_end{\n address callback\n }\n\n message_construct{\n address original_message\n address constructed_message\n }\n\n dds_bind_addr_to_addr{\n address addr_from\n address addr_to\n }\n\n rclcpp_intra_publish{\n address publisher_handle\n address message\n }\n\n rmw_take{\n address rmw_subscription_handle\n address message\n uint64_t source_timestamp\n bool taken\n }\n\n dispatch_subscription_callback{\n address message\n address callback\n uint64_t source_timestamp\n uint64_t message_timestamp\n }\n\n dispatch_intra_process_subscription_callback{\n address message\n address callback\n uint64_t message_timestamp\n }\n\n rcl_publish{\n address publisher_handle\n address message\n }\n\n rclcpp_publish{\n address publisher_handle\n address message\n }\n\n dds_write{\n address message\n }\n\n dds_bind_addr_to_stamp{\n address addr\n uint64_t source_stamp\n }\n\n    rclcpp_intra_publish ||--|| dispatch_intra_process_subscription_callback: message_addr\n    rclcpp_publish ||--|| rcl_publish: message_addr\n    rcl_publish ||--|| dds_write: message_addr\n    dds_write ||--|| dds_bind_addr_to_stamp: message_addr\n\n    dds_bind_addr_to_stamp ||--|| dispatch_subscription_callback: source_timestamp\n\n    dds_bind_addr_to_stamp ||--|| rmw_take: source_timestamp\n    rmw_take ||--|| callback_start: tid\n    dispatch_intra_process_subscription_callback ||--|| callback_start: callback\n    dispatch_subscription_callback ||--|| callback_start: callback\n\n    callback_start ||--|| callback_end: callback\n</code></pre> <p>Using addresses, thread id (<code>tid</code>) and source timestamp, CARET is able to identify a pair of message publish and corresponding subscription. However, it's difficult to associate a certain message publish to corresponding callback execution because mapping between callback and publish cannot be obtained automatically.</p> <p><code>message_construct</code> and <code>dds_bind_addr_to_addr</code> are trace points to adapt to copying and converting instances for binding.</p>"},{"location":"design/trace_points/runtime_trace_points/#trace-point-definition","title":"Trace point definition","text":""},{"location":"design/trace_points/runtime_trace_points/#ros2callback_start","title":"ros2:callback_start","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback</li> <li>bool is_intra_process</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2callback_end","title":"ros2:callback_end","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2message_construct","title":"ros2:message_construct","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * original_message</li> <li>void * constructed_message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2rclcpp_intra_publish","title":"ros2:rclcpp_intra_publish","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2dispatch_subscription_callback-before-v049","title":"ros2:dispatch_subscription_callback (before v0.4.9)","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * message</li> <li>void * callback</li> <li>uint64_t source_timestamp</li> <li>uint64_t message_timestamp</li> </ul> <p>This tracepoint is no longer used from v0.4.10 onwards.</p>"},{"location":"design/trace_points/runtime_trace_points/#ros2rmw_take-after-v0410","title":"ros2:rmw_take (after v0.4.10)","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * rmw_subscription_handle</li> <li>void * message</li> <li>int64_t * source_timestamp</li> <li>bool * taken</li> </ul> <p>In CARET, this tracepoint is used to correctly link the <code>callback_start</code> to the <code>rclcpp_publish</code> that triggered the callback. Until version 0.4.9, ros2:dispatch_subscription_callback was used to link <code>rclcpp_publish</code> and <code>callback_start</code> events.</p>"},{"location":"design/trace_points/runtime_trace_points/#ros2dispatch_intra_process_subscription_callback","title":"ros2:dispatch_intra_process_subscription_callback","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * message</li> <li>void * callback</li> <li>uint64_t message_timestamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2rcl_publish","title":"ros2:rcl_publish","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2rclcpp_publish","title":"ros2:rclcpp_publish","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_write","title":"ros2_caret:dds_write","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_bind_addr_to_stamp","title":"ros2_caret:dds_bind_addr_to_stamp","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * addr</li> <li>uint64_t source_stamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_bind_addr_to_addr","title":"ros2_caret:dds_bind_addr_to_addr","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * addr_from</li> <li>void * addr_to</li> </ul>"},{"location":"design/visualizations/","title":"Visualizations","text":"<p>CARET is a tool for performance evaluation and analysis.</p> <p>For evaluation, quantification and visualization would be sufficient. For analysis, on the other hand, various factors are involved in behavior and performance, so it is necessary to investigate from multiple perspectives.</p> <p>CARET has multiple visualizations for evaluation and analysis APIs. Also, CARET let you to directly acquire and evaluate the data on your own (see Processing trace data for detail).</p>"},{"location":"design/visualizations/#policy","title":"Policy","text":""},{"location":"design/visualizations/#evaluation-flow","title":"Evaluation flow","text":"<p>CARET handles a large amount of recorded events, which prevents you from investigating performance of your application smoothly. Just displaying recorded events thoughtlessly might waste your time. So, it is important to focus on evaluation targets with appropriate granularity according to the purpose of evaluation.</p> <p>The following diagram shows the evaluation flow and analysis by adjusting the granularity.</p> <p></p> <p>Here, the horizontal axis represents the visualization granularity and the vertical axis represents the processing granularity. Those definitions will be explained subsequent sections.</p> <p>CARET help you to find issues and their causes by changing the processing and visualization granularity, respectively. You can approach an issues and its cause step by step from rough to fine granularity, from right-upper to left-lower in the figure.</p> <ol> <li>Detect issues: Detects performance issues on the target system.</li> <li>Identify issues: Identify the bottleneck that is causing the issue.</li> <li>Identify causes: Identifies the cause of the bottleneck.</li> </ol> <p>Processing granularity on the horizontal axis and visualization granularity on the vertical axis are explained in the following section.</p>"},{"location":"design/visualizations/#visualization-granularity","title":"Visualization granularity","text":"<p>The granularity of visualizations are listed below in order of fine granularity.</p> <ul> <li>Time-series trace data</li> <li>Bar graph / Line graph</li> <li>Heatmap</li> <li>Histogram</li> <li>Statistic</li> </ul> <p>The coarser granularity, the more time information is aggregated to evaluate the measurement as a whole. The most granular statistics are suitable for regression testing.</p> <p>On the other hand, the finer granularity, the more detailed information is expressed, so it is more suitable for analysis. Latency and response time are mainly used metrics to evaluate performance. The most detailed information is a time-series graph of each trace data.</p>"},{"location":"design/visualizations/#processing-granularity","title":"Processing granularity","text":"<p>The processing granularity means granularity of subsystem in an application, it is ordered in coarse order as follows.</p> <ul> <li>path</li> <li>node / communication</li> <li>callback</li> <li>function</li> </ul> <p>Path is suitable for performance evaluation per system , while node and callback are suitable for performance evaluation per component or smaller subsystem.</p> <p> <p>Notice<p>In the present, CARET does not support measurement of arbitrary functions or DDS enqueue/dequeue or system calls.</p> </p> <p> <p>See also</p> <ul> <li>Event and latency definition</li> </ul>"},{"location":"design/visualizations/#metrics-category","title":"Metrics category","text":"<p>We described behavior and metrics in terms of visualization granularity, but there are multiple metrics, such as latency and frequency. Metrics for performance analysis is categorized into two types; time-related metrics and frequency-related metrics. CARET recommends you to be aware two types.</p> <ul> <li>Time Domain Metrics (ex: callback execution time [s])</li> <li>Frequency Domain Metrics (ex: topic frequency [Hz])</li> </ul> <p>Both have their pros and cons.</p> Time Domain Metrics Frequency Domain Metrics Metric Latency, Response time Frequency (, Period) Pros Easy to compare with system requirements No need to define latency or path Cons Need to define latency or path Difficult to compare with system requirements <p>In the table above, period is metrics that expresses the time interval between sequential cyclic events, so it is classified into the frequency-related metrics.</p> <p>See also</p> <ul> <li>Records service</li> </ul>"},{"location":"faq/faq/","title":"FAQ","text":""},{"location":"faq/faq/#installation","title":"Installation","text":""},{"location":"faq/faq/#setup-fails","title":"Setup fails","text":"<ul> <li>In case you encounter errors during setup or build process, please make sure to use an appropriate branch for your environment<ul> <li>ROS 2 Galactic, Ubuntu 20.04: <code>galactic</code> branch</li> <li>ROS 2 Humble, Ubuntu 22.04: main branch</li> </ul> </li> <li>It's also important to delete <code>./build</code> <code>./install</code> and <code>./src</code> directory before rebuilding CARET if you have built CARET using wrong settings</li> </ul>"},{"location":"faq/faq/#cli-tool-doesnt-work","title":"CLI tool doesn't work","text":"<p>In case CLI tool execution fails, please make sure to perform CARET environment settings</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\nros2 caret check_caret_rclcpp &lt;path-to-workspace&gt;\n</code></pre> <p> <p>Warning</p> <p>CARET CLI tool doesn't work properly in Anaconda environment. Please use pure Python.</p> <p>"},{"location":"faq/faq/#recording","title":"Recording","text":""},{"location":"faq/faq/#lttng-session-doesnt-start-after-ros2-caret-record","title":"LTTng session doesn't start after <code>ros2 caret record</code>","text":"<ul> <li>Check detailed status for recording sequence by adding <code>-verbose</code> option (e.g. <code>ros2 caret record -v</code> )<ul> <li>You will see <code>N/M process started recording</code> , where <code>N</code> is the number of processes which have been started recording and <code>M</code> is the number of total processes to be started recording</li> </ul> </li> <li>If <code>N</code> increases very slowly, add <code>--recording-frequency</code> option with integer greater than 100 (e.g. <code>ros2 caret record -f 500</code> )<ul> <li>Please be careful that it increases the possibility of recording failure</li> </ul> </li> <li>If <code>N</code> remains 0, remove <code>~/.lttng</code> and start recording again<ul> <li>Please be careful that the first recorded trace data after removing <code>~/.lttng</code> tends to lack some events. So, please ignore the data</li> </ul> </li> <li>It's also important to make sure you don't have another LTTng session running</li> </ul>"},{"location":"faq/faq/#so-many-nodes-named-caret_trace_ooooooo-created","title":"So many nodes named <code>/caret_trace_ooooooo</code> created","text":"<ul> <li>As described in design section, a node to store CARET events is created for each process. Therefore, if a target application is huge and has a lot of processes, the number of CARET nodes also becomes huge</li> </ul>"},{"location":"faq/faq/#visualization","title":"Visualization","text":""},{"location":"faq/faq/#result-plot-message_flow-etc-is-not-outputted-or-there-seems-something-wrong-with-the-result","title":"Result (plot, message_flow, etc.) is not outputted, or there seems something wrong with the result","text":"<ul> <li>Please use the following commands for verification<ul> <li><code>ros2 caret check_caret_rclcpp</code> to check if a target application is built with CARET/rclcpp</li> <li><code>ros2 caret check_ctf</code> to check if tracing data is recorded properly</li> </ul> </li> <li>Please make sure the followings:<ul> <li>A target application is built with CARET/rclcpp</li> <li>CARET environment is set properly before running a target application<ul> <li><code>export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)</code></li> <li><code>source ~/ros2_caret_ws/install/local_setup.bash</code></li> </ul> </li> <li>LTTng trace is started before running a target application<ul> <li><code>ros2 trace -s e2e_sample -k -u \"ros2*\"</code></li> <li>or consider to use launch file</li> </ul> </li> <li>Trace data is not discarded<ul> <li>In case trace data is discarded, use Trace filter</li> </ul> </li> <li>The size of trace data is proper<ul> <li>If the size of trace data is extremely small (e.g. only few KByte) and a target application has lots of nodes, the maximum number of file descriptors may not be enough. It can be increased by <code>ulimit -n 65536</code></li> </ul> </li> </ul> </li> <li>See Recording for more details</li> </ul>"},{"location":"faq/faq/#parts-of-results-are-not-outputted","title":"Parts of results are not outputted","text":"<ul> <li>If certain nodes are not traced but some nodes are traced, some packages may be built without CARET/rclcpp. Please make sure <code>&lt;depend&gt;rclcpp&lt;/depend&gt;</code> is described in <code>package.xml</code></li> <li>Another possibility is that some nodes can't be analyzed due to CARET's limitations:<ul> <li>CARET cannot analyze a node which has two or more timer callbacks with the same period time setting</li> <li>CARET cannot analyze a node which has two or more subscription callbacks with the same topic name</li> </ul> </li> <li>Callback information in such nodes are not outputted. Also, message flow will be discontinued at such nodes</li> </ul>"},{"location":"faq/faq/#traceresultanalyzeerror-failed-to-find-error-occurs","title":"<code>TraceResultAnalyzeError: Failed to find</code> error occurs","text":"<ul> <li>The error occurs if information in an architecture file and trace data are inconsistent with each other</li> <li>Please modify the architecture file or check recording process</li> <li>e.g.<ul> <li><code>TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)()</code></li> </ul> </li> </ul>"},{"location":"faq/faq/#visualization-callback","title":"Visualization (callback)","text":""},{"location":"faq/faq/#callback-frequency-is-smaller-than-expected-value","title":"Callback frequency is smaller than expected value","text":"<ul> <li><code>Plot.create_callback_frequency_plot</code> calculates frequency from one second to one second. It counts how many times a callback function is called for a second, and just uses the count as frequency. Therefore, the frequency on the last term tends to small because the last term is usually shorter than one second</li> <li>Another possibility is that the frequency of a subscription callback will be small if it receives topics not periodically but infrequently. Also, the frequency of a timer callback will be small if the timer dynamically stops/starts</li> </ul>"},{"location":"faq/faq/#callback-latency-is-bigger-than-expected-value","title":"Callback latency is bigger than expected value","text":"<ul> <li>Some nodes may run initialization process. In this case, the latency time calculated by <code>Plot.create_callback_latency_plot</code> is huge on the first execution</li> </ul>"},{"location":"faq/faq/#visualization-message-flow","title":"Visualization (message flow)","text":""},{"location":"faq/faq/#message-flow-is-discontinued","title":"Message flow is discontinued","text":"<ul> <li>If parts of nodes/communications don't run at all during recording, message flow stops on the way and such nodes/communications are not displayed on y-axis<ul> <li>Please make sure that all nodes/communications in a target path run during recording, or modify a target path to analyze actually working path</li> </ul> </li> <li>Another possibility is that a target path includes a node which CARET cannot analyze due to its limitations as explained above</li> </ul>"},{"location":"faq/faq/#what-is-a-gray-color-rectangle-in-a-message-flow-diagram","title":"What is a gray color rectangle in a message flow diagram?","text":"<ul> <li>A rectangle in a message flow diagram indicates a period from the entry to the exit of a callback function, while a line shows a flow of topics</li> <li>Note: a rectangle is not always illustrated</li> </ul>"},{"location":"faq/faq/#huge-delay-between-topic-publication-and-callback-start","title":"Huge delay between topic publication and callback start","text":"<ul> <li>In a message flow diagram, elapsed time from <code>ooo/rclcpp_publish</code> to <code>ooo/callback_start</code> means latency from when a topic is published to when the following callback starts</li> <li>It includes the following time:<ul> <li>Communication (topic) latency</li> <li>Wait by ROS scheduler</li> <li>Wait by OS scheduler</li> </ul> </li> <li>In most cases, it doesn't take so much time. In case the time is huge, the followings are possible causes:<ul> <li>There is a problem in communication</li> <li>An executor cannot wake up because other processes occupy CPU</li> <li>A callback cannot wake up because other callbacks in the same callback group occupy the executor</li> <li>Processing time of a callback is longer than topic subscription period</li> </ul> </li> </ul>"},{"location":"faq/faq/#message-flow-looks-split","title":"Message flow looks split","text":"<ul> <li>Take the following system for example;<ul> <li><code>Node_C</code> publishes a topic when it receives a topic from <code>Node_A</code></li> <li><code>Node_A</code> publishes a topic with a rate of 50 Hz, while <code>Node_B</code> publishes a topic at 10 Hz</li> </ul> </li> <li>Message flow (<code>Node_B</code> -&gt; <code>Node_C</code> -&gt; <code>Node_D</code>) looks split at <code>Node_C</code>. It's because <code>Node_C</code> publishes 5 topics while receiving 1 topic from <code>Node_B</code></li> <li>Note: A similar phenomenon will happen even if <code>Callback c0</code> is a timer callback</li> </ul>"},{"location":"faq/faq/#message-flow-looks-dropped","title":"Message flow looks dropped","text":"<ul> <li>Take the following system for example;<ul> <li><code>Node_C</code> publishes a topic when it receives a topic from <code>Node_A</code></li> <li><code>Node_A</code> publishes a topic with a rate of 10 Hz, while <code>Node_B</code> publishes a topic at 50 Hz</li> </ul> </li> <li>Message flow (<code>Node_B</code> -&gt; <code>Node_C</code> -&gt; <code>Node_D</code>) looks disconnected at <code>Node_C</code> four times every five messages. It's because <code>Node_C</code> publishes 1 topic while receiving 5 topics from <code>Node_B</code>. So 4 topics don't have a corresponding topic to be published to <code>Node_D</code></li> <li>Note: A similar phenomenon will happen even if <code>Callback c0</code> is a timer callback</li> </ul>"},{"location":"faq/faq/#how-response-time-is-calculated","title":"How response time is calculated?","text":"<ul> <li>In general, response time is the time a system or functional unit takes to react to a given input (reference). Response time calculated by CARET is the time it takes for input data to arrive at the last node. It doesn't include processing time at the first/last node nor latency of an actuator. It's calculated as the sum of communication latency time (from the time when a node publishes a topic to the time when the following node subscribes the topic) and node latency time (from the time when a node subscribes a topic to the time when it publishes another topic) in a path<ul> <li>In the following diagram, input data at point A is first reflected with output at point X (<code>ResponseTime_Best</code>)</li> <li><code>ResponseTime_Best</code> can be considered as a path (dataflow) latency time</li> <li><code>ResponseTime_Best</code> can be considered as a happy case, which is contrary to the following worst case scenario</li> </ul> </li> <li>Assuming that input information is created by a sensor such as an object detection sensor, delay in a sensor should be considered. For instance, if a new object appears at point B, the time from point B to point A should added to the response time. The worst case scenario is that a new object appears just after the previous flow (point C). Response time for the worst case is shown as <code>ResponseTime_Worst</code></li> <li>CARET can calculate both <code>ResponseTime_Best</code> and <code>ResponseTime_Worst</code> using the following APIs:<ul> <li><code>response_time.to_best_case_timeseries()</code> , <code>response_time.to_best_case_histogram()</code></li> <li><code>response_time.to_worst_case_timeseries()</code> , <code>response_time.to_best_worst_histogram()</code></li> </ul> </li> <li>CARET also provides <code>response_time.to_histogram()</code> API. It creates histogram assuming a new object appears from point C to point A at intervals of histogram bin size</li> </ul>"},{"location":"faq/known_issues/","title":"Known issues","text":""},{"location":"faq/known_issues/#install","title":"Install","text":""},{"location":"faq/known_issues/#warnings-caused-by-setuppy","title":"Warnings caused by <code>setup.py</code>","text":"<ul> <li>Issue<ul> <li>The following warnings happen when building CARET</li> </ul> </li> </ul> <pre><code>/usr/local/lib/python3.10/dist-packages/setuptools/command/develop.py:40: EasyInstallDeprecationWarning: easy_install command is deprecated.\n!!\n\n        ********************************************************************************\n        Please avoid running ``setup.py`` and ``easy_install``.\n        Instead, use pypa/build, pypa/installer or other\n        standards-based tools.\n\n        See https://github.com/pypa/setuptools/issues/917 for details.\n        ********************************************************************************\n\n!!\n  easy_install.initialize_options(self)\n</code></pre> <pre><code>/usr/local/lib/python3.10/dist-packages/setuptools/_distutils/cmd.py:66: SetuptoolsDeprecationWarning: setup.py install is deprecated.\n!!\n\n        ********************************************************************************\n        Please avoid running ``setup.py`` directly.\n        Instead, use pypa/build, pypa/installer or other\n        standards-based tools.\n\n        See https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html for details.\n        ********************************************************************************\n\n!!\n  self.initialize_options()\n</code></pre> <ul> <li>Cause<ul> <li>Python3 deprecates building with <code>setup.py</code></li> <li>However, <code>setup.py</code> is used to build ROS 2 by colcon</li> </ul> </li> <li>Workaround<ul> <li>This warning does not prevent CARET from working and does not require any action</li> <li>However, if you really want to remove the warning, the following steps can be taken to suppress the warning</li> </ul> </li> </ul> <pre><code>export PYTHONWARNINGS=ignore:\"setup.py install is deprecated.\",ignore:\"easy_install command is deprecated.\"\n</code></pre>"},{"location":"faq/known_issues/#build","title":"Build","text":""},{"location":"faq/known_issues/#conflicts-of-dependency-on-libtracetoolsso","title":"Conflicts of dependency on <code>libtracetools.so</code>","text":"<ul> <li>Issue<ul> <li>The following errors happen when building a target application with certain packages like <code>pcl_ros</code><ul> <li><code>undefined reference to `ros_trace_message_construct'</code></li> <li><code>undefined reference to `ros_trace_rclcpp_intra_publish'</code></li> <li><code>undefined reference to `ros_trace_dispatch_subscription_callback'</code></li> <li>and so on</li> </ul> </li> </ul> </li> <li>Cause<ul> <li><code>~/ros2_caret_ws/install/tracetools/lib/libtracetools.so</code> needs to be linked, but <code>/opt/ros/humble/lib/libtracetools.so</code> is referred when using some packages</li> <li>For instance, <code>pcl_ros</code> package has <code>/opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake</code> which enforces <code>/opt/ros/humble/lib/libtracetools.so</code> to be linked</li> </ul> </li> <li>Workaround<ul> <li>Remove <code>/opt/ros/humble/lib/libtracetools.so;</code> from <code>/opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake</code></li> </ul> </li> </ul> <pre><code>sudo cp /opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake /opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake.bak\nsudo sed -i -e 's/\\/opt\\/ros\\/humble\\/lib\\/libtracetools.so;//g' /opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake\n</code></pre>"},{"location":"faq/known_issues/#build-using-ament_cmake","title":"Build using ament_cmake","text":"<ul> <li>Issue<ul> <li>The following error happens when building a target application using ament_cmake<ul> <li><code>error: too few arguments to function \u2018void ros_trace_rclcpp_publish</code></li> </ul> </li> </ul> </li> <li>Cause<ul> <li><code>SYSTEM</code> is added as dependencies in ament_cmake_auto by this PR. As a result, ros2/rclcpp is used rather than CARET/rclcpp in some packages</li> </ul> </li> <li>Workaround<ul> <li>Remove <code>SYSTEM</code> from dependencies in ament_cmake_auto</li> </ul> </li> </ul> <pre><code>cd /opt/ros/humble/share/ament_cmake_auto/cmake/\nsudo cp ament_auto_add_executable.cmake ament_auto_add_executable.cmake.bak\nsudo cp ament_auto_add_library.cmake ament_auto_add_library.cmake.bak\nsudo sed -i -e 's/SYSTEM//g' ament_auto_add_executable.cmake\nsudo sed -i -e 's/SYSTEM//g' ament_auto_add_library.cmake\n</code></pre>"},{"location":"faq/known_issues/#systems-rclcpp-is-referred","title":"SYSTEM's rclcpp is referred","text":"<ul> <li>Issue<ul> <li>The following error happens when building a target application</li> </ul> </li> </ul> <pre><code>/opt/ros/humble/include/rclcpp/rclcpp/publisher.hpp: In member function \u2018void rclcpp::Publisher&lt;MessageT, AllocatorT&gt;::do_inter_process_publish(const ROSMessageType&amp;)\u2019:\n/opt/ros/humble/include/rclcpp/rclcpp/publisher.hpp:452:5: error: too few arguments to function \u2018void ros_trace_rclcpp_publish(const void*, const void*, uint64_t)\u2019\n  452 |     TRACEPOINT(rclcpp_publish, nullptr, static_cast&lt;const void *&gt;(&amp;msg));\n</code></pre> <ul> <li>Cause<ul> <li>To build with CARET, caret/rclcpp should be used. However, in case rclcpp in SYSTEM ( <code>/opt/ros/humble</code> ) is used for some reasons, build will fail</li> <li>Take <code>pcl_ros</code> for example, <code>/opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake</code> enforces <code>/opt/ros/humble/include/rclcpp</code> to be referred. So that caret/rclcpp is not used and building a package depending on <code>pcl_ros</code> will fail</li> </ul> </li> <li>Workaround<ul> <li>Remove <code>/opt/ros/humble/include/rclcpp;</code> from <code>/opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake</code></li> </ul> </li> </ul> <pre><code>sudo cp /opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake /opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake.bak2\nsudo sed -i -e 's/\\/opt\\/ros\\/humble\\/include\\/rclcpp;//g' /opt/ros/humble/share/pcl_ros/cmake/export_pcl_rosExport.cmake\n</code></pre>"},{"location":"faq/known_issues/#recording","title":"Recording","text":""},{"location":"faq/known_issues/#only-metadata-is-recorded","title":"Only metadata is recorded","text":"<ul> <li>Issue<ul> <li>Only metadata file (<code>~/.ros/tracing/ooo/ust/uid/1000/64-bit/metadata</code>) is created, and the size of the trace data is always about 28 KByte</li> </ul> </li> <li>Cause<ul> <li>The size of LTTng buffer is too large for some environments</li> <li>It happens especially when<ul> <li>Recording on Docker</li> <li>and the number of CPUs is large (e.g. 24 cores)</li> </ul> </li> </ul> </li> <li>Workaround<ul> <li>Decrease the number of the LTTng buffer size<ul> <li>lttng_impl.py<ul> <li>Rebuild is not required after the modification</li> </ul> </li> <li>Please note that decreasing the buffer size may cause tracer discarded</li> </ul> </li> </ul> </li> </ul>"},{"location":"installation/installation/","title":"Installation","text":""},{"location":"installation/installation/#requirements","title":"Requirements","text":"<p>CARET is confirmed to run on the platforms shown in the following table with supported version.</p> dependent platform supported version ROS Humble Ubuntu 22.04 LTTng stable-2.13 Linux Kernel 5.15.x Python3 3.10.x <p>The recent version, after v0.3.0, of CARET supports only the combination of ROS 2 Humble and Ubuntu 22.04. If you want to run CARET on ROS 2 Galactic and Ubuntu 20.04, please refer to documents for v0.2.3</p>"},{"location":"installation/installation/#installation_1","title":"Installation","text":"<p>Installation using meta repository is the least time-consuming way to install CARET. With meta repository and Ansible, you can skip the laborious manual setup which is explained in manual installation(./manual_installation.md) section (written in Japanese).</p> <p>Please execute the following steps on Ubuntu 20.04. The order is important so that you have to follow the steps in order.</p> <ol> <li> <p>Clone <code>caret</code> and enter the directory.</p> <pre><code>git clone https://github.com/tier4/caret.git ros2_caret_ws\ncd ros2_caret_ws\n</code></pre> <p><code>main</code> branch is dedicated for ROS 2 Humble. If you want to use CARET for ROS 2 Galactic, please execute <code>git checkout galactic</code> in <code>ros2_caret_ws</code> directory.</p> </li> <li> <p>Create the src directory and clone repositories into it.</p> <p>CARET uses vcstool to construct workspaces.</p> <pre><code>mkdir src\nvcs import src &lt; caret.repos\n</code></pre> </li> <li> <p>Run <code>setup_caret.sh</code>.</p> <pre><code>./setup_caret.sh\n</code></pre> </li> <li> <p>Build the workspace.</p> <pre><code>source /opt/ros/humble/setup.bash\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> </li> <li> <p>Check whether CARET (ros2-tracing) is enabled.</p> <p>CARET inherits some functions from ros2-tracing.</p> <pre><code>source ~/ros2_caret_ws/install/local_setup.bash\nros2 run tracetools status # return Tracing enabled\n</code></pre> </li> </ol> <p>If you see <code>Tracing enabled</code>, you can continue to apply CARET to your application.</p>"},{"location":"installation/manual_installation/","title":"Manual installation","text":""},{"location":"installation/manual_installation/#installation-of-required-packages","title":"Installation of required packages","text":""},{"location":"installation/manual_installation/#install-lttng","title":"Install LTTng","text":"<p>Refer to the official document for LTTng for details</p> <pre><code>sudo apt-add-repository ppa:lttng/stable-2.13\nsudo apt-get update\nsudo apt-get install lttng-tools liblttng-ust-dev\nsudo apt-get install python3-babeltrace python3-lttng\n</code></pre>"},{"location":"installation/manual_installation/#install-packages-to-build-caret","title":"Install packages to build CARET","text":"<p>Install ROS 2 Humble and related packages. See also the official document for ROS 2.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y \\\nbuild-essential \\\ncmake \\\ngit \\\npython3-colcon-common-extensions \\\npython3-flake8 \\\npython3-pip \\\npython3-pytest-cov \\\npython3-rosdep \\\npython3-setuptools \\\npython3-vcstool \\\npython3-bt2 \\\nwget\n\npython3 -m pip install -U \\\nflake8-blind-except \\\nflake8-builtins \\\nflake8-class-newline \\\nflake8-comprehensions \\\nflake8-deprecated \\\nflake8-docstrings \\\nflake8-import-order \\\nflake8-quotes \\\npytest-repeat \\\npytest-rerunfailures \\\npytest \\\nsetuptools \\\ncolorcet\n\nsudo apt install ros-humble-desktop\n</code></pre> <p>Install packages related with <code>ros2_tracing</code></p> <pre><code>sudo apt install -y \\\nros-humble-ros2trace \\\nros-humble-ros2trace-analysis \\\nros-humble-tracetools \\\nros-humble-tracetools-analysis \\\nros-humble-tracetools-launch \\\nros-humble-tracetools-read \\\nros-humble-tracetools-test \\\nros-humble-tracetools-trace\n</code></pre> <p>Install packages for visualization with CARET.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y \\\ngraphviz \\\ngraphviz-dev\n\npython3 -m pip install -U \\\npytest-mock \\\npybind11 \\\n'pandas&gt;=1.4.0' \\\nbokeh \\\npandas-bokeh \\\njupyterlab \\\ngraphviz\n\n# If you see the message, [ImportError: The Jupyter Server requires tornado &gt;=6.1.0] during installing jupyterlab,\n# upgrade tornado with the following command.\n# pip install tornado --upgrade\n</code></pre>"},{"location":"installation/manual_installation/#source-build-of-caret","title":"Source build of CARET","text":"<pre><code>mkdir -p ~/ros2_caret_ws/src\ncd ~/ros2_caret_ws\n\nwget https://raw.githubusercontent.com/tier4/caret/main/caret.repos\nvcs import src &lt; caret.repos\n\nrosdep install \\\n--from-paths src --ignore-src \\\n--rosdistro humble -y \\\n--skip-keys \"console_bridge fastcdr fastrtps rti-connext-dds-5.3.1 urdfdom_headers\"\n\n# If you find the error message, [ERROR: the following packages/stacks could not have their rosdep keys resolved],\n# execute rosdep initialization and update with the following two commands.\n# rosdep init\n# rosdep update\nsource /opt/ros/humble/setup.bash\n\n# Create symbolic link so that the header files, which are provided by the forked packages, should be referred\nln -sf ~/ros2_caret_ws/src/ros-tracing/ros2_tracing/tracetools/include/tracetools ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\nln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_action/include/rclcpp_action ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\nln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_components/include/rclcpp_components/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\nln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_lifecycle/include/rclcpp_lifecycle/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\n\n# Build CARET with colcon command\ncolcon build --cmake-args -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTING=off  --symlink-install\n</code></pre> <p>Check whether <code>ros2_tracing</code> is available</p> <pre><code>$ source ~/ros2_caret_ws/install/local_setup.bash\n$ ros2 run tracetools status\nTracing enabled\n</code></pre>"},{"location":"recording/","title":"Recording with CARET","text":""},{"location":"recording/#introduction","title":"Introduction","text":"<p>Recording includes two sub-steps at least; building a target application from source code and executing the target application. After execution, you will find trace data which has events data sampled by tracepoints.</p> <p>Trace data validation is necessary as the third step because any failure on recording prevents users from analyzing performance correctly. Trace data is not recorded correctly due to any reason if a target application is large or any failure involves in the previous steps. CARET serves functions to validate trace data for the step.</p> <p>CARET supports trace filter to exclude certain nodes or topics during recording. It is optional, but strongly recommended for analysis of a large application.</p>"},{"location":"recording/#steps-to-record-trace-data-with-caret","title":"Steps to record trace data with CARET","text":"<ul> <li>Build a target application with CARET and check it (See details)</li> <li>(Optional) Configure trace filter (See details)</li> <li>Record the application (See details)</li> <li>Validate trace data (See details)</li> </ul>"},{"location":"recording/#other-tips","title":"Other tips","text":"<ul> <li>CLI tools</li> <li>ROS time (sim_time) support</li> </ul>"},{"location":"recording/build_check/","title":"Build with CARET","text":""},{"location":"recording/build_check/#build-a-target-application-with-caret","title":"Build a target application with CARET","text":"<p>A target application should be built with CARET/rclcpp to record trace data. If you have already built the application without CARET/rclcpp, you have to build the application with CARET/rclcpp again.</p> <p>For building the application with CARET/rclcpp, CARET's <code>local_setup.bash</code> should be applied along with ROS 2's <code>setup.bash</code> as shown below. Also, <code>-DBUILD_TESTING=OFF</code> should be given to build option.</p> <pre><code>cd &lt;path-to-workspace&gt;\n\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash  # please keep the order after ROS 2's setup.bash\n\ncolcon build --symlink-install --cmake-args -DBUILD_TESTING=OFF\n</code></pre> <p> <p>Reason for building a target application with CARET/rclcpp</p> <p>CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET.   Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application.   In order to apply rclcpp which has the additional tracepoints, the application have to be built with CARET/rclcpp again.   Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as <code>demo_nodes_cpp</code>.   If you want to trace such pre-build packages, please build them again from source code.</p> <p> <p> <p>Reason for giving <code>-DBUILD_TESTING=OFF</code></p> <p>To use CARET, you need to use forked shared libraries and headers such as CARET/rclcpp.   In the test codes, CARET/rclcpp is not available due to loading priority issues for headers.   Depending on the version of CARET, conflicts may occur between the shared libraries of   ros-rclcpp and the headers of CARET/rclcpp, resulting in compile errors.   Therefore, test codes have to be excluded from building.</p> <p>"},{"location":"recording/build_check/#check-whether-caretrclcpp-is-applied-to-each-package","title":"Check whether CARET/rclcpp is applied to each package","text":"<p>You can check whether a target application is successfully built with CARET/rclcpp using <code>ros2 caret check_caret_rclcpp</code> command.</p> <pre><code>ros2 caret check_caret_rclcpp &lt;path-to-workspace&gt;\n</code></pre> Output Message Description <code>All packages are built using caret-rclcpp</code> There is no problem <code>The following packages have not been built using caret-rclcpp</code> CARET/rclcpp is not applied to the listed packages (Please read the next section to fix it)"},{"location":"recording/build_check/#how-to-fix","title":"How to fix","text":"<p>In case CARET/rclcpp is not applied to the package you want to analyze, you need to fix it. The followings show possible causes and solutions.</p> <ul> <li>Case 1: All packages are listed as CARET/rclcpp is not applied<ul> <li>Make sure you applied CARET's <code>local_setup.bash</code> after ROS 2's <code>setup.bash</code> (keep the order)</li> </ul> </li> <li>Case 2: Some, but not all, packages are listed as CARET/rclcpp is not applied<ul> <li>Make sure you have the following line in <code>package.xml</code> in the listed package<ul> <li><code>&lt;depend&gt;rclcpp&lt;/depend&gt;</code></li> </ul> </li> </ul> </li> </ul> <p> <p>Info</p> <p>The listed packages are not traced while other packages built with CARET/rclcpp are properly traced. Therefore, you can ignore this message if you don't need to trace/analyze the listed packages.</p> <p>"},{"location":"recording/cli_tool/","title":"CLI tools for recording","text":"<p>CARET provides CLI tools which can be utilized at recording process.</p> <p> <p>Info</p> <p>CARET environment settings need to be performed to use these CLI tools by the following commands.</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n</code></pre> <p>"},{"location":"recording/cli_tool/#build-results-validation","title":"Build results validation","text":"<p>This command checks whether a target application is successfully built with CARET/rclcpp. (See details)</p> <pre><code>ros2 caret check_caret_rclcpp &lt;path-to-workspace&gt;\n</code></pre> <pre><code>---Output text as below---\n\nINFO    : 2022-09-29 20:18:43 | All packages are built using caret-rclcpp.\n</code></pre>"},{"location":"recording/cli_tool/#recording","title":"Recording","text":"<p>This command starts a LTTng session and recording sequence. (See details)</p> <p>Recording begins after <code>All process started recording</code> is displayed.</p> <pre><code>ros2 caret record --session-name &lt;session_name&gt; --recording-frequency &lt;recording_frequency&gt; --verbose\n</code></pre> <p>Increasing value of <code>&lt;recording_frequency&gt;</code> reduces time required to start recording. However, if large value is given to <code>&lt;recording_frequency&gt;</code>, recording is more likely to cause <code>Tracer discarded</code>. <code>-f</code> is the short option for <code>--recording-frequency</code> [TODO] Add a link to the design page as a reference for details.</p> <p>With the <code>--verbose</code> option, you can check status for recording sequence in detail. <code>-v</code> is the short option for <code>--verbose</code></p>"},{"location":"recording/cli_tool/#trace-data-validation","title":"Trace data validation","text":"<p>This command checks whether a recording is successful. (See details)</p> <p>If there are problems with the recorded data, warning messages will be displayed</p> <pre><code>ros2 caret check_ctf &lt;path-to-trace-data&gt;\n</code></pre>"},{"location":"recording/cli_tool/#node-summary","title":"Node summary","text":"<p>This command displays the number of events per node.</p> <pre><code>ros2 caret node_summary &lt;path-to-trace-data&gt;\n</code></pre> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\n=============================================\n\nnode_name            |   number_of_trace_points\n----------------------+--------------------------\n /message_driven_node |                     4207\n/timer_driven_node   |                     3630\n/filter_node         |                     2680\n/drive_node          |                     2146\n/sensor_dummy_node   |                     2144\n/actuator_dummy_node |                     1609\n</code></pre>"},{"location":"recording/cli_tool/#topic-summary","title":"Topic summary","text":"<p>This command displays the number of events per topic.</p> <pre><code>ros2 caret topic_summary &lt;path-to-trace-data&gt;\n</code></pre> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\n=============================================\n\ntopic_name        |   number_of_trace_points\n-------------------+--------------------------\n /drive            |                     2668\n/topic1           |                     2668\n/topic2           |                     2668\n/topic4           |                     2658\n/topic3           |                     2478\n/parameter_events |                       66\n/rosout           |                        6\n</code></pre> <p> <p>Info</p> <p>If the number of events is too huge to handle, trace filtering is a reasonable choice to exclude unnecessary nodes/topics based on the output result.</p> <p>"},{"location":"recording/cli_tool/#tracepoint-summary","title":"Tracepoint summary","text":"<p>This command displays all tracepoints included in the trace data and the number of events collected by tracepoints.</p> <pre><code>ros2 caret trace_point_summary &lt;path-to-trace-data&gt;\n</code></pre> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\n=============================================\n\ntrace_point                                       |   number_of_trace_points\n---------------------------------------------------+--------------------------\n ros2:callback_end                                 |                     4216\nros2:callback_start                               |                     4216\nros2_caret:dds_write                              |                     2790\nros2_caret:dds_bind_addr_to_stamp                 |                     2790\nros2:rcl_publish                                  |                     2650\nros2:rclcpp_publish                               |                     2650\nros2:dispatch_subscription_callback               |                     2620\nros2:rclcpp_subscription_callback_added           |                       44\nros2:rclcpp_service_callback_added                |                       44\nros2:rclcpp_callback_register                     |                       44\nros2:rclcpp_timer_callback_added                  |                       44\nros2_caret:callback_group_add_service             |                       36\nros2:rcl_service_init                             |                       36\nros2:rcl_publisher_init                           |                       17\nros2_caret:callback_group_add_subscription        |                       11\nros2:rcl_node_init                                |                        6\nros2_caret:add_callback_group                     |                        6\nros2:rcl_subscription_init                        |                        5\nros2:rclcpp_subscription_init                     |                        5\nros2:rcl_timer_init                               |                        3\nros2:rclcpp_timer_link_node                       |                        3\nros2_caret:callback_group_add_timer               |                        3\nros2_caret:construct_executor                     |                        1\nros2_caret:rmw_implementation                     |                        1\nros2:rcl_init                                     |                        1\nros2:rcl_client_init                              |                        0\nros2:dispatch_intra_process_subscription_callback |                        0\nros2_caret:tilde_subscribe_added                  |                        0\nros2_caret:tilde_subscribe                        |                        0\nros2_caret:tilde_publisher_init                   |                        0\nros2_caret:tilde_publish                          |                        0\nros2_caret:sim_time                               |                        0\nros2_caret:on_data_available                      |                        0\nros2:message_construct                            |                        0\nros2_caret:dds_bind_addr_to_addr                  |                        0\nros2_caret:construct_static_executor              |                        0\nros2:rclcpp_intra_publish                         |                        0\nros2:rcl_lifecycle_transition                     |                        0\nros2:rcl_lifecycle_state_machine_init             |                        0\nros2_caret:callback_group_add_client              |                        0\nros2_caret:add_callback_group_static_executor     |                        0\nros2_caret:tilde_subscription_init                |                        0\n</code></pre>"},{"location":"recording/cli_tool/#filtering-for-summary-commands","title":"Filtering for summary commands","text":"<p>Executing a summary command for huge trace data (e.g., more than 10 minutes) takes time. The following two options allow you to filter the load range of trace data used for summary output. In both options, the argument type is float and the unit of time is second.</p> <pre><code>ros2 caret trace_point_summary &lt;path-to-trace-data&gt; --duration_filter &lt;DURATION&gt; &lt;OFFSET&gt;\nros2 caret trace_point_summary &lt;path-to-trace-data&gt; --strip_filter &lt;LSTRIP&gt; &lt;RSTRIP&gt;\n</code></pre> <ul> <li><code>--duration_filter [DURATION] [OFFSET]</code><ul> <li>Load only this [DURATION] from [OFFSET].</li> </ul> </li> <li><code>--strip_filter [LSTRIP] [RSTRIP]</code><ul> <li>Ignore trace data for specified seconds from start/end.</li> </ul> </li> </ul> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\nFiltered trace range    | 17:34:15 ~ 17:34:45\nFiltered trace duration | 0:00:29\n=============================================\n\ntrace_point                                       |   number_of_trace_points\n---------------------------------------------------+--------------------------\n ros2:callback_end                                 |                     2385\nros2:callback_start                               |                     2385\nros2:dispatch_subscription_callback               |                     1485\nros2:rcl_publish                                  |                     1484\nros2_caret:dds_write                              |                     1484\nros2_caret:dds_bind_addr_to_stamp                 |                     1484\nros2:rclcpp_publish                               |                     1484\nros2:rclcpp_subscription_callback_added           |                       44\nros2:rclcpp_service_callback_added                |                       44\nros2:rclcpp_callback_register                     |                       44\nros2:rclcpp_timer_callback_added                  |                       44\nros2_caret:callback_group_add_service             |                       36\nros2:rcl_service_init                             |                       36\nros2:rcl_publisher_init                           |                       17\nros2_caret:callback_group_add_subscription        |                       11\nros2:rcl_node_init                                |                        6\nros2_caret:add_callback_group                     |                        6\nros2:rcl_subscription_init                        |                        5\nros2:rclcpp_subscription_init                     |                        5\nros2:rcl_timer_init                               |                        3\nros2:rclcpp_timer_link_node                       |                        3\nros2_caret:callback_group_add_timer               |                        3\nros2_caret:construct_executor                     |                        1\nros2_caret:rmw_implementation                     |                        1\nros2:rcl_init                                     |                        1\nros2:rcl_client_init                              |                        0\nros2:dispatch_intra_process_subscription_callback |                        0\nros2_caret:tilde_subscribe_added                  |                        0\nros2_caret:tilde_subscribe                        |                        0\nros2_caret:tilde_publisher_init                   |                        0\nros2_caret:tilde_publish                          |                        0\nros2_caret:sim_time                               |                        0\nros2_caret:on_data_available                      |                        0\nros2:message_construct                            |                        0\nros2_caret:dds_bind_addr_to_addr                  |                        0\nros2_caret:construct_static_executor              |                        0\nros2:rclcpp_intra_publish                         |                        0\nros2:rcl_lifecycle_transition                     |                        0\nros2:rcl_lifecycle_state_machine_init             |                        0\nros2_caret:callback_group_add_client              |                        0\nros2_caret:add_callback_group_static_executor     |                        0\nros2_caret:tilde_subscription_init                |                        0\n</code></pre>"},{"location":"recording/recording/","title":"Recording","text":""},{"location":"recording/recording/#recording-with-caret","title":"Recording with CARET","text":"<p>CARET uses LTTng for tracing a target application. This page explains two different ways for tracing: Starting LTTng session manually and Starting LTTng session using ROS launch system.</p> <p>Explanation in this page assumes CARET is installed to <code>~/ros2_caret_ws</code> and the sample application used in the tutorial section is located in <code>~/ros2_ws</code>.</p>"},{"location":"recording/recording/#starting-lttng-session-manually","title":"Starting LTTng session manually","text":"<p>Two terminals are needed for this method; one for executing a target application, another for starting a LTTng session.</p> <ol> <li> <p>Open a terminal and launch a target application</p> <ul> <li> <p>Perform environment settings in the same order as below. CARET's <code>local_setup.bash</code> should be applied along with ROS 2's <code>setup.bash</code> as the target application refers to CARET/rclcpp</p> <pre><code># Environment settings (keep the order as below)\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n</code></pre> </li> </ul> <ul> <li> <p>Set <code>LD_PRELOAD</code> to enable tracepoints provided by function hook</p> <pre><code>export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n</code></pre> </li> </ul> <ul> <li> <p>(Optional) Apply trace filtering. With configuration of trace filtering, CARET can ignore unnecessary nodes/topics. This function is useful for a large application</p> <pre><code># Apply filter directly\nexport CARET_IGNORE_NODES=\"/rviz*\"\nexport CARET_IGNORE_TOPICS=\"/clock:/parameter_events\"\n\n# Apply filter using a setting file\nsource ./caret_topic_filter.bash\n</code></pre> </li> </ul> <ul> <li> <p>Launch the target application</p> <pre><code>ros2 run caret_demos end_to_end_sample\n</code></pre> </li> </ul> </li> <li> <p>Open another terminal and start a LTTng session with the following commands</p> <ul> <li>Trace data will be stored into the directory whose path is defined as <code>{ROS_TRACE_DIR}/{SESSION_NAME}</code>.<ul> <li><code>ROS_TRACE_DIR</code> is an environmental variable whose default value is <code>~/.ros/tracing</code>     (Optional) You can set <code>ROS_TRACE_DIR</code> environment variable to change a destination directory where recorded trace data will be stored</li> <li><code>SESSION_NAME</code> means a session name given with <code>-s</code> option for <code>ros2 caret record</code> command</li> </ul> </li> <li>Press \"Enter\" key to start a session</li> </ul> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\n# (Optional) Set a destination directory\nmkdir -p ~/ros2_ws/evaluate\nexport ROS_TRACE_DIR=~/ros2_ws/evaluate\n\nros2 caret record -s e2e_sample\n\n# Start session with pressing Enter key\n</code></pre> </li> <li> <p>Press \"Enter\" key to stop the LTTng session in the terminal where the LTTng session runs</p> </li> <li> <p>Stop the target application</p> </li> </ol> <p> <p>Info</p> <p>If you'd like to start measurement immediately after launch, reverse Step 1 and Step 2.   You can start a Lttng session first before executing a target application as well.   However, if recording is started during launch of a target application, it may cause missing recordings.   Please start recording either before launch is started or after launch is completed.</p> <p> <p> <p>Info</p> <p>You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with <code>ulimit -n</code> command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; <code>ulimit -n 65536</code>.</p> <p>"},{"location":"recording/recording/#starting-lttng-session-via-ros-launch","title":"Starting LTTng session via ROS launch","text":"<p>You can start LTTng session using ROS launch system. When you have started a target application in one terminal, you have to open another terminal for starting a LTTng session as explained above. Operating multiple terminals is laborious for users. Starting LTTng session along with application by ROS launch is a reasonable way to apply CARET repeatedly.</p> <ol> <li> <p>Create a launch file for a target application in ROS general manner if you haven't made it</p> <pre><code># launch/end_to_end_sample.launch.py\nimport launch\nimport launch_ros.actions\n\n\ndef generate_launch_description():\n    return launch.LaunchDescription([\n        launch_ros.actions.Node(\n            package='caret_demos', executable='end_to_end_sample', output='screen'),\n    ])\n</code></pre> </li> <li> <p>Add description to start a LTTng session</p> <pre><code># launch/end_to_end_sample_with_lttng_session.launch.py\nimport launch\nimport launch_ros.actions\nfrom tracetools_launch.action import Trace\n\n\ndef generate_launch_description():\n    return launch.LaunchDescription([\n        Trace(\n            session_name='e2e_sample',\n            events_kernel=[],\n            events_ust=['ros2*']\n        ),\n        launch_ros.actions.Node(\n            package='caret_demos', executable='end_to_end_sample', output='screen'),\n    ])\n</code></pre> </li> <li> <p>Launch a target application and a LTTng session via the launch file</p> <ul> <li>Environment settings are still needed, but all operations are performed in just one terminal</li> </ul> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n\nexport LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\nsource ./caret_topic_filter.bash\n\nros2 launch caret_demos end_to_end_sample_with_lttng_session.launch.py\n</code></pre> </li> </ol>"},{"location":"recording/recording/#advanced-useful-settings-for-launch-file","title":"Advanced: Useful settings for launch file","text":"<ul> <li>The following script shows advanced settings for a launch file</li> <li><code>caret_session</code> option is used to set a session name. If not assigned, datetime (YYYYMMDD-HHMMSS) is used</li> <li><code>caret_light</code> option is used to add another event filter. Only events specified in <code>caret_event</code> variable are recorded. In this example, high level events, such as ros2:rclcpp layer, are recorded if <code>caret_light</code> is set to \"true\". This setting will be helpful to record a huge application.<ul> <li>Please refer to tracepoint summary to find which events are recorded, and modify <code>caret_event</code> as you want.</li> </ul> </li> </ul> <pre><code># launch/end_to_end_sample_with_lttng_session.launch.py\nimport launch\nimport launch_ros.actions\nfrom tracetools_launch.action import Trace\n\nimport sys\nimport datetime\nfrom distutils.util import strtobool\n\n\ndef generate_launch_description():\n  caret_session = \"\"\n  caret_event = [\"ros2*\"]\n  caret_light = True\n\n  for arg in sys.argv:\n    if arg.startswith(\"caret_session:=\"):\n      caret_session = arg.split(\":=\")[1]\n    elif arg.startswith(\"caret_light:=\"):\n      try:\n        caret_light = strtobool(arg.split(\":=\")[1]) # 0 or 1\n      except:\n        print(\"Invalid arguments 'caret_light'.\")\n        print(\"Start tracing with 'ros2*'.\")\n\n  if caret_light:\n    caret_event = [\n            \"ros2:*callback*\",\n            \"ros2_caret:*callback*\",\n            \"ros2:dispatch*\",\n            \"ros2_caret:dispatch*\",\n            \"ros2:rclcpp*\" ,\n            \"ros2_caret:rclcpp*\" ,\n            \"ros2_caret:rmw*\",\n            \"ros2:rmw_take\",\n            \"*callback_group*\",\n            \"ros2_caret:*executor\",\n            \"ros2_caret:dds_bind*\",\n            \"ros2:rcl_*init\",\n            \"ros2_caret:rcl_*init\",\n            \"ros2_caret:caret_init\"]\n\n  if caret_session == \"\":\n    dt_now = datetime.datetime.now()\n    caret_session = \"autoware_launch_trace_\" + dt_now.strftime(\"%Y%m%d-%H%M%S\")\n\n  return launch.LaunchDescription([\n    Trace(\n      session_name=caret_session,\n      events_kernel=[],\n      events_ust=caret_event\n    ),\n    launch_ros.actions.Node(\n        package='caret_demos', executable='end_to_end_sample', output='screen'),\n  ])\n</code></pre>"},{"location":"recording/sim_time/","title":"ROS time (sim_time) support","text":""},{"location":"recording/sim_time/#introduction","title":"Introduction","text":"<p>CARET uses system time to analyze trace data by default. It may be inconvenient, especially when treating trace data recorded with rosbag. These are examples:</p> <ul> <li>The flow of time in analysis results (e.g., time series graph) is different from that of ROS when playing rosbag with <code>[-r RATE]</code> option. For instance, 10 Hz becomes 2 Hz when rosbag was played with <code>[-r 0.2]</code> but analysis uses system time</li> <li>Time becomes different at every recording even if you use the same rosbag file, which makes comparing experimental results difficult</li> </ul> <p>This page explains how to use sim_time.</p>"},{"location":"recording/sim_time/#recording-clock-topic","title":"Recording <code>/clock</code> topic","text":"<p><code>/clock</code> topic needs to be recorded in trace data. <code>/clock</code> topis is recorded as <code>ros2_caret:sim_time</code> event in trace data.</p> <p>Add the <code>--record-clock</code> option to the <code>ros2 caret record</code> command.</p> <p> <p>Info</p> <p>Remember to set <code>use_sim_time=true</code> for each node when launching a target application   Remember to add <code>--clock</code> option when playing rosbag</p> <p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\nros2 caret record --record-clock\n</code></pre> <p>You can check whether <code>/clock</code> is successfully recorded by the following command.</p> <pre><code>babeltrace &lt;path-to-trace-data&gt; | cut -d' ' -f 4 | sort -u | grep sim_time\n</code></pre> <pre><code>---Expected output text as below---\n\nros2_caret:sim_time:\n</code></pre>"},{"location":"recording/sim_time/#visualization-using-sim_time","title":"Visualization using sim_time","text":"<p>By setting <code>xaxis_type='sim_time'</code>, sim_time is used instead of system time for the following APIs in Plot object.</p> <pre><code>def to_dataframe(\n   self,\n   xaxis_type: str\n) -&gt; pd.DataFrame:\n\ndef figure(\n   self,\n   xaxis_type: Optional[str],\n   ywheel_zoom: Optional[bool],\n   full_legends: Optional[bool]\n) -&gt; Figure:\n\ndef show(\n    self,\n    xaxis_type: str = 'system_time',\n    ywheel_zoom: bool = True,\n    full_legends: bool = False,\n) -&gt; None:\n\ndef save(\n    self,\n    export_path: str,\n    title: str = '',\n    xaxis_type: Optional[str] = None,\n    ywheel_zoom: Optional[bool] = None,\n    full_legends: Optional[bool] = None\n) -&gt; None:\n</code></pre> <p>In case <code>/clock</code> topic is not recorded in trace data, the following error will occur.</p> <pre><code>InvalidArgumentError: Failed to load sim_time. Please measure again with clock_recorder running.\n</code></pre>"},{"location":"recording/sim_time/#sample-to-use-sim_time","title":"Sample to use sim_time","text":"<p>Explanation below assumes CARET is installed to <code>~/ros2_caret_ws</code> and the sample application used in the tutorial section is located in <code>~/ros2_ws</code>.</p>"},{"location":"recording/sim_time/#record-rosbag","title":"Record rosbag","text":"<p>The following steps can be performed either with or without CARET. If you have built a target application without CARET, you don't need to set environment for CARET and LD_PRELOAD.</p> <ol> <li> <p>Open a terminal to run a target application to record rosbag</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\nexport LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\nros2 run caret_demos end_to_end_sample\n</code></pre> </li> <li> <p>Open another terminal to record rosbag</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n\nros2 bag record /topic1 /drive\n</code></pre> <p>Here, <code>/topic1</code> and <code>/drive</code> are source topics of the sample application.  You can check if rosbag is successfully recorded.</p> <pre><code>ros2 bag info rosbag2_2022_09_30-10_57_06\n\nFiles:             rosbag2_2022_09_30-10_57_06_0.db3\nBag size:          29.3 KiB\nStorage id:        sqlite3\nDuration:          9.601s\nStart:             Sep 30 2022 10:57:08.952 (1664503028.952)\nEnd:               Sep 30 2022 10:57:18.554 (1664503038.554)\nMessages:          194\nTopic information: Topic: /drive | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr\n                Topic: /topic1 | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr\n</code></pre> </li> </ol>"},{"location":"recording/sim_time/#record-trace-data","title":"Record trace data","text":"<ol> <li> <p>Open terminal to run a target application to record trace data with CARET</p> <p>In the launch file, <code>use_sim_time</code> is set to true and source nodes are disabled.</p> <pre><code> source /opt/ros/humble/setup.bash\n source ~/ros2_caret_ws/install/local_setup.bash\n source ~/ros2_ws/install/local_setup.bash\n export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\nros2 launch caret_demos end_to_end_sample.launch.py use_sim_time:=true use_rosbag:=true\n</code></pre> </li> <li> <p>Open another terminal to record the performance data with <code>/clock</code> topic.</p> <pre><code> source /opt/ros/humble/setup.bash\n source ~/ros2_caret_ws/install/local_setup.bash\n source ~/ros2_ws/install/local_setup.bash\n\n ros2 caret record -s e2e_sample --record-clock\n</code></pre> </li> <li> <p>Open another terminal to play the rosbag</p> <pre><code> source /opt/ros/humble/setup.bash\n source ~/ros2_caret_ws/install/local_setup.bash\n source ~/ros2_ws/install/local_setup.bash\n\n ros2 bag play rosbag2_2022_09_30-10_57_06 --clock -r 0.2\n</code></pre> </li> <li> <p>Stop the application and the rosbag</p> </li> <li> <p>Check if <code>/clock</code> topic is recorded in trace data as <code>sim_time</code></p> <pre><code>babeltrace ~/ros2_ws/evaluate/e2e_sample | cut -d' ' -f 4 | sort -u | grep sim_time\nros2_caret:sim_time:\n</code></pre> </li> </ol>"},{"location":"recording/sim_time/#visualize-results-using-sim_time","title":"Visualize results using sim_time","text":"<ol> <li>Launch Jupyter Notebook in <code>~/ros2_ws/evaluate</code> and run the following scripts<ul> <li>Reference: the tutorial</li> </ul> </li> </ol> <pre><code>from bokeh.plotting import output_notebook\noutput_notebook()\nfrom caret_analyze import Architecture, Application, Lttng\nfrom caret_analyze.plot import Plot, message_flow\n\n# Read trace data\narch = Architecture('lttng', './e2e_sample')\nlttng = Lttng('./e2e_sample')\n\n# Search and add path\npaths = arch.search_paths(\n    '/filter_node',\n    '/message_driven_node')\narch.add_path('target_path', paths[0])\napp = Application(arch, lttng)\n\n# Draw message_flow\npath = app.get_path('target_path')\nplot = Plot.create_message_flow_plot(path)\nplot.show(xaxis_type='sim_time')\n\n# Draw node info\nnode = app.get_node('/filter_node')\nplot = Plot.create_period_timeseries_plot(node.callbacks)\nplot.show(xaxis_type='sim_time')\n</code></pre>"},{"location":"recording/trace_filtering/","title":"Trace filtering","text":""},{"location":"recording/trace_filtering/#trace-filtering_1","title":"Trace filtering","text":"<p>CARET provides a trace filtering function to exclude specific nodes and topics. Trace data may be discarded when recording a large application like Autoware due to too many data to be recorded, and a warning will occur when validating/analyzing the recorded trace data (See validating). By applying trace filter, unconcerned events like <code>/tf</code> are ignored and the size of recorded data decreases.</p>"},{"location":"recording/trace_filtering/#trace-filter-configuration","title":"Trace filter configuration","text":"<ul> <li>Trace filter configuration is performed by setting the following environment variables<ul> <li><code>CARET_SELECT_NODES</code> : node names to be recorded</li> <li><code>CARET_IGNORE_NODES</code> : node names to be ignored</li> <li><code>CARET_SELECT_TOPICS</code> : topic names to be recorded</li> <li><code>CARET_IGNORE_TOPICS</code> : topic names to be ignored</li> </ul> </li> <li>\"SELECT\" settings override \"IGNORE\" settings if both are used</li> <li>Colon \"<code>:</code>\" is used to set more than one nodes/topics</li> <li>Regular expressions are supported</li> <li>These variables need to be set in the same terminal as a target application running</li> <li>In most cases, nodes related to <code>/rviz</code>, <code>/clock</code> topic and <code>/parameter_events</code> topic are unnecessary to analyze an application. It's recommended to ignore these nodes/topics</li> </ul> <p>The following shows sample settings</p> <pre><code>export CARET_IGNORE_NODES=\"/rviz*\"\nexport CARET_IGNORE_TOPICS=\"/clock:/parameter_events\"\n</code></pre>"},{"location":"recording/trace_filtering/#trace-filter-setting-file","title":"Trace filter setting file","text":"<p>It will be handy to prepare a trace filter setting file like the following.</p> <pre><code># caret_topic_filter.bash\n#!/bin/bash\n\nexport CARET_IGNORE_NODES=\\\n\"\\\n/rviz*:\\\n/caret_trace_*:\\\n\"\n\nexport CARET_IGNORE_TOPICS=\\\n\"\\\n/clock:\\\n/parameter_events:\\\n\"\n\n# if you want to select nodes or topics,\n# please remove comment out of the followings.\n# export CARET_SELECT_NODES=\\\n# \"\\\n# /rviz*:\\\n# /caret_trace_*:\\\n# \"\n\n# export CARET_SELECT_TOPICS=\\\n# \"\\\n# /clock:\\\n# /parameter_events:\\\n# \"\n</code></pre>"},{"location":"recording/validating/","title":"Validating trace data","text":""},{"location":"recording/validating/#validating-trace-data_1","title":"Validating trace data","text":"<p>You can check whether a recording is successful with <code>ros2 caret check_ctf</code> command.</p> <pre><code>ros2 caret check_ctf &lt;path-to-trace-data&gt;\n</code></pre> <p> <p>Info</p> <p>Executing the <code>ros2 caret check_ctf</code> command for long recorded data or recorded data of a large application takes a long time.   Therefore, it is recommended to execute the <code>ros2 caret check_ctf</code> command on a short duration of recorded data before long-time recording.   Also, It's recommended to record and validate trace data when you build a target application, so that you can modify code to avoid the following warnings.</p> <p> <p> <p>Info</p> <p>You can ignore warnings caused by Python and libraries</p> <p>"},{"location":"recording/validating/#warnings-due-to-wrong-procedure","title":"Warnings due to wrong procedure","text":""},{"location":"recording/validating/#failed-to-find-trace-point-added-by-caret-rclcpp","title":"<code>Failed to find trace point added by caret-rclcpp</code>","text":"<ul> <li>Cause<ul> <li>CARET/rclcpp is not applied when you built a target application</li> </ul> </li> <li>Solution<ul> <li>Build the application with CARET (See build section)</li> </ul> </li> </ul>"},{"location":"recording/validating/#failed-to-find-trace-point-added-by-ld_preload","title":"<code>Failed to find trace point added by LD_PRELOAD</code>","text":"<ul> <li>Cause<ul> <li>Hooked tracepoints were not found. <code>LD_PRELOAD</code> may be missed</li> </ul> </li> <li>Solution<ul> <li>Set <code>LD_PRELOAD</code> before running the application (See recording section)</li> </ul> </li> </ul>"},{"location":"recording/validating/#trace-data-from-a-package-built-without-caret-rclcpp-was-detected","title":"<code>Trace data from a package built without caret-rclcpp was detected</code>","text":"<ul> <li>Cause<ul> <li>Some packages (e.g. packages installed with apt) have been built without using caret-rclcpp.</li> </ul> </li> <li>Solution<ul> <li>Build the application with CARET (See build section)</li> <li>If you still get this warning after checking the above,   add all packages used in your application to your workspace and build using CARET.</li> </ul> </li> </ul>"},{"location":"recording/validating/#tracer-discarded","title":"<code>Tracer discarded</code>","text":"<ul> <li>Cause<ul> <li>Trace data lost occurred while recording due to too many trace data</li> <li>This warning will be observed in some case, especially when applying CARET to a large application</li> <li>Details<ul> <li>LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents. After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded.</li> </ul> </li> </ul> </li> <li>Solution<ul> <li>Apply trace filter, or modify trace filter setting to ignore more topics/nodes (See trace filtering section)<ul> <li>especially, filtering highly-frequent nodes and topics is effective</li> <li>highly-frequent nodes/topics can be identified by checking the summary of trace data</li> </ul> </li> <li>Increase size of ring-buffer in CARET if a target device has enough memory<ul> <li>example</li> </ul> </li> </ul> </li> </ul>"},{"location":"recording/validating/#warnings-due-to-caret-limitations","title":"Warnings due to CARET limitations","text":"<ul> <li>CARET identifies callback functions using the following parameters. In case a node has several callback functions whose parameters are identical, such node is ignored because CARET cannot analyze it.<ul> <li>Timer callback functions: timer period</li> <li>Subscription callback functions: topic name</li> </ul> </li> </ul>"},{"location":"recording/validating/#duplicate-parameter-callback-found","title":"<code>Duplicate parameter callback found</code>","text":"<ul> <li>Cause<ul> <li>Several timer callback functions which have the same timer period exist in a node</li> <li>In other words, <code>rclcpp::create_timer()</code> with the same timer period is called more than once</li> </ul> </li> <li>Solution (workaround)<ul> <li>Modify code to avoid using the same timer period (You can slightly change timer period value)</li> <li>Or, this warning can be ignored unless the node needs to be analyzed</li> </ul> </li> </ul>"},{"location":"recording/validating/#failed-to-identify-subscription-several-candidates-were-found","title":"<code>Failed to identify subscription. Several candidates were found</code>","text":"<ul> <li>Cause<ul> <li>Several subscription callback functions which have the same topic name exist in a node</li> <li>In other words, <code>rclcpp::create_subscription()</code> with the same topic name is called more than once</li> </ul> </li> <li>Solution (workaround)<ul> <li>Modify code to avoid creating more than one subscription callback function with the same topic name</li> </ul> </li> </ul>"},{"location":"recording/validating/#multiple-executors-using-the-same-callback-group-were-detected","title":"<code>Multiple executors using the same callback group were detected</code>","text":"<ul> <li>Cause<ul> <li>A callback group is added to several executors</li> </ul> </li> <li>Solution<ul> <li>There is no solution at the moment. CARET uses the last executor to analyze. This warning can be ignored in most cases</li> </ul> </li> </ul>"},{"location":"recording/validating/#failed-to-find-callback-group","title":"<code>Failed to find callback group</code>","text":"<ul> <li>Cause<ul> <li>CARET failed to bind callback groups, callbacks and executors. It mainly because of ROS 2 \"service\". \"Service\" is not supported by CARET</li> </ul> </li> <li>Solution<ul> <li>There is no solution at the moment. This warning can be ignored in most cases</li> </ul> </li> </ul>"},{"location":"tutorials/configuration/","title":"Configuration","text":"<p>Please download the architecture file and use it for visualization.</p> <pre><code>cd ~/ros2_ws/evaluate\nwget https://raw.githubusercontent.com/tier4/caret_demos/main/samples/end_to_end_sample/architecture.yaml\n</code></pre> <p>Configuration is an advanced topic for beginners. This section only provides the architecture file for the next section of visualization.</p> <p>Please refer to the chapter of Configuration if you are interested.</p>"},{"location":"tutorials/recording/","title":"Recording with CARET","text":"<p>This page explains usage of CARET with a sample application. The sample application is located on caret_demos repository.</p> <p>See Recording to find more details.</p>"},{"location":"tutorials/recording/#building-application-with-caret","title":"Building application with CARET","text":"<p>To trace a target application, the target should be built with CARET/rclcpp. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's <code>local_setup.bash</code> should be applied along with ROS 2's <code>setup.bash</code> as shown below.</p> <pre><code>mkdir -p ~/ros2_ws/src\ncd ~/ros2_ws\n\ngit clone https://github.com/tier4/caret_demos.git src/caret_demos\n\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash'\n\ncolcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING=OFF\n</code></pre> <p>The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables.</p> <pre><code>ros2 caret check_caret_rclcpp ~/ros2_ws/\n\n# Expected output. CARET/rclcpp is applied to all packages\nINFO    : 2022-06-12 12:26:49 | All packages are built using caret-rclcpp.\n\n# In case there are packages to which CARET/rclcpp is not applied\n# The following message will be outputted\nWARNING : 2022-06-12 12:25:26 | The following packages have not been built using caret-rclcpp:\n   demo_nodes_cpp\n   caret_demos\n   intra_process_demo\n</code></pre>"},{"location":"tutorials/recording/#tracing-the-sample-application-with-caret","title":"Tracing the sample application with CARET","text":""},{"location":"tutorials/recording/#launching-the-target-application","title":"Launching the target application","text":"<p>Run the target as shown in the following.</p> <pre><code># Environment settings (keep the order as below)\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n\n# Enable tracepoints which are defined hooked functions.\nexport LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\n# (Optional) Exclude nodes and topics which you are not concerned with\nexport CARET_IGNORE_NODES=\"/rviz*\"\nexport CARET_IGNORE_TOPICS=\"/clock:/parameter_events\"\n\n# Launch the target application, demos_end_to_end_sample\nros2 launch caret_demos end_to_end_sample.launch.py\n</code></pre>"},{"location":"tutorials/recording/#starting-recording","title":"Starting recording","text":"<p>Open a new terminal and record the performance data.</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\n# set a destination directory. ~/.ros/tracing is default.\nmkdir -p ~/ros2_ws/evaluate\nexport ROS_TRACE_DIR=~/ros2_ws/evaluate\n\nros2 caret record -s e2e_sample\n\n# Start recording with pressing Enter key\n# &gt; All process tarted recording.\n# &gt; press enter to stop...\n</code></pre>"},{"location":"tutorials/recording/#validating-recorded-data-briefly","title":"Validating recorded data briefly","text":"<p>You can check whether tracing is successful or not with <code>ros2 caret check_ctf</code> command before visualizing recorded data.</p> <pre><code>ros2 caret check_ctf ~/ros2_ws/evaluate/e2e_sample/\n\n# If there are problems with the recorded data, warning messages will be displayed.\n</code></pre>"},{"location":"tutorials/visualization/","title":"Performance visualization","text":"<p>CARET serves Python APIs to visualize trace data for users to analyze applications' performance. This section will show basic flow to visualize data with Jupyter notebook.</p>"},{"location":"tutorials/visualization/#how-to-locate-trace-data-on-jupyter-notebook","title":"How to locate trace data on Jupyter notebook","text":"<ol> <li> <p>Launching <code>jupyter-lab</code>    Launch <code>jupyter-lab</code> at first for learning how to visualize recorded data.</p> <pre><code>cd ~/ros2_ws/evaluate\n\nsource ~/ros2_caret_ws/install/setup.bash\njupyter-lab\n</code></pre> <p>CARET uses <code>bokeh</code> for some visualization APIs.  Execute the following code for loading <code>bokeh</code></p> <pre><code>from bokeh.plotting import output_notebook\noutput_notebook()\n</code></pre> </li> <li> <p>Loading trace data onto Jupyter notebook</p> <p>Locate trace data on Jupyter notebook as well as the architecture file.</p> <pre><code>from caret_analyze import Architecture, Application, Lttng\n\n# load the architecture file which is created in the previous page\narch = Architecture('yaml', './architecture.yaml')\n\n# load recorded data by CARET\nlttng = Lttng('./e2e_sample')\n\n# map the application architecture to recorded data\napp = Application(arch, lttng)\n</code></pre> <p>After execution of the code, users will often refer to the <code>app</code> object defined as <code>Application</code> class. The <code>app</code> objects provides users latency of callbacks, communication, and paths. <code>Application</code> class is similar to <code>Architecture</code> class which describes structure of the application and their interfaces are similar. In addition, <code>Application</code> class has interfaces to get latency.</p> </li> </ol>"},{"location":"tutorials/visualization/#basic-api-to-get-latency","title":"Basic API to get latency","text":"<p>This section will explain APIs to get callback latency. The following code is one of examples to get callback latency.</p> <pre><code># Get a callback instance, which has latency information, from app\ncallback = app.get_callback('/timer_driven_node/callback_0')\n\n# Get time-series variation of latency\nt, latency_ns = callback.to_timeseries()\n\n# Get histogram of latency\nbins, latency_ns = callback.to_histogram()\n</code></pre> <p>Though this example shows callback latency, CARET serves API to get communication latency. <code>callback.to_dataframe()</code> will provides <code>pandas.DataFrame</code> based object including raw timestamps which is obtained from tracepoints.</p> <p> <p>Todo<p>Sorry for not providing CARET's API list, but we'll provide it in the near future.</p> </p> <p>"},{"location":"tutorials/visualization/#visualizing-latency-of-node-chain-with-message-flow","title":"Visualizing latency of node chain with message flow","text":"<p>CARET provides some APIs to visualize measured data. With message flow, which is one of effective visualizations, users can understand what happens and where is bottleneck in target applications. Execute the following code for visualization with message flow.</p> <pre><code>from caret_analyze.plot import Plot\n\ntarget_path = app.get_path('target')\nplot = Plot.create_message_flow_plot(target_path)\nplot.show()\n</code></pre> <p>The following figure will appear if <code>show</code> method is successful.</p> <p></p> <p>The horizontal axis shows time line. On the other hand, the vertical axis shows elements of the node chain (<code>target</code>), which include callback functions and topic messages from input to output. Each colorful line shows how a certain input message is propagated to callback functions and topic communications. Gray rectangles show execution timing of callback functions.</p> <p>If your mouse pointer is put over one of gray rectangles, latency of callback functions will be shown. You can find latency of a target node chain as well if you put the mouse pointer onto one of colorful lines.</p> <p>CARET serves other APIs for visualization. Refer to visualization for more details.</p>"},{"location":"visualization/","title":"Overview","text":"<p>This chapter explains how to visualize trace data as you expect. Gallery section shows which type of visualization is supported by CARET. CARET serves uniform visualization API to create such graphs.</p>"},{"location":"visualization/#uniform-api-design","title":"Uniform API design","text":"<p>CARET serves <code>Plot</code> class to visualize trace data. The following sample code shows the basic usage of <code>Plot</code>.</p> <pre><code>from caret_analyze import Application, Architecture, Lttng\nfrom caret_analyze.plot import Plot\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\n# Load recorded data\nlttng = Lttng('/path/to/trace_data')\n# Load an Architecture object\narch = Architecture('yaml', '/path/to/architecture_file')\n# Map the architecture object to the recorded data\napp = Application(arch, lttng)\n\n# Focus on a target callback\ncallback = app.get_callback('/target/callback/name')\n\n# Get plot object for visualizing callback frequency\n# Plot.create_[Metrics]_[GraphType]_plot(data)\n# is format to get a target data set to visualize\nplot = Plot.create_frequency_timeseries_plot(callback)\n\n# Assign a table to callback_df object\ncallback_df = plot.to_dataframe()\n\n# Create a graph for frequency of callback execution\nplot.show()\n</code></pre> <p><code>plot</code> object is obtained from <code>Plot.create_[Metrics]_[GraphType]_plot(data)</code>. The argument of <code>data</code> is, for example, a <code>CallbackBase</code>-based object or a <code>Communication</code>-based object. A list of <code>CallbackBase</code> or <code>Communication</code> is also acceptable as explained later. Any of performance metrics such as <code>latency</code>, <code>frequency</code>, or <code>period</code> is given as <code>Metrics</code>. <code>GraphType</code> is served to select a graph type such as time-series or histogram.</p> <p><code>plot</code> object has following four method; <code>to_dataframe()</code>, <code>show()</code>, <code>save()</code>, and <code>figure()</code>.</p> <ul> <li><code>to_dataframe()</code> method returns a table including time-series data on a given metrics. If you want to create another type of graph manually, you will get the table by <code>to_dataframe()</code> method and convert it into the expected graph.</li> <li><code>show()</code> method creates a figure of time-series graph. In other words, <code>show()</code> method visualizes the time-series data.</li> <li><code>save()</code> method saves the figure in an arbitrary path.</li> <li><code>figure()</code> method returns the corresponding figure handler. This method allows additional customization of the figure before it is displayed.</li> </ul>"},{"location":"visualization/#visualization-api","title":"Visualization API","text":"<p>This section lists methods to visualize several metrics. You will find a sample figure corresponding to metrics if you access the link. Some of methods are not designed according to uniform API design, and they are exception.</p>"},{"location":"visualization/#callback","title":"Callback","text":"<ul> <li><code>create_frequency_timeseries_plot(callbacks: Collection[CallbackBase])</code></li> <li><code>create_period_timeseries_plot(callbacks: Collection[CallbackBase])</code></li> <li><code>create_latency_timeseries_plot(callbacks: Collection[CallbackBase])</code></li> <li><code>create_callback_scheduling_plot</code><ul> <li>Visualize callback scheduling</li> </ul> </li> </ul>"},{"location":"visualization/#communication","title":"Communication","text":"<ul> <li><code>create_frequency_timeseries_plot(communications: Collection[Communication])</code></li> <li><code>create_period_timeseries_plot(data: [Communication])</code></li> <li><code>create_latency_timeseries_plot(data: [Communication])</code></li> </ul> <p>Here, CARET takes into account communication when both transmission and reception on a message are performed successfully without being lost. See Premise of communication for more details. Feel free to skip this page if you are not interested in.</p>"},{"location":"visualization/#path","title":"Path","text":"<ul> <li><code>create_message_flow_plot</code><ul> <li>Visualize message flow of a target path</li> </ul> </li> <li><code>create_response_time_histogram_plot</code></li> <li><code>chain_latency</code></li> </ul>"},{"location":"visualization/#helper-apis","title":"Helper APIs","text":"<p>CARET provides some APIs which can help users to focus on their respective interest.</p> <ul> <li><code>LTTngEventFilter()</code></li> <li>Wildcards for <code>get_callbacks()</code></li> </ul> <p> <p>Info</p> <p>CARET analyze API document describes the parameters and returns of APIs.</p> <p>"},{"location":"visualization/premise_of_communication/","title":"Premise of communication","text":""},{"location":"visualization/premise_of_communication/#1-to-1-communication","title":"1-to-1 communication","text":"<p> <p>Info</p> <p>This premise section may be boring for some users. If you don't have much time, please feel free to skip the section.</p> <p> <p>In ROS 2, nodes communicate each other via topic messages. The topic messages are transmitted by publishers and received by subscriptions. The following figure shows the simplest example where one node sends topic message and the other node receives it.</p> <p></p> <p>CARET serves <code>Communication</code> class which focus on a topic message from a source node to a destination node. A <code>Communication</code>-based object is retrieved from method, <code>Application.get_communication('source node', 'destination node', '/topic/message')</code>. A <code>Communication</code> object has a collection of timestamps which are obtained when both publish and subscription on a target message are performed successfully. <code>Communication</code> class is explained in the page.</p> <p>Topic messages have possibility to be lost in communication path as they are transmitted and received by UDP. A <code>Communication</code> object ignores loss of topic messages. If you want to check loss of topic messages, it is reasonable to compare the number of publish and that of subscription. CARET serves both <code>Publish</code> and <code>Subscription</code> class. A <code>Publish</code> object has a collection of timestamp obtained when publish is invoked. A <code>Subscription</code> object have timestamps of invocation of subscription callback.</p>"},{"location":"visualization/premise_of_communication/#many-to-many-communication","title":"Many-to-many communication","text":"<p>ROS 2 allows topic messages to be published from multiple nodes and to be received by multiple nodes. Topic messages who share a same topic are transmitted and received among many nodes as the following figure shows.</p> <p></p> <p>If you want to investigate performance of many-to-many communication, you should select a pair of publish and subscription because CARET divides them into 1-to-1 communication and select a set of 1-to-1 communications. You will execute <code>Application.get_communication()</code> per target communication.</p>"},{"location":"visualization/premise_of_communication/#constraints-for-many-to-1-communication","title":"Constraints for Many-to-1 communication","text":"<p>CARET requires users to take care of Many-to-1 communication. Many-to-1 communication means that topic messages are published from multiple nodes and received by a single node as the following figure shows.</p> <p></p> <p>In this case, invocation frequency of publish on the source node is different from that of subscription on the destination node. The destination In this case, invocation frequency of publish on the source node is different from that of subscription on the destination node. The destination node receives topic messages from 2 other nodes. It is expected that sum of publish frequency on three nodes is equaled to that of subscription.node receives topic messages from 2 other nodes. It is expected that sum of publish frequency on three nodes is equaled to that of subscription.</p> <p>If you see that publish frequency is different from subscription frequency, you may think loss of topic messages. However, it is reasonable when many-to-1 communication is performed.</p>"},{"location":"visualization/filter/lttng_event_filter/","title":"LTTngEventFilter","text":"<p>CARET is able to analyze data recorded for several minutes. When analyzing large data with CARET, both memory and time consumed for analysis will be critical issue.</p> <p>In order not to load unnecessary data, CARET has <code>LTTngEventFilter</code> to exclude selected data from loading data.</p> <p><code>LTTngEventFilter</code> has the following methods.</p> <ul> <li><code>init_pass_filter</code></li> <li><code>duration_filter</code></li> <li><code>strip_filter</code></li> </ul>"},{"location":"visualization/filter/lttng_event_filter/#init_pass_filter","title":"<code>init_pass_filter</code>","text":"<p>With <code>init_pass_filter</code> method, events recorded by runtime tracepoints are not loaded onto memory.</p> <pre><code>LttngEventFilter.init_pass_filter()\n</code></pre>"},{"location":"visualization/filter/lttng_event_filter/#duration_filter","title":"<code>duration_filter</code>","text":"<p>With <code>duration_filter</code> method, you can crop data with targeting time range of recorded data.</p> <pre><code>LttngEventFilter.duration_filter(duration_s: float, offset_s: float)\n</code></pre> <p><code>duration_filter</code> method has following two arguments.</p> <ul> <li><code>duration_s</code> is duration of target time range</li> <li><code>offset_s</code> is point of target time range</li> </ul>"},{"location":"visualization/filter/lttng_event_filter/#strip_filter","title":"<code>strip_filter</code>","text":"<p>With <code>strip_filter</code> method, you can crop data with targeting time range of recorded data as well as <code>duration_filter</code>. <code>strip_filter</code> has different arguments from <code>duration_filter</code>.</p> <pre><code>LttngEventFilter.strip_filter(lsplit_s: Optional[float], rsplit_s: Optional[float])\n</code></pre> <p><code>strip_filter</code> method has following two optional arguments. If you omit either or both of them, default value '0' is given to the optional argument.</p> <ul> <li><code>lstrip_s</code> is start time of cropping range</li> <li><code>rstrip_s</code> is end point of cropping range</li> </ul>"},{"location":"visualization/filter/lttng_event_filter/#sample-code","title":"Sample code","text":"<p>A sample code, where <code>duration_filter</code> is used, is given as below.</p> <pre><code>from caret_analyze import Lttng, LttngEventFilter\n\nlttng = Lttng('/path/to/ctf', event_filters=[\n  LttngEventFilter.duration_filter(10, 5)\n]) # Filtering for 10 from 5 seconds\n</code></pre> <p>If you want to add another filter, append it to <code>event_filters</code> list.</p>"},{"location":"visualization/frequency/","title":"Frequency","text":"<p>CARET is able to show you frequencies of callback execution, message communication, and invocation of publisher or subscription. <code>Plot.create_frequency_timeseries_plot(target_object)</code> interface is provided for it. This section describes sample visualization scripts for them. Execute the following script code to load trace data and an architecture object before calling this method.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\n</code></pre>"},{"location":"visualization/frequency/#callback","title":"Callback","text":"<p><code>Plot.create_frequency_timeseries_plot(callbacks: Collections[CallbackBase])</code> and <code>Plot.create_frequency_histogram_plot(callbacks: Collections[CallbackBase])</code> are introduced to confirm whether targeted callback functions were running at desired frequency.</p> <pre><code>### Timestamp tables\nplot = Plot.create_frequency_timeseries_plot(app.callbacks)\nfrequency_df = plot.to_dataframe()\nfrequency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p>"},{"location":"visualization/frequency/#time-series","title":"Time Series","text":"<pre><code>### Time-series graph\nplot = Plot.create_frequency_timeseries_plot(app.callbacks)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means time, labeled as <code>Time [s]</code>. <code>xaxis_type</code> argument is prepared to select index of x-axis among Linux system time, ROS simulation time, and 0-based ordering. One of <code>'system_time'</code>, <code>'sim_time'</code> and <code>'index'</code> is chosen as <code>xaxis_type</code> though <code>'system_time'</code> is the default value. The vertical axis means frequency of callback execution, labeled as <code>Frequency [Hz]</code>. It is plotted per second.</p>"},{"location":"visualization/frequency/#histogram","title":"Histogram","text":"<pre><code>### Time-series graph\nplot = Plot.create_frequency_histogram_plot(app.callbacks)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means frequency, labeled as <code>frequency [Hz]</code>. The vertical axis is the probability of execution at that frequency, labeled <code>probability</code>.</p>"},{"location":"visualization/frequency/#communication","title":"Communication","text":"<p><code>Plot.create_frequency_timeseries_plot(communications: Collection[Communication])</code> and <code>Plot.create_frequency_timeseries_plot(communications: Collection[Communication])</code> are introduced to confirm targeted topic is communicated at expected frequency. Here, CARET takes into account communication when both transmission and reception on a message are performed successfully without being lost. See Premise of communication for more details.</p> <pre><code>### Timestamp tables\nplot = Plot.create_frequency_timeseries_plot(app.communications)\nfrequency_df = plot.to_dataframe()\nfrequency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p>"},{"location":"visualization/frequency/#time-series_1","title":"Time Series","text":"<pre><code>### Time-series graph\nplot = Plot.create_frequency_timeseries_plot(app.communications)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means time, labeled as <code>Time [s]</code> while the vertical axis means frequency of communication, labeled as <code>Frequency [Hz]</code> as well as time-series graph for callback execution. <code>xaxis_type</code> argument is provided as well.</p>"},{"location":"visualization/frequency/#histogram_1","title":"Histogram","text":"<pre><code>### Time-series graph\nplot = Plot.create_frequency_histogram_plot(app.communications)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means frequency, labeled as <code>frequency [Hz]</code>. The vertical axis is the probability of execution at that frequency, labeled <code>probability</code>.</p>"},{"location":"visualization/frequency/#publish-and-subscription","title":"Publish and Subscription","text":"<p><code>Plot.create_frequency_timeseries_plot(Collection[publish: Publisher or subscription: Subscriber])</code> is introduced to check how frequent target publisher or subscription is invoked.</p> <pre><code>### Timestamp tables\nplot = Plot.create_frequency_timeseries_plot(*app.publishers, *app.subscriptions)\nfrequency_df = plot.to_dataframe()\nfrequency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <pre><code>### Time-series graph\nplot = Plot.create_frequency_timeseries_plot(*app.publishers, *app.subscriptions)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <p>The horizontal axis means time, labeled as <code>Time [s]</code> while the vertical axis means invocation frequency of publish or subscription, labeled as <code>Frequency [Hz]</code> as well as time-series graph for callback execution. <code>xaxis_type</code> argument is provided as well.</p>"},{"location":"visualization/latency/","title":"Latency (or Execution time)","text":"<p>CARET is able to show you latencies of callback execution, message communication. <code>Plot.create_latency_timeseries_plot(target_object)</code> interface is provided for it. This section describes sample visualization scripts for them. Execute the following script code to load trace data and an architecture object before calling this method.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\n</code></pre>"},{"location":"visualization/latency/#callback","title":"Callback","text":"<p><code>Plot.create_latency_timeseries_plot(callbacks: Collections[CallbackBase])</code> and <code>Plot.create_latency_histogram_plot(callbacks: Collections[CallbackBase])</code> are served to see execution time of callback functions.</p> <pre><code>### Timestamp tables\nplot = Plot.create_latency_timeseries_plot(app.callbacks)\nlatency_df = plot.to_dataframe()\nlatency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p>"},{"location":"visualization/latency/#time-series","title":"Time Series","text":"<pre><code>### Time-series graph\nplot = Plot.create_latency_timeseries_plot(app.callbacks)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means time, labeled as <code>Time [s]</code>. <code>xaxis_type</code> argument is prepared to select index of x-axis among Linux system time, ROS simulation time, and 0-based ordering. One of <code>'system_time'</code>, <code>'sim_time'</code> and <code>'index'</code> is chosen as <code>xaxis_type</code> though <code>'system_time'</code> is the default value. The vertical axis means execution time of callback function, labeled as <code>Latency [ms]</code>. It is duration from <code>callback_start</code> to <code>callback_end</code> and plotted per sample.</p>"},{"location":"visualization/latency/#histogram","title":"Histogram","text":"<pre><code>### Histogram graph\nplot = Plot.create_latency_histogram_plot(app.callbacks)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means latency, labeled as <code>Latency [ms]</code>. The vertical axis is the probability of execution at that latency, labeled <code>probability</code>.</p>"},{"location":"visualization/latency/#communication","title":"Communication","text":"<p><code>Plot.create_latency_timeseries_plot(communications: Collection[Communication])</code> and <code>Plot.create_latency_histogram_plot(communications: Collection[Communication])</code> are called when you are concerned how long time is consumed from message publish to corresponding subscription. Here, CARET takes into account communication when both transmission and reception on a message are performed successfully without being lost. See Premise of communication for more details.</p> <pre><code>### Timestamp tables\nplot = Plot.create_latency_timeseries_plot(app.communications)\nlatency_df = plot.to_dataframe()\nlatency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p>"},{"location":"visualization/latency/#time-series_1","title":"Time Series","text":"<pre><code>### Time-series graph\nplot = Plot.create_latency_timeseries_plot(app.communications)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means time, labeled as <code>Time [s]</code>. <code>xaxis_type</code> argument is prepared as well as the previous callback subsection. The vertical axis means latency, labeled as <code>Latency [ms]</code>. It is plotted per sample.</p> <p> <p>Warning</p> <p>Communication latency is defined as elapsed time from topic message publish to subscription callback execution corresponding to the message. Strictly speaking, it is not not only elapsed time from message transmission to reception, but it also includes scheduling latency of callback.</p> <p>"},{"location":"visualization/latency/#histogram_1","title":"Histogram","text":"<pre><code>### Histogram graph\nplot = Plot.create_latency_histogram_plot(app.communications)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means latency, labeled as <code>Latency [ms]</code>. The vertical axis is the probability of execution at that latency, labeled <code>probability</code>.</p>"},{"location":"visualization/path/chain_latency/","title":"Chain latency","text":"<p>Chain latency shows a breakdown of path latency. As explained in configuration, path latency is sum of elapse time in inter-node data paths and that in intra-node data paths. Chain latency shows how time is cost in inter-node data path and intra-node data path respectively.</p> <pre><code>from caret_analyze.plot import chain_latency\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npath = app.get_path('target_path')\n\nchain_latency(path, granularity='node', lstrip_s=1, rstrip_s=1)\n</code></pre> <p></p> <ul> <li><code>granularity</code><ul> <li>Change the granularity of visualization in ['raw', 'node']</li> </ul> </li> <li><code>lstrip_s</code> and <code>rstrip_s</code><ul> <li>Extract the focusing points by removing unnecessary data</li> <li><code>lstrip_s</code> means that the data for 1 second from trace start is removed.</li> <li><code>rstrip_s</code> means that the data for 1 second from trace end is removed.</li> </ul> </li> </ul>"},{"location":"visualization/path/message_flow/","title":"Message flow","text":"<p><code>Plot.create_message_flow_plot()</code> function shows how input messages are received to nodes and output messages are transmitted to next nodes. You can confirm bottleneck of response in your application.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npath = app.get_path('target_path')\n\nplot = Plot.create_message_flow_plot(path, granularity='node', lstrip_s=1, rstrip_s=1)\nplot.show()\n</code></pre> <p></p> <p>The horizontal axis means time, labeled as <code>Time [s]</code>. The vertical axis lists names of nodes and topics in a target path. A colored line is corresponded to an input message and represents its propagation. With tracing a colored line, you can find when a message input is processed in a certain node. Gray rectangles indicate callback executions.</p> <p><code>Plot.create_message_flow_plot()</code> function has following arguments.</p> <ul> <li><code>granularity</code> is served to adjusts granularity of chain with two value; <code>raw</code> and <code>node</code><ul> <li>With <code>raw</code>, callback-level message flow is generated</li> <li>With <code>node</code>, node-level message flow is generated</li> </ul> </li> <li><code>treat_drop_as_delay</code> is a boolean value for the connection of the flow to the next flow if there is a drop</li> <li><code>lstrip_s</code> is float value for selecting start time of cropping time range</li> <li><code>rstrip_s</code> is float value for selecting end time of cropping time range</li> </ul> <p>Message flow diagram let you operate as follows.</p> <ul> <li>Scrolling upper or lower on x-axis for scaling up or down on horizontal direction</li> <li>Scrolling upper or lower on y-axis for scaling up or down on vertical direction</li> <li>Scrolling upper of lower on a graph for scaling up or down on both horizontal and vertical direction</li> <li>Hovering over a line in message flow or a gray rectangle give you details</li> </ul>"},{"location":"visualization/path/response_time/","title":"Response Time","text":"<p>In context of CARET, response time is defined how much of time costs from a message input to message output of a target path. Please refer to FAQ if you are interested in response time defined in CARET.</p> <p> <p>Note</p> <p>\"Response time\" is generally used for the input/output of a system. Therefore, when analyzing a part of a system (when a target path is a part of end-to-end path), it should be referred to as \"path latency (sum of node latency and communication latency)\" rather than \"response time\". However, both will be referred to as \"response time\" for simplicity in this document.</p> <p> <p>As a visualization of the graph, four different cases can be specified in the <code>case</code> argument. Default value is 'all'; 'all', 'best', 'worst', and 'worst-with-external-latency'.</p> <ul> <li><code>all</code> case<ul> <li>CARET displays the elapsed time from all input times in the same cycle.</li> </ul> </li> <li><code>best</code> case<ul> <li>CARET displays the elapsed time that is the shortest of all input times in the same cycle.</li> </ul> </li> <li><code>worst</code> case<ul> <li>CARET displays the elapsed time that is the longest of all input times in the same cycle.</li> </ul> </li> <li><code>worst-with-external-latency</code> case<ul> <li>CARET displays the elapsed time from the last input time of a previous cycle.</li> </ul> </li> </ul> <p>This section shows three methods to visualize response time, <code>Histogram</code>, <code>Stacked Bar</code> and <code>TimeSeries</code>. Execute the following script code to load trace data and an architecture object before calling this method.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npath = app.get_path('target_path')\n</code></pre>"},{"location":"visualization/path/response_time/#histogram","title":"Histogram","text":"<p>The following scripts generate histograms of response time. Horizontal axis of the histograms means response time, labeled <code>Response Time [ms]</code> and vertical axis of the histograms means <code>Probability</code>.</p> <pre><code># plot all case\nplot = Plot.create_response_time_histogram_plot(path)\nplot.show()\n# or\n# plot = Plot.create_response_time_histogram_plot(path, case='all')\n# plot.show()\n</code></pre> <p> <p>Info</p> <p>The <code>output_notebook()</code> is needed to show figures inside Jupyter Notebook.</p> <p> <p></p> <pre><code># plot best case\nplot = Plot.create_response_time_histogram_plot(path, case='best')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst case\nplot = Plot.create_response_time_histogram_plot(path, case='worst')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst-with-external-latency case\nplot = Plot.create_response_time_histogram_plot(path, case='worst-with-external-latency')\nplot.show()\n</code></pre> <p></p>"},{"location":"visualization/path/response_time/#stacked-bar","title":"Stacked Bar","text":"<p>The following scripts generate stacked bar graphs of response time. Horizontal axis of the stacked bar graph means <code>system time [s]</code> or <code>index</code> and vertical axis means breakdown of time elapsed for each callback in <code>response time [s]</code>.</p> <pre><code># plot all case\nplot = Plot.create_response_time_stacked_bar_plot(path)\nplot.show()\n# or\n# plot = Plot.create_response_time_stacked_bar_plot(path, case='all')\n# plot.show()\n</code></pre> <p></p> <pre><code># plot best case\nplot = Plot.create_response_time_stacked_bar_plot(path, case='best')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst case\nplot = Plot.create_response_time_stacked_bar_plot(path, case='worst')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst-with-external-latency case\nplot = Plot.create_response_time_stacked_bar_plot(path, case='worst-with-external-latency')\nplot.show()\n</code></pre> <p></p> <p>The horizontal axis can be changed to <code>system time</code> or <code>index</code> by changing <code>plot.show()</code> to <code>plot.show(xaxis_type='index')</code>.</p> <p><code>[worst - best] response time</code> in legends refers to the difference in response time between the worst case and the best case.</p>"},{"location":"visualization/path/response_time/#timeseries","title":"TimeSeries","text":"<p>The following scripts generate timeseries graphs of response time. The horizontal axis means <code>system time [s]</code> or <code>index</code>. The vertical axis means <code>Response Time [ms]</code>.</p> <pre><code># plot all case\nplot = Plot.create_response_time_timeseries_plot(path)\nplot.show()\n# or\n# plot = Plot.create_response_time_timeseries_plot(path, case='all')\n# plot.show()\n</code></pre> <p></p> <pre><code># plot best case\nplot = Plot.create_response_time_timeseries_plot(path, case='best')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst case\nplot = Plot.create_response_time_timeseries_plot(path, case='worst')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst-with-external-latency case\nplot = Plot.create_response_time_timeseries_plot(path, case='worst-with-external-latency')\nplot.show()\n</code></pre> <p></p> <p>The horizontal axis can be changed to <code>system time</code> or <code>index</code> by changing <code>plot.show()</code> to <code>plot.show(xaxis_type='index')</code> though <code>system_time</code> is the default value.</p>"},{"location":"visualization/period/","title":"Period","text":"<p>CARET is capable of showing periods of callback start, message transmission, invocation of publisher or subscription. <code>Plot.create_period_timeseries_plot(target_object)</code> interface is provided for it. This section describes sample visualization scripts for them. Execute the following script code to load trace data and an architecture object before calling this method.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\n</code></pre>"},{"location":"visualization/period/#callback","title":"Callback","text":"<p><code>Plot.create_period_timeseries_plot(callbacks: Collections[CallbackBase])</code> and <code>Plot.create_period_histogram_plot(callbacks: Collections[CallbackBase])</code> are introduced to check period between invocation of callback function . Period is more detailed metrics than frequency.</p> <pre><code>### Timestamp tables\nplot = Plot.create_period_timeseries_plot(app.callbacks)\nperiod_df = plot.to_dataframe()\nperiod_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p>"},{"location":"visualization/period/#time-series","title":"Time Series","text":"<pre><code>### Time-series graph\nplot = Plot.create_period_timeseries_plot(app.callbacks)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means time, labeled as <code>Time [s]</code>. <code>xaxis_type</code> argument is prepared to select index of x-axis among Linux system time, ROS simulation time, and 0-based ordering. One of <code>'system_time'</code>, <code>'sim_time'</code> and <code>'index'</code> is chosen as <code>xaxis_type</code> though <code>'system_time'</code> is the default value. The vertical axis means period of callback start, labeled as <code>Period [ms]</code>. It is plotted per sample.</p>"},{"location":"visualization/period/#histogram","title":"Histogram","text":"<pre><code>### histogram graph\nplot = Plot.create_period_histogram_plot(app.callbacks)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means period, labeled as <code>period [ms]</code>. The vertical axis is the probability of execution at that period, labeled <code>probability</code>.</p>"},{"location":"visualization/period/#communication","title":"Communication","text":"<p><code>Plot.create_period_timeseries_plot(communications: Collection[Communication])</code> and <code>Plot.create_period_histogram_plot(communications: Collection[Communication])</code> are helpful if you want to see that communication period is stable or not. Here, CARET takes into account communication when both transmission and reception on a message are performed successfully without being lost. See Premise of communication for more details.</p> <pre><code>### Timestamp tables\nplot = Plot.create_period_timeseries_plot(app.communications)\nperiod_df = plot.to_dataframe()\nperiod_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p>"},{"location":"visualization/period/#time-series_1","title":"Time Series","text":"<pre><code>### Time-series graph\nplot = Plot.create_period_timeseries_plot(app.communications)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means time, labeled as <code>Time [s]</code> while the vertical axis means period, labeled as <code>Period [ms]</code>, from communication of a certain message to that of next one. <code>xaxis_type</code> argument is provided as well as callback execution.</p>"},{"location":"visualization/period/#histogram_1","title":"Histogram","text":"<pre><code>### Histogram graph\nplot = Plot.create_period_histogram_plot(app.communications)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means period, labeled as <code>period [ms]</code>. The vertical axis is the probability of execution at that period, labeled <code>probability</code>.</p>"},{"location":"visualization/period/#publish-and-subscription","title":"Publish and Subscription","text":"<p><code>Plot.create_period_timeseries_plot(Collection[publish: Publisher or subscription: Subscriber])</code> is useful to check how stable invocation cycle of publisher or subscription is.</p> <pre><code>### Timestamp tables\nplot = Plot.create_period_timeseries_plot(*app.publishers, *app.subscriptions)\nperiod_df = plot.to_dataframe()\nperiod_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <pre><code>### Time-series graph\nplot = Plot.create_period_timeseries_plot(*app.publishers, *app.subscriptions)\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <p>The horizontal axis means time, labeled as <code>Time [s]</code>, while the vertical axis means invocation period of publish or subscription, labeled as <code>Period [ms]</code>. <code>xaxis_type</code> argument is prepared as well.</p>"},{"location":"visualization/scheduling/callback/","title":"Callback Scheduling Visualization","text":"<p>The function <code>Plot.create_callback_scheduling_plot()</code> visualizes the callback scheduling of targets, such as Node, Path, Executor, and Callbackgroup. This section describes sample visualization scripts for them. Execute the following script code to load trace data and an architecture object before calling this method.</p> <pre><code>from caret_analyze import Architecture, Application, Lttng\nfrom caret_analyze.plot import Plot\n\narch = Architecture('lttng', './e2e_sample')\nlttng = Lttng('./e2e_sample')\napp = Application(arch, lttng)\n</code></pre> <pre><code>### target: node\nnode = app.get_node('node_name') # get node object\nplot_node = Plot.create_callback_scheduling_plot(node)\nplot_node.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <pre><code>### target: callback group\ncbg = app.get_callback_group('cbg_name') # get callback group object\nplot_cbg = Plot.create_callback_scheduling_plot(cbg)\nplot_cbg.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <pre><code>### target: executor\nexecutor = app.get_executor('executor_name') # get executor object\nplot_executor = Plot.create_callback_scheduling_plot(executor)\nplot_executor.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p></p> <ul> <li>Callback Scheduling Visualization<ul> <li>Colored rectangles indicate the callback execution time (callback_start to callback_end)</li> <li>Information about the callback will be displayed by hovering over the translucent colored areas.</li> </ul> </li> <li>Timer Event Visualization<ul> <li>Arrows are the expected start timing of the timer callback</li> <li>If timer callbacks start with delay (5 ms or more), the arrows turn red (if on time, white)</li> </ul> </li> </ul>"},{"location":"visualization/search/wildcards_for_get_callbacks/","title":"Wildcards for get_callbacks()","text":"<p><code>get_callbacks()</code> function gets a list of callbacks whose names match a given string as an argument. If there is no matched callbacks, this function may tell you possible candidates of callback. <code>get_callbacks()</code> supports UNIX-based wildcard such as '*' or '?'.</p>"},{"location":"visualization/search/wildcards_for_get_callbacks/#usage","title":"Usage","text":"<pre><code>from caret_analyze import Architecture, Application, Lttng\n\ncallback1 = app.get_callbacks('/timer_driven_node/callback_0')\ncallback2 = app.get_callbacks('/timer_driven_node/callback_?')\ncallback3 = app.get_callbacks('/timer_driven_node/*')\n</code></pre>"}]}