{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chain-Aware ROS Evaluation Tool (CARET)","text":"<p>CARET is one of performance analysis tool dedicated with ROS 2 applications. It is able to measure not only callback latency and communication latency, but also path latency, in other words, chain of node or callback. As additional tracepoints are introduced by function hook, tracing resolution is improved.</p> <p>Features and capabilities are shown below.</p> <p>Features:</p> <ul> <li>Low overhead with LTTng-based tracepoints for sampling events in ROS/DDS layer</li> <li>Flexible tracepoints added by function hooking with LD_PRELOAD</li> <li>Python-based API for flexible data analysis and visualization</li> <li>Application-layer events tracing by cooperation with TILDE, runtime message tracer</li> </ul> <p>Capabilities:</p> <ul> <li>Performance measurement from several aspects<ul> <li>Callback latency, frequency, and period</li> <li>Topic communication latency, frequency, and period</li> <li>Node latency</li> <li>Path latency<ul> <li>End-to-end latency of software if path from input to output is selected</li> </ul> </li> </ul> </li> <li>Visualization of scheduling for callback execution</li> <li>Filtering function to ignore specific nodes and topics</li> <li>Search of target paths to trace</li> <li>Trace of application events like consumption of buffered topic message<ul> <li><code>/tf</code> (planned for v0.3.x release)</li> <li><code>message_filters</code> (supported by TILDE)</li> <li><code>image_transport</code> (supported by TILDE)</li> </ul> </li> </ul>"},{"location":"#tracing-flow-with-caret","title":"Tracing flow with CARET","text":"<p>CARET gives you capability of tracing your application with introducing new tracepoints to ROS and DDS layer while it utilized original tracepoints for <code>ros2_tracing</code>.</p> <p>CARET is served as only source code, but not as <code>apt</code> package, so far. CARET hooks dedicated functions to those defined in dynamic library in order to add tracepoints. The fork of rclcpp which has CARET-dedicated tracepoints is delivered. You have to build CARET and your application if you want to use.</p> <p>After you run your application with CARET, you will get recorded data which includes events, metadata and timestamp. You have to write a configuration file, called architecture file, in which you defines node latency and target path, before you analyze the data set.</p> <p>You will visualize trace data with the architecture file and <code>CARET_analyze</code> package, including API for data analysis. <code>CARET_analyze</code> is designed on assumption that users analyze trace data on Jupyter Notebook.</p>"},{"location":"#contents-list","title":"Contents list","text":""},{"location":"#installation","title":"Installation","text":"<p>Installation with Ansible is provided as the following page shows.</p> <ul> <li>Installation</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Refer to these page if you want to try.</p> <ul> <li>Recording</li> <li>Configuration</li> <li>Visualization</li> </ul>"},{"location":"#design","title":"Design","text":"<ul> <li>Index</li> <li>Software architecture</li> <li>Processing trace data</li> <li>Runtime processing</li> <li>Tracepoints</li> <li>Configuration</li> <li>Limits and constraints</li> </ul>"},{"location":"#details-of-each-step-for-analysis","title":"Details of each step for analysis","text":"<p>CARET serves helpful functions for you to analyze your application efficiently. Please refer to detailed explanation of each step for analysis.</p> <ul> <li>Recording</li> <li>Configuration</li> <li>Visualization</li> </ul>"},{"location":"#api-list","title":"API list","text":"<p>CARET serves powerful API to visualize and analyze performance. API list is located on the other repository, <code>CARET_analyze</code>.</p> <ul> <li>API list (external link)</li> </ul> <p>There are two types of APIs: for user and for developer.</p>"},{"location":"#related-repositories","title":"Related repositories","text":"<p>CARET is constructed of the following packages</p> <ul> <li>CARET_trace \uff5c Define tracepoints added by function hooking</li> <li>CARET_analyze \uff5c Library for scripts to analyze and visualize data</li> <li>CARET_analyze_cpp_impl \uff5c Efficient helper functions to analyze trace data written in C++</li> <li>ros2caret \uff5c CLI commands like <code>ros2 caret</code></li> <li>CARET_demos \uff5c Demo programs for CARET</li> <li>CARET_doc \uff5c Documentation</li> <li>rclcpp \uff5c the forked <code>rclcpp</code> including CARET-dedicated tracepoints</li> <li>ros2_tracing\uff5c the forked <code>ros2_tracing</code> including definition of CARET-dedicated tracepoints</li> </ul> <p>This software is based on results obtained from a project subsidized by the New Energy and Industrial Technology Development Organization (NEDO).</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#caret","title":"CARET","text":""},{"location":"changelog/#id","title":"v0.3.4 _ Dec 12, 2022","text":"<ul> <li>New: Added functions to rename subsystems in Architecture object like executor, node, callback and topic (CARET_analyze#156)</li> <li>Suppressed warning messages, which are outputted because <code>service</code> event is not supported, during trace data loading (CARET_analyze#192)</li> <li>Fixed bug which calculated incorrect period or frequency (CARET_analyze#213)</li> <li>Fixed error messages from <code>Mypy</code> (CARET_analyze#211)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.3 _ Nov 28, 2022","text":"<ul> <li>Added guidances for a beginner to avoid getting stuck in unexpected cases (CARET_analyze #200 and CARET_analyze #186)</li> <li>Added <code>publishers</code> and <code>subscriptions</code> properties to <code>Architecture</code> and <code>Application</code> classes (CARET_analyze #179, CARET_analyze #180)</li> <li>Added function to update cache file named as <code>caret_converted</code> (CARET_analyze#189)</li> <li>Suppressed unnecessary warnings in <code>check_caret_rclcpp</code> (ros2caret #53, ros2caret #54)</li> <li>Improved documentation of installation (CARET_doc #111), configuration (CARET_doc #112), visualization (CARET_doc #98), and design (CARET_doc#106)</li> <li>Fixed a bug which makes incorrect graphs (CARET_analyze #201)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.2 _ Nov 14, 2022","text":"<ul> <li>Improved warning messages of CARET_analyze (CARET_analyze #144, CARET_analyze #158, CARET_analyze #162, CARET_analyze #172, CARET_analyze #182)</li> <li>Added properties of <code>publishers</code> and <code>subscriptions</code> to <code>Application</code> and <code>Architecture</code> object(CARET_analyze #179)</li> <li>Improved ros2caret(ros2caret #44, ros2caret #50)</li> <li>Enlarged buffer size(ros2_tracing #2)</li> <li>Added some minor changes (CARET_analyze #183, CARET_analyze #187)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.1 _ Oct 31, 2022","text":"<ul> <li>Added record function to ros2caret for upcoming feature. (ros2caret #38)</li> <li>Added function to display histogram for response time (CARET_analyze #165)</li> <li>Added API to calculate period and latency (CARET_analyze #167, CARET_analyze #168)</li> <li>Fixed some bugs (CARET_analyze #141, CARET_analyze #153, CARET_analyze #157)</li> <li>Refactored <code>Architecture</code> object interface (CARET_analyze)</li> <li>Added some minor changes (CARET_analyze #139, CARET_analyze #146, CARET_analyze #147, CARET_analyze #151, CARET_analyze #159, CARET_analyze #162, CARET_analyze #165, CARET_analyze#171)</li> </ul>"},{"location":"changelog/#id","title":"v0.3.0 _ Sept 26, 2022","text":"<ul> <li>Supported OS: Ubuntu 22.04</li> <li>Supported ROS Dist.: ROS Humble</li> <li>Imported to Ubuntu 22.04 and ROS Humble</li> <li>Added new feature to show response time (CARET_analyze #96)</li> <li>Added new APIs to visualize frequency, period, and latency of publishes, subscriptions, and communications (CARET_analyze #124, #130, #133, #134, #136, #140)</li> <li>Reduced memory consumption wasted for recorded data (CARET_analyze #100)</li> <li>Launched CARET_analyze API document</li> <li>Added small fixes<ul> <li>CARET_analyze #107</li> <li>CARET_analyze #107</li> <li>CARET_analyze #108</li> <li>CARET_analyze #109</li> <li>CARET_analyze #112</li> <li>CARET_analyze #115</li> </ul> </li> </ul>"},{"location":"changelog/#id","title":"v0.2.3 _ July 14, 2022","text":"<ul> <li>Supported OS: Ubuntu 20.04</li> <li>Supported ROS Dist.: ROS Galactic</li> <li>Improved output message from <code>path.verify()</code> method</li> <li>Improved view of graphs</li> <li>Added wildcard support for <code>Architecture.callbacks()</code> method</li> <li>Added command line function to check trace data</li> <li>Fixed specification of <code>Architecture.search_paths()</code> method</li> <li>Added function to extract duplicated timer callback</li> </ul>"},{"location":"changelog/#id","title":"v0.2.2 _ May 2, 2022","text":"<ul> <li>Supported OS: Ubuntu 20.04</li> <li>Supported ROS Dist.: ROS Galactic</li> <li>Added feature to measure complicated node path</li> <li>Added feature to choose optional trace points</li> <li>Added <code>Architecture.search_paths()</code> method</li> <li>Improved trace filtering function</li> </ul>"},{"location":"gallery/","title":"Gallery","text":"<p>This page shows examples of figures that can be visualized in CARET. CARET visualizes these figures on jupyter-notebook.</p>"},{"location":"gallery/#callback","title":"Callback","text":""},{"location":"gallery/#frequency","title":"Frequency","text":"<p> Detail : Frequency</p>"},{"location":"gallery/#period","title":"Period","text":"<p> Detail : Period</p>"},{"location":"gallery/#latency","title":"Latency","text":"<p> Detail : Latency</p>"},{"location":"gallery/#callback-scheduling-visualization","title":"Callback Scheduling Visualization","text":"<p> Detail : Callback Scheduling Visualization</p>"},{"location":"gallery/#communication","title":"Communication","text":""},{"location":"gallery/#frequency_1","title":"Frequency","text":"<p> Detail : Frequency</p>"},{"location":"gallery/#period_1","title":"Period","text":"<p> Detail : Period</p>"},{"location":"gallery/#latency_1","title":"Latency","text":"<p> Detail : Latency</p>"},{"location":"gallery/#publishsubscribe-frequency","title":"Publish/Subscribe Frequency","text":"<p> Detail : Frequency</p>"},{"location":"gallery/#publishsubscribe-period","title":"Publish/Subscribe Period","text":"<p> Detail : Period</p>"},{"location":"gallery/#path","title":"Path","text":""},{"location":"gallery/#message-flow","title":"Message flow","text":"<p> Detail : Message flow</p>"},{"location":"gallery/#response-time-histogram","title":"Response Time Histogram","text":"<p> Detail : Response Time Histogram</p>"},{"location":"gallery/#chain-latency","title":"Chain latency","text":"<p> Detail : Chain latency</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#introduction","title":"Introduction","text":"<p>Configuration is a phase where users tell CARET which data path is targeted for visualization.</p> <p>CARET is capable of recording enormous numbers of events even when a large application runs. The large application may have lots of data paths, but most users must not want to observe all of data paths. If CARET kindly shows analysis results for all of possible data paths, users will be overwhelmed and exhausted to deal with large amount of results.</p> <p>For delivering efficient analysis, CARET is designed to show analysis results on demand. CARET serves user functions to select target data paths to fulfill their interests.</p> <p>In addition to defining targeted path, CARET will ask users to define node latency before users analyze their application with visualization.</p> <p>The rest of this chapter will explain the following two types of sections;</p> <ul> <li>The detailed background of configuration</li> <li>The basic procedure for preparing desired configuration</li> </ul> <p>In detail, the following sections are listed as below.</p> <ul> <li>Background of configuration section will explain detailed background of configuration phase</li> <li>How to load and save section will tell you how to load and save configuration</li> <li>How to define inter-node data path section will tell you how to use <code>architecture.search_paths()</code></li> <li>How to define intra-node data path will let you know what <code>message_context</code> is. This is advanced topic than others</li> <li>Practical example with CARET_demos will demonstrates configuration process on <code>CARET_demos</code></li> </ul> <p>Visualization of application structure will be prepared as an appendix which shows another usage of an architecture object. CARET can show structure of a targeted application while it is a performance analysis tool. This appendix will be disclosed in the near future also.</p>"},{"location":"configuration/background/","title":"Background","text":"<p>CARET is mainly capable of showing the following 4 latency:</p> <ul> <li>callback latency</li> <li>communication latency (inter-node)</li> <li>node latency (intra-node)</li> <li>path latency (intra-node &amp; inter-node)</li> </ul> <p>The following figure shows definition of node latency and path latency.</p> <p></p> <p>Callback latency is defined as execution time of a callback function, and can be measured with simple tracepoints. Communication latency between nodes can be defined as time from publish invoking to subscription callback invoking. Identifying callback and topic is not difficult so that their latency are calculated easily. However, it's difficult to define node latency and path latency mechanically. Node latency, time elapsed from input to output in a certain node, cannot be identified in ROS layer and its definition depends on patterns of application implementation. Path latency, which is defined as combination of node latency and communication latency, depends implementation patterns as well as node latency. Paths are combination of nodes which are connected via topic messages. The number of paths in an application is equaled to that of nodes combination, so that complicated and large application has large number of paths. To deal with such difficulty of defining node and path latency mechanically, CARET requires users to define node and path latency manually via a configurable object , called \"architecture object\".</p>"},{"location":"configuration/background/#architecture-object","title":"Architecture object","text":"<p>An architecture object has two sections; application structure and latency definition. Application structure section describes components of a target application and their connections, represented as executors, nodes, callback groups, callbacks, topics, and timers. CARET can load an architecture object including only application structure section from CTF-based recorded data. The application structure section remains same unless the structure is changed or component is renamed.</p> <p>On the other hand, latency definition section in the original architecture object is empty just before users add any definition. Users are expected to add definitions of node latency and path latency to the original architecture object. CARET helps users to add definition of node and path latency.</p> <p>The following sections explain how to load an architecture object and add latency definition.</p>"},{"location":"configuration/inter_node_data_path/","title":"How to define inter-nodes data path","text":"<p>Latency definition section is empty just after an architecture object is loaded from a set of CTF-based recorded data. If you want to observe data flow on targeted paths, you should add the target paths to the architecture object. As a path is combination of multiple nodes and topics, it may be laborious to list their names. To mitigate such burden, CARET serves a function to search the targeted path. The targeted path is added to the architecture object via Python API.</p>"},{"location":"configuration/inter_node_data_path/#basic-usage-to-find-and-add-target-path","title":"Basic usage to find and add target path","text":"<p>Listing nodes and topics by their names is laborious. CARET serve a helpful method, <code>arch.search_paths</code>, to search candidates that you want to observe.</p> <p>The following sample code shows usage of <code>arch.search_paths</code> method.</p> <pre><code># Architecture object is loaded to variable of arch\n\npaths = arch.search_paths('source_node',\n                          'destination_node')\n\ntype(paths) # list of multiple paths\npaths[0].summary.pprint() # shows nodes and topics in paths[0]\n</code></pre> <p>In the sample, <code>paths</code> is a list including all possible paths between <code>source_node</code> and <code>destination_node</code>, whose type is <code>PathStructValue</code>. If you are satisfied with output from <code>paths[0].summary.pprint()</code>, you have to add <code>paths[0]</code> to the <code>arch</code> object as below.</p> <pre><code>arch.add_path('target_path', paths[0])\n\narch.export('new_architecture_with_path.yaml')\n</code></pre> <p>In the above sample, <code>paths[0]</code> is named as <code>target_path</code> and registered to the <code>arch</code> object. <code>arch</code> object is exported to a new architecture file for reuse.</p> <p>If you want to restore the <code>paths[0]</code> object with <code>new_architecture_with_path.yaml</code> file, <code>arch.get_path()</code> method will help you to do so.</p> <pre><code>arch = Architecture('yaml', 'new_architecture_with_path.yaml')\n\npath = arch.get_path('target_path') # path object is same as paths[0] in the previous sample\n</code></pre>"},{"location":"configuration/inter_node_data_path/#efficient-target-path-search","title":"Efficient target path search","text":"<p>As explained above, <code>Architecture.search_paths()</code> returns list of multiple paths. The list size will be too large to find target path if application has large numbers of nodes and distance between source and destination node is long. In worse case, <code>Architecture.search_paths()</code> keep searching and does not return <code>paths</code> variable after hours passes.</p> <p><code>Architecture.search_paths()</code> method serves four options to narrow down possible paths as below.</p> <ol> <li>Additional nodes as variable length arguments</li> <li>Limiting maximum number of nodes between given nodes with <code>max_node_depth</code></li> <li>Node filter which excludes paths including specific nodes</li> <li>Communication filter which excludes paths including specific topics</li> </ol> <p>In short, <code>Architecture.search_paths</code> is defined as follows.</p> <pre><code>search_paths(\n    *node_names: 'str',\n    max_node_depth: 'Optional[int]' = None,\n    node_filter: 'Optional[Callable[[str], bool]]' = None,\n    communication_filter: 'Optional[Callable[[str], bool]]' = None\n) -&gt; 'List[PathStructValue]'\n</code></pre> <p>The following sub-sections will explain their roles and usages in details.</p>"},{"location":"configuration/inter_node_data_path/#additional-nodes","title":"Additional nodes","text":"<p>In the previous example, <code>Architecture.search_paths()</code> had two arguments <code>source_node</code> and <code>destination_node</code>. However, the number of nodes given to <code>Architecture.search_paths()</code> is variable and not always two. You can add other nodes to <code>Architecture.search_paths()</code> as below, and you will get a list including multiple paths which passes all given nodes.</p> <pre><code># Architecture object is loaded to variable of arch\n\npaths = arch.search_paths('source_node',\n                          'intermediate_node_1',\n                          'intermediate_node_2',\n                          'destination_node')\n</code></pre> <p><code>paths</code> is a list including multiple paths which pass <code>source_node</code>, <code>intermediate_node_1</code>, <code>intermediate_node_2</code>, and <code>destination_node</code>. They are allowed to pass another node, but all chosen nodes are passed in order.</p>"},{"location":"configuration/inter_node_data_path/#limiting-maximum-number-of-nodes","title":"Limiting maximum number of nodes","text":"<p><code>Architecture.search_paths()</code> will scan all paths as possible if you don't give <code>max_node_depth</code> argument. <code>max_node_depth</code> means maximum number between given nodes. The number of candidate paths will be suppressed by this argument.</p> <p>This argument will be helpful When you waste much time for <code>Architecture.search_paths()</code>.</p> <p>The usage is shown as below. This can be used with another approach to filter candidates.</p> <pre><code># Architecture object is loaded to variable of arch\n\npaths = arch.search_paths('source_node',\n                          'intermediate_node_1',\n                          'destination_node',\n                          max_node_depth=10)\n</code></pre> <p><code>max_node_depth</code> does not always limit the maximum number of nodes between source and destination. If you give 3 nodes to <code>arch.search_paths</code> as shown above, <code>max_node_depth</code> does not limits the maximum number of nodes between <code>source_node</code> and <code>destination_node</code>. In this example, <code>max_node_depth</code> limits the number of nodes between <code>source_node</code> and <code>intermediate_node_1</code>, and that between <code>intermediate_node_1</code> and <code>destination_node</code>.</p>"},{"location":"configuration/inter_node_data_path/#node-and-topic-filter","title":"Node and topic filter","text":"<p>As node filter is similar to communication filter, they are explained together in this section.</p> <p>With node filter and communication filter, <code>Architecture.search_paths()</code> excludes paths which includes selected nodes or topics. They support regular expression.</p> <p>The following sample code shows usage.</p> <pre><code>import re\n\n# name list of nodes to be excluded\nnode_filters = [\n    re.compile(r'/_ros2cli_/*'),\n    re.compile(r'/launch_ros_*'),\n]\n\n# name list of topics to be excluded\ncomm_filters = [\n    re.compile(r'/tf/*'),\n]\ndef comm_filter(topic_name: str) -&gt; bool:\n    can_pass = True\n    for comm_filter in comm_filters:\n        can_pass &amp;= not bool(comm_filter.search(topic_name))\n    return can_pass\n\ndef node_filter(node_name: str) -&gt; bool:\n    can_pass = True\n    for node_filter in node_filters:\n        can_pass &amp;= not bool(node_filter.search(node_name))\n    return can_pass\n\npaths = arch.search_paths(\n    '/start_node',\n    '/intermediate_node'\n    '/end_node',\n    max_node_depth=30,\n    node_filter = node_filter,\n    communication_filter = comm_filter)\n</code></pre>"},{"location":"configuration/intra_node_data_path/","title":"How to define intra-node data path","text":"<p>In the previous section, you learned how to define inter-node data path. CARET can calculate response time for a simple path using only inter-node data path definition. However, when a target application or path becomes complicated, intra-node-data path needs to be defined as well as inter-node data path.</p> <p>CARET assume that intra-node data path is mapping of topic subscription and publish in a node. This is not defined simply because the definition depends on implementation.</p> <p>This section will explain how to find which intra-node data path you have to define, and how to define it.</p>"},{"location":"configuration/intra_node_data_path/#find-which-intra-node-data-path-to-define","title":"Find which intra-node data path to define","text":"<p>Before defining intra-node data path, you have to check whether latency of the target path is calculable. This can be checked with <code>Path.verify()</code> method as the following sample code shows.</p> <pre><code>arch = Architecture('yaml', '/path/to/architecture.yaml')\n\npath = arch.get_path('target_path')\npath.verify()\n</code></pre> <p>Here, <code>path.verify()</code> returns <code>True</code> if path latency for <code>path</code> is calculable. Otherwise, you will confront with warning messages as shown below.</p> <p>Example 1.</p> <pre><code>WARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/message_driven_node')\nmessage_context: null\nnode: /message_driven_node\npublish_topic_name: /topic3\nsubscribe_topic_name: /topic2\n\nWARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/timer_driven_node')\nmessage_context: null\nnode: /timer_driven_node\npublish_topic_name: /topic4\nsubscribe_topic_name: /topic3\n</code></pre> <p>Example 2.</p> <pre><code>WARNING : 2022-03-18 12:53:54 | 'caret/rclcpp' may not be used in subscriber of '/topic/name'.\n</code></pre> <p>On the sample warning message of <code>Example 1</code>, <code>/message_driven_node</code> and <code>/timer_driven_node</code> have undefined intra-node data path. You will add the intra-node data path in next step.</p> <p>On the other message, <code>Example 2</code>, the node which subscribes <code>/topic/name</code> topic has not compiled with caret/rclcpp. Please check here.</p>"},{"location":"configuration/intra_node_data_path/#message-context","title":"Message Context","text":"<p>CARET assumes that node latency is defined as duration from subscription time to publish time. The definition looks simple, but node latency is difficult to define mechanically because some nodes have multiple inputs or multiple outputs.</p> <p>CARET require users to define <code>message_context</code> to calculate node latency. One of the following policies is acceptable for <code>message_context</code>.</p> <ul> <li><code>use_latest_message</code></li> <li><code>callback_chain</code></li> </ul> <p>They have different capability to measure node latency, and the selected <code>message_context</code> policy decides how to calculate node latency. However, <code>message_context</code> is a little difficult for CARET beginners without any example. The subsequence section introduces an example issue before explaining the policies.</p> <p>These two policies are not enough to cover the arbitrary node latency, and some implementations have node latency that cannot be measured. For example, message filter is currently unable to measure.</p>"},{"location":"configuration/intra_node_data_path/#example-issue","title":"Example issue","text":"<p>An example issue on <code>/ping_node</code> and <code>/pong_node</code> is given as the below figure shows.</p> <p></p> <p>Next items are explaining <code>/ping_node</code> and <code>/pong_node</code>.</p> <ul> <li><code>/ping_node</code><ul> <li>it transmit messages of <code>/ping</code> topic to <code>/pong_node</code></li> <li>it is composed of a single callback function</li> </ul> </li> <li><code>/pong_node</code><ul> <li>it transmits message of <code>/pong</code> topic to another node</li> <li>it is composed of two callback functions; <code>subscription_callback_0</code> and <code>timer_callback_1</code></li> <li>it receives messages of <code>/ping</code> topic from <code>/pong_node</code> via <code>subscription_callback_0</code></li> <li><code>subscription_callback_0</code> shares messages <code>/ping</code> topic with <code>timer_callback_1</code> via shared variable</li> <li><code>timer_callback_1</code> produces <code>/pong</code> with the shared messages</li> <li><code>timer_callback_1</code> runs about 8/5 as frequent as <code>timer_callback_0</code></li> </ul> </li> </ul> <p>CARET is concerned which input topic message is mapped to an output message. <code>message_context</code> is provided to map input messages to output messages.</p>"},{"location":"configuration/intra_node_data_path/#use_latest_message","title":"<code>use_latest_message</code>","text":"<p>With <code>use_latest_message</code> policy, CARET will map a most recent input message to output message. CARET focuses on input and output,but is not concerned structure of node structure. The next figure shows how CARET defines node latency with <code>use_latest_message</code> in the example issue.</p> <p></p> <p>In the figure, latest messages of <code>ping</code> topic is mapped to messages of <code>/pong</code> topic mechanically by CARET. It is not still easy to understand with only the block figure, but the provided timing chart below help you to understand what <code>use_latest_message</code> is.</p> <p></p> <p>In the timing chart, colored boxes represent duration of callback running, and bold lines are message flow of topic message. Dotted lines indicates mapping between input messages and outputs. With <code>use_latest_message</code>, CARET assumes that output message is made from the most recent input message. <code>use_latest_message</code> is fairly simple and works well in most cases.</p> <p>In the timing chart, red dotted lines explains a pitfall of <code>use_latest_message</code>. Using <code>use_latest_message</code> policy, CARET believes that input message, which is not even processed completely, is mapped to output message. For example, CARET interprets that <code>/pong[4]</code> is made from <code>/ping[2]</code> because <code>/ping[2]</code> is the recent input message for <code>/pong[4]</code>. However, <code>subscription_callback_0</code> is processing <code>/ping[2]</code> and does not share it with <code>timer_callback_1</code> before publishing <code>/pong[4]</code>. You have to tell CARET the node structure when you find such pitfall.</p>"},{"location":"configuration/intra_node_data_path/#callback_chain","title":"<code>callback_chain</code>","text":"<p><code>callback_chain</code> is introduced for CARET to map input messages to outputs based on inter-operation of multiple callback functions. Input messages are consumed in subscription callbacks and propagated to other nodes. It looks as if input messages passes chains of multiple callbacks to make output messages. With <code>callback_chain</code>, CARET take care of input propagation on callbacks and it is helpful to escape the limitation of <code>use_latest_message</code> as mentioned above.</p> <p>Next figure shows how CARET interprets intra-node data path using <code>callback_chain</code>. Intra-communication between <code>subscription_callback_0</code> and <code>timer_callback_1</code> is taken into account for defining intra-node data path. <code>variable_passings</code> is a tag used in CARET, and represents such intra-communication.</p> <p></p> <p>The following timing chart shows how input messages are mapped to output messages.</p> <p></p> <p>CARET maps mechanically messages of <code>/pong</code> topic to messages of <code>/ping</code> which finish being processed on <code>subscription_callback_0</code>. The unexpected behavior of <code>use_latest_message</code> is improved by <code>callback_chain</code>.</p> <p><code>callback_chain</code> looks the best choice. However, it has several drawbacks.</p> <ul> <li>It is not designed for node which have multiple callbacks running at parallel, and response time might be longer than actual</li> <li>It is not able to detect actual time when buffered data are consumed because only CARET does not trace user code on ROS 2</li> <li>Users are expected to know node structure beforehand</li> </ul> <p> <p>Info</p> <p><code>use_latest_message</code> and <code>callback_chain</code> do not cover all of use cases for CARET. We, CARET development team, continue improvements of intra-node data path definition.</p> <p>"},{"location":"configuration/intra_node_data_path/#python-api","title":"Python API","text":"<p>Python API is not implemented so far. Python API support is planned in 2023.</p>"},{"location":"configuration/intra_node_data_path/#architecture-file-editing","title":"Architecture file editing","text":"<p>This section explain how to add intra-node data path definition with editing an architecture file. The example issue above is used for explanation.</p>"},{"location":"configuration/intra_node_data_path/#use_latest_message_1","title":"<code>use_latest_message</code>","text":"<p>Next sample description is required for using <code>use_latest_message</code> on an architecture file. <code>use_latest_message</code> is applied to <code>/pong_node</code> in the next sample description. Essential description is extracted in the following snippet, but you will confront with busy YAML file actually rather than the sample.</p> <p>You have to add <code>use_latest_message</code> as <code>context_types</code> between targeted subscription and publisher.</p> <pre><code>- node_name: /pong_node\n  callbacks:\n    - callback_name: subscription_callback_0\n    - callback_name: timer_callback_1\n  publishes:\n    - topic_name: /pong\n      callback_names:\n        - timer_callback_1 # manually added\n  subscribes:\n    - topic_name: /ping\n      callback_name: subscription_callback_0\n  message_contexts:\n    - context_type: use_latest_message # manually added\n      subscription_topic_name: /ping\n      publisher_topic_name: /pong\n</code></pre>"},{"location":"configuration/intra_node_data_path/#callback_chain_1","title":"<code>callback_chain</code>","text":"<p>On the other hand, CARET requires users to provide the following description if you apply <code>callback_chain</code> to <code>/pong_node</code>.</p> <pre><code>- node_name: /pong_node\n  callbacks:\n    - callback_name: subscription_callback_0\n    - callback_name: timer_callback_1\n  variable_passings:\n    - callback_name_write: subscription_callback_0 # manually added\n      callback_name_read: timer_callback_1 # manually added\n  publishes:\n    - topic_name: /ping\n      callback_names:\n        - timer_callback_1 # manually added\n  subscribes:\n    - topic_name: /pong\n      callback_name: timer_callback_1\n  message_contexts:\n    - context_type: callback_chain # manually added\n      subscription_topic_name: /pong\n      publisher_topic_name: /ping\n</code></pre> <p>User have to fill callback name in <code>variable_passings</code>, <code>publishes</code>'s <code>callback_name</code>. <code>context_type</code> must be set as <code>callback_chain</code>. After editing, use path.verify() described in the beginning of this section to verify that it has been set correctly.</p>"},{"location":"configuration/load_and_save/","title":"How to load and save an architecture object","text":"<p>The first step of configuration is to load an architecture object from a set of CTF-based recorded data onto memory. You can update the architecture object as the following section explains. After you finish updating it, you can save it to a yaml-based file, called \"architecture file\" to reuse the updated object.</p> <p>An architecture file has structure of a targeted application. <code>dear_ros_node_viewer</code> help you to comprehend structure of the application with the architecture file.</p>"},{"location":"configuration/load_and_save/#python-api","title":"Python API","text":"<p>CARET serves Python-based APIs to load and save an architecture object.</p> <p>All of the following code snippets can be executed after load environment variables with <code>source /path/to/ros2_caret_ws/install/setup.bash</code>.</p>"},{"location":"configuration/load_and_save/#load-from-a-set-of-ctf-based-recorded-data","title":"Load from a set of CTF-based recorded data","text":"<p>You can load an architecture object with <code>Architecture</code> constructor.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('lttng', '/path/to/ctf-based_recorded_data')\n</code></pre> <p>You will find <code>caret_analyze.architecture.Architecture</code>-based object, named '<code>arch</code>'.</p> <p>Loading an architecture object from CTF-based recorded data tends to be time-consuming task.</p>"},{"location":"configuration/load_and_save/#load-from-a-yaml-based-architecture-file","title":"Load from a YAML-based architecture file","text":"<p>As I mentioned, CARET serves a function to stored an architecture object into YAML-based architecture file for reusability. It can save loading time and preserve update of the object. You can load it from YAML-based file with only replacing '<code>lttng</code>' of the first argument of <code>Architecture</code> constructor by '<code>yaml</code>'.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('yaml', '/path/to/architecture.yaml')\n</code></pre> <p>It is recommended for you to use YAML-based file to benefit from reusability unless structure of targeted application is changed.</p>"},{"location":"configuration/load_and_save/#save","title":"Save","text":"<p>CARET provides <code>Architecture.export</code> method to save an architecture object as follow.</p> <pre><code># arch is caret_analyze.architecture.architecture.Architecture-based object\n\n\narch.export('/path/to/destination/architecture.yaml')\n\n! readlink -f /path/to/destination//architecture.yaml\n# /path/to/destination/architecture.yaml\n</code></pre> <p>The argument of <code>arch.export()</code> is string type and means file path to store the <code>arch</code> object. In this sample, <code>architecture.yaml</code> will be created in <code>/path/to/destination</code> directory if the destination path is writable or another file of the same name does exist.</p> <p><code>arch.export()</code> has the second argument, <code>force</code>, to allow you to overwrite the <code>arch</code> object into an existing file. The following sample shows how to overwrite.</p> <pre><code>arch.export('/path/to/destination/architecture.yaml', force=True)\n\n! readlink -f /path/to/destination//architecture.yaml\n# /path/to/destination/architecture.yaml\n</code></pre> <p><code>force=True</code> option erases the existing architecture object.</p>"},{"location":"configuration/load_and_save/#cli","title":"CLI","text":""},{"location":"configuration/load_and_save/#create-an-architecture-file-via-cli","title":"Create an architecture file via CLI","text":"<p>With the functions I introduced above, you can create a YAML-based file including an architecture object. CARET serves CLI to create it as well. <code>create_architecture_file</code> command plays role of it.</p> <p>The following sample code shows how to use <code>create_architecture_file</code> command.</p> <pre><code>source /path/to/ros2_caret_ws/install/setup.bash\n\nros2 caret create_architecture_file /path/to/ctf-based_recorded_data -o /path/to/destination/architecture.yaml\n\nreadlink -f /path/to/destination/architecture.yaml\n# /path/to/destination/architecture.yaml\n</code></pre>"},{"location":"configuration/practical_example/","title":"Practical example of configuration","text":"<p>The previous sections have explained what to do in configuration. This section explains you a practical example to let you understand the flow of configuration.</p> <p>This section demonstrates creation of an architecture file for <code>CARET_demos</code> on Jupyter Notebook. Defining inter-node and intra-node data path is also demonstrated. The following three steps are explained.</p> <ol> <li>Load an Architecture object on Jupyter Notebook</li> <li>Define an inter-node data path</li> <li>Define an intra-node data path</li> </ol> <p>The architecture file that will be created in the example is provided here.</p>"},{"location":"configuration/practical_example/#load-an-architecture-object-on-jupyter-notebook","title":"Load an Architecture object on Jupyter Notebook","text":"<p>Load an architecture object from recorded data, as explained section of Load and save</p> <ol> <li> <p>Launch Jupyter Notebook (Jupyter Lab)</p> <pre><code>mkdir -p ~/ros2_ws/evaluate &amp;&amp; cd ~/ros2_ws/evaluate\n\nsource ~/ros2_caret_ws/install/setup.bash\njupyter-lab\n</code></pre> </li> <li> <p>Generate an architecture file from recorded data as below</p> <pre><code>from caret_analyze import Architecture\n\n# Read description of application's architecture from recorded data\n#\narch = Architecture('lttng', './e2e_sample')\n\n# Save description as an architecture file\narch.export('architecture.yaml')\n\n# Check if the architecture file is created\n! readlink -f ./architecture.yaml\n# /home/user/ros2_caret_ws/eval/architecture.yaml\n</code></pre> </li> </ol>"},{"location":"configuration/practical_example/#define-an-inter-node-data-path","title":"Define an inter-node data path","text":"<p>Define an inter-node data path on the loaded architecture object as section of Define inter-node data path explained</p> <ol> <li> <p>Load the yaml-based architecture file as below</p> <pre><code>from caret_analyze import Architecture, check_procedure\narch = Architecture('yaml', './architecture.yaml')\n</code></pre> </li> <li> <p>Choose source node and destination node in a path</p> <p><code>arch.search_paths</code> extract all candidates of the path</p> <pre><code>paths = arch.search_paths(\n'/sensor_dummy_node', # source node\n'/actuator_dummy_node') # destination node\n</code></pre> <p>If a target application is large and complicated, <code>arch.search_paths</code> method may consume time more than 1 minute.  For decreasing consumed time, you can ignore nodes and topics and specify depth of search. Refer to Define inter-node data path for more details.</p> </li> <li> <p>Check the path as you expected</p> <p>You will find multiple candidates of the path. You can check which candidate is expected as target. The following code is an example for users to check</p> <pre><code>path = paths[0]\npath.summary.pprint()\n\n---Output text as below---\n\npath:\n  - message_context: null # for definition of node latency\n    node: /sensor_dummy_node\n  - topic: /topic1\n  - message_context:\n      publisher_topic_name: /topic2\n      subscription_topic_name: /topic1\n      type: callback_chain\n    node: /filter_node\n  - topic: /topic2\n  - message_context: null\n    node: /message_driven_node\n  - topic: /topic3\n  - message_context: null\n    node: /timer_driven_node\n  - topic: /topic4\n  - message_context: null\n    node: /actuator_dummy_node\n</code></pre> </li> <li> <p>Give a name to selected path and update architecture file</p> <pre><code>arch.add_path('target_path', path)\narch.export('./architecture.yaml', force=True)\n</code></pre> <p>The updated architecture file describes the path named as <code>target_path</code>.</p> <pre><code>named_paths:\n- path_name: target_path\nnode_chain:\n- node_name: /sensor_dummy_node\npublish_topic_name: /topic1\nsubscribe_topic_name: UNDEFINED\n- node_name: /filter_node\npublish_topic_name: /topic2\nsubscribe_topic_name: /topic1\n- node_name: /message_driven_node\npublish_topic_name: /topic3\nsubscribe_topic_name: /topic2\n- node_name: /timer_driven_node\npublish_topic_name: /topic4\nsubscribe_topic_name: /topic3\n- node_name: /actuator_dummy_node\npublish_topic_name: UNDEFINED\nsubscribe_topic_name: /topic4\n</code></pre> </li> </ol>"},{"location":"configuration/practical_example/#define-intra-node-data-path","title":"Define intra-node data path","text":"<p>Define an intra-node data path on the loaded architecture object as section of Define intra-node data path explained</p> <ol> <li> <p>Check which node latency should be configured</p> <p><code>path.verify()</code> method, as shown in the following example, tells you which node latency should be defined.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('yaml', './architecture.yaml')\npath = arch.get_path('target_path')\npath.verify()\n\n---Output text as below---\nWARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/message_driven_node')\nmessage_context: null\nnode: /message_driven_node\npublish_topic_name: /topic3\nsubscribe_topic_name: /topic2\n\nWARNING : 2021-12-20 19:14:03 | Detected \"message_contest is None\". Correct these node_path definitions.\nTo see node definition and procedure,execute :\n&gt;&gt; check_procedure('yaml', '/path/to/yaml', arch, '/timer_driven_node')\nmessage_context: null\nnode: /timer_driven_node\npublish_topic_name: /topic4\nsubscribe_topic_name: /topic3\n</code></pre> <p>In the example, <code>path.verify()</code> tells you two nodes have undefined relationships of input and output.</p> <ul> <li>input <code>/topic2</code> and output <code>/topic3</code> in node <code>/message_driven_node</code></li> <li>input <code>/topic3</code> and output <code>/topic4</code> in node <code>/timer_driven_node</code></li> </ul> <p>Their relationships must be explicit with corresponding message_context items in the architecture file.</p> </li> <li> <p>Define relationship between input and output</p> <p>You have to change message_contexts items as below for the sample.</p> <pre><code># in /message_driven_node\nmessage_contexts:\n- context_type: use_latest_message # changed from 'UNDEFINED' to 'use_latest_message'\nsubscription_topic_name: /topic2\npublisher_topic_name: /topic3\n</code></pre> <pre><code># in /timer_driven_node\nmessage_contexts:\u3000\n- context_type: use_latest_message # changed from 'UNDEFINED' to 'use_latest_message'\nsubscription_topic_name: /topic3\npublisher_topic_name: /topic4\n</code></pre> </li> <li> <p>Check if node latency is defined</p> <p><code>path.verify()</code> tells you that there is no undefined node latency in the path.</p> <pre><code>from caret_analyze import Architecture\n\narch = Architecture('yaml', './architecture.yaml')\npath = arch.get_path('target_path')\npath.verify()\n</code></pre> <p>If <code>path.verify()</code> returns <code>True</code>, CARET can calculate latency of the path. Otherwise, there is any lack of definition to calculate latency.</p> </li> </ol>"},{"location":"configuration/visualize_application_structure/","title":"Visualize application structure","text":"<p>This section is not still available. dear_ros_node_viewer will be introduced.</p>"},{"location":"design/","title":"Design","text":"<p>The design section describes the internals of CARET. The following figure shows the tracing flow with each package added.</p> <p></p> <p>CARET records data, which include timestamps, from tracepoints embedded in user applications, ROS 2 and DDS. The data are stored as \"Trace Data\". CARET analyzes the Trace Data and provides the results to the developer.</p> <p>This design section describes policies and internal processes for each step listed below.</p> <p>Recording phase</p> <ol> <li> <p>Runtime processing</p> </li> <li> <p>Tracepoints</p> </li> </ol> <p>Configuration phase</p> <ol> <li>Configuration</li> </ol> <p>Analyzing phase</p> <ol> <li> <p>Processing trace data</p> </li> <li> <p>Visualization</p> </li> </ol> <p>In addition, the followings are explained.</p> <ul> <li>Software architecture</li> <li>Event and latency definition</li> <li>Limits and constraints</li> </ul> <p>See also</p> <ul> <li>CARET analyze API document</li> </ul>"},{"location":"design/configuration/","title":"Configuration","text":"<p>CARET requires several kinds of information for visualization. Configuration set up the information needed for visualization.</p> <p>Some of the information can be configured via Python API and jupyter, but there are also items that require direct modification of the architecture file.</p> <p>For the format of the architecture file, see architecture file for the format of the architecture file.</p>"},{"location":"design/configuration/architecture_file/","title":"Architecture file","text":"<p>An architecture file is a yaml file with the necessary information for visualization.</p> <p>An architecture file contains the following information</p> <ul> <li>Definition of the node-path to be measured</li> <li>Information about the structure of the software to be measured<ul> <li>Executor information</li> <li>Node information (e.g. node latency definition)</li> </ul> </li> </ul>"},{"location":"design/configuration/architecture_file/#file-format","title":"File format","text":"<p>A sample of the architecture file is as follows.</p> Key Type Required? Auto generate?  (Configuration method) Note / Description named_paths List Yes Yes Path definitions to evaluate. \u2003 path_name String Yes No (Edit via Python-API) \u2003 node_chain List Yes No (Edit via Python-API) \u2003 \u2003 node_name String Yes No (Edit via Python-API) \u2003 \u2003 publish_topic_name String Required if node is not end of the path. No (Edit via Python-API) \u2003 \u2003 subscribe_topic_name String Required if node is not start of the path. No (Edit via Python-API) executors List Yes Yes \u2003 executor_type String Yes Yes single_threaded_executor / multi_threaded_executor \u2003 executor_name String Yes Yes \u2003 callback_group_names List(String) Yes Yes nodes List Yes Yes \u2003 node_name String Yes Yes \u2003 callback_groups List Yes Yes \u2003 \u2003 callback_group_type String Yes Yes mutually_exclusive / reentrant \u2003 \u2003 callback_group_name String Yes Yes \u2003 callbacks List Yes Yes \u2003 \u2003 callback_type String Yes Yes timer_callback / subscription_callback \u2003 \u2003 symbol String Yes Yes symbol for callback function. \u2003 \u2003 period_ns int Required for timer_callback only. Yes \u2003 \u2003 topic_name String Required for subscription_callback only. Yes \u2003 \u2003 construction_order int No No Zero is used as the default value if not present. \u2003 variable_passings List No Yes \u2003 \u2003 callback_name_write String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 callback_name_read String No No (Edit architecture file) default value = UNDEFINED \u2003 publishes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_names List(String) No No (Edit architecture file) callbacks which publish the topic. \u2003 subscribes List No Yes \u2003 \u2003 topic_name String No Yes \u2003 \u2003 callback_name String No Yes \u2003 message_contexts List No Yes Field to define node latency \u2003 \u2003 context_type String No No (Edit architecture file) default value = UNDEFINED \u2003 \u2003 subscription_topic_name String No Yes \u2003 \u2003 publisher_topic_name String No Yes"},{"location":"design/configuration/architecture_file/#sample","title":"Sample","text":"<p>A sample of the architecture file is as follows.</p> <pre><code>named_paths:\n- path_name: target_path\nnode_chain:\n- node_name: /ping_node\npublish_topic_name: /chatter\nsubscribe_topic_name: UNDEFINED\n- node_name: /pong_node\npublish_topic_name: UNDEFINED\nsubscribe_topic_name: /chatter\nexecutors:\n- executor_type: single_threaded_executor\nexecutor_name: executor_0\ncallback_group_names:\n- /ping_node/callback_group_0\n- /pong_node/callback_group_0\nnodes:\n- node_name: /ping_node\ncallback_groups:\n- callback_group_type: mutually_exclusive\ncallback_group_name: /ping_node/callback_group_0\ncallback_names:\n- /ping_node/callback_0\ncallbacks:\n- callback_name: subscription_callback_0\ntype: subscription_callback\ntopic_name: /topic3\nsymbol: Node::{lambda()}\n- callback_name: timer_callback_0\ntype: timer_callback\nperiod_ns: 100000000\nsymbol: Node::{lambda()}\n- callback_name: timer_callback_0\ntype: timer_callback\nperiod_ns: 100000000\nsymbol: Node::{lambda()}\nconstruction_order: 1\nvariable_passings:\n- callback_name_write: subscription_callback_0\ncallback_name_read: timer_callback_0\npublishes:\n- topic_name: /ping\ncallback_names:\n- timer_callback_0\nsubscribes:\n- topic_name: /pong\ncallback_name: timer_callback_0\nmessage_contexts:\n- context_type: use_latest_message\nsubscription_topic_name: /pong\npublisher_topic_name: /ping\n</code></pre>"},{"location":"design/configuration/architecture_file/#callback-identification","title":"Callback identification","text":"<p>It's convenient for users to give a name to a callback function for its identification. However, in the context of ROS 2, only an address is given to a callback.</p> <p>Addresses change with each launch of an application. This makes it difficult to handle callbacks by address when evaluating performance of them. For example, if you want to compare the execution time of a particular callback for each launch, you have to find address to select target callbacks.</p> <p>CARET helps users to give a name to a callback, but it is not directly associated with its address due to the reason as explained above.</p> <p>In order to tackle the issue, CARET associates a name with an address of callback with using combination of following data.</p> <ul> <li><code>node_name</code></li> <li><code>callback_type</code></li> <li><code>period_ns</code> / <code>topic_name</code></li> <li><code>symbol</code></li> <li><code>construction_order</code></li> </ul> <p>By using this information to match <code>callback_name</code> and callback address, each <code>callback_name</code> will always refer to identical callbacks without being aware of callback address.</p>"},{"location":"design/event_and_latency_definitions/","title":"Latency definition","text":"<p>CARET mainly measures the following</p> <ul> <li>Callback latency</li> <li>Communication latency</li> <li>Node latency</li> <li>Path latency</li> </ul> <p>The simplified sequence diagram shown below illustrates each definition.</p> <p></p> <p>Here, the horizontal axis represents time and the vertical axis represents layers. The red line represents message flow. A message is received in the subscription callback and the processed data is published to the next node. In this way, information is propagated from the sensor node to the actuator node.</p> <p>CARET samples events for latency calculation. The following three items are main types of the events.</p> <ul> <li>Callback start</li> <li>Callback end</li> <li>Publish</li> </ul> <p>Difference of timestamp between two events are corresponded to latency.</p> <p>For a more detailed definition, see</p> <ul> <li>Callback</li> <li>Communication</li> <li>Node</li> <li>Path</li> </ul> <p>CARET provides time series data of events through Python objects. Time series data can be retrieved with the Python objects which have to_dataframe API. All objects are capable of retrieving time-series data are listed below.</p> Target Configuration required? Path Yes Node Yes Communication No Callback No Publisher No Subscription No Timer No <p>Here, for Path and Node, definitions must be given manually. For details on setting the definitions, see Configuration.</p>"},{"location":"design/event_and_latency_definitions/#detailed-sequence","title":"Detailed Sequence","text":"<p>Below is a detailed sequence diagram of the SingleThreadedExecutor, from publish in the callback to the execution of the subscription callback.</p> <p></p> <p>Here, each element indicates the following</p> <ul> <li>UserCode is a callback</li> <li>ROS2 is rclcpp, rcl, and rmw</li> <li>DDS is FastDDS or CycloneDDS</li> <li>LTTng is the output destination for tracepoints</li> </ul> <p>Within the spin of Subscription, the executable callbacks are executed sequentially.</p> <p>In this way, the executor schedules callbacks. If there are multiple executable callbacks, they are executed sequentially, so other callbacks may have to wait.</p> <p> <p>Info</p> <p>There have been many different proposals for schedulers, and the information provided above may not be up-to-date.   Please keep in mind that system performance will vary depending on the scheduler you choose.</p> <p>"},{"location":"design/event_and_latency_definitions/callback/","title":"Callback","text":"<p>Callback latency is defined as duration between beginning and end of callback execution. These events are represented as <code>callback_start</code> and <code>callback_end</code>, respectively.</p>  l_{\\rm{callback}} = t_{\\rm{callback\\ end}} - t_{\\rm{callback\\ start}}  <p>The sequence diagram shows how CARET rclcpp picks up two events; callback_start and callback_end.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description callback_start System time Callback start time callback_end System time Callback end time <p>See also</p> <ul> <li>Trace points | Callback Start</li> <li>Trace points | Callback End</li> <li>RuntimeDataProvider API</li> </ul>"},{"location":"design/event_and_latency_definitions/communication/","title":"Communication","text":"<p>Communication latency is an expression of how much time it takes for a topic message to travel from source callback to next callback.</p>  l_{comm} = t_{sub} - t_{pub}  <p> <p>Info<p>In this definition, communication latency is affected by the scheduling of callbacks, and includes not only the communication latency of the DDS, but also the delay due to scheduling. For example, if multiple callbacks are dispatched simultaneously, the communication latency may include the execution time of other callbacks. For more information on scheduling, see Event and latency_definitions | overview.</p> </p> <p> <p>ROS communication is performed by the subscription side for intra-process communication and inter-process communication. Since ROS communication is capable of many-to-many communication, there are cases where both intra-process and inter-process communication are performed in a single publish. In CARET, communication is divided into 1:1 pairs and latency is calculated.</p>"},{"location":"design/event_and_latency_definitions/communication/#intra-process-communication","title":"Intra process communication","text":"<p>A simplified sequence diagram focusing only on the relevant data flow is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. callback_start_timestamp System time Callback start time <p>See also</p> <ul> <li>Trace points | rclcpp_intra_publish</li> <li>Trace points | dispatch_intra_process_subscription_callback</li> <li>Trace points | callback start</li> <li>Trace points | message_construct</li> <li>RuntimeDataProvider API</li> </ul>"},{"location":"design/event_and_latency_definitions/communication/#inter-process-communication","title":"Inter process communication","text":"<p>A simplified sequence diagram focusing only on the relevant data flow is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description rclcpp_publish_timestamp System time Publish time in rclcpp. rcl_publish_timestamp System time Publish time in rcl. dds_write_timestamp System time Publish time in rmw. callback_start_timestamp System time Callback start time. <p>See also</p> <ul> <li>Trace points | message_construct</li> <li>Trace points | rclcpp_publish</li> <li>Trace points | rcl_publish</li> <li>Trace points | dds_write</li> <li>Trace points | bind_addr_to_addr</li> <li>Trace points | bind_addr_to_stamp</li> <li>Trace points | callback start</li> <li>Trace points | dispatch_subscription_callback</li> <li>RuntimeDataProvider API</li> </ul>"},{"location":"design/event_and_latency_definitions/node/","title":"Node","text":"<p>Node latency is elapsed time from message reception to message transmission in a node.</p>  l_{node} = t_{transfer} - t_{receive}  <p>As transmission is replaced by publish and reception is subscription in the context of ROS 2, the equation is translated into the next one.</p>  l_{node} = t_{pub} - t_{sub}   l_{node} = t_{pub} - t_{sub}"},{"location":"design/event_and_latency_definitions/node/#message-context","title":"Message context","text":"<p>A node receives a message, processes it, and then publishes it to a subsequent node. The dependency between the subscribed and published messages is used to define node latency. In the following sections explain the message dependency (message context), which is the concept of node latency.</p> <p>For example, consider the following callback.</p> <pre><code>auto subsription_callback = [](&amp;msg){\nmsg_ = f(msg);\npub.publish(msg_);\n}\n</code></pre> <p>In this case, the received message is processed and published immediately. The dependency of the message at this time is described in chronological order and is expressed as follows.</p> <p></p> <p>Here, the elapsed time from subscription to publish is defined as node latency. In this way, node latency can be calculated when message dependencies are defined.</p> <p>In the previous example, we presented a case where a node is subscribed and immediately published. Actually, the message context can be quite complex because data processing in a node is freely defined by application developers.</p> <p></p> <p>Examples of complex message context are described below.</p> <ul> <li>Buffered, for example, is a buffer delay process.</li> <li>Multiple inputted is for moving average processing, for example. There are multiple candidates for node latency.</li> <li>Unused is a message that has not been published and has not been used. This is evaluated as a kind of message drop.</li> <li>Crossed can occur in cases where messages are retrieved based on the timestamp of the message rather than the system time.</li> </ul> <p>In any of those cases, it is difficult to automatically determine the message context.</p> <p>the message context are given for some cases of them as shown in configuration. For more information, see Configuration for details.</p> <p>To enlarge coverage the others of complex cases, we are considering a mechanism to allow users to describe message dependencies in their user codes. TILDE is one of good candidates to achieve it.</p>"},{"location":"design/event_and_latency_definitions/path/","title":"Path","text":"<p>Path latency is sum of node latency and communication latency included in a certain path. Path represents data flow which is constructed of multiple nodes connected each other.</p>  l_{path} = \\sum_{\\in path} l_{node} + \\sum_{\\in path} l_{comm} \\\\ l_{node} = t_{pub} - t_{sub} \\\\ l_{comm} = t_{sub} - t_{pub} \\\\  <p>In CARET, the path is defined as <code>[node_name]-[topic_name]-... -[topic_name]-[node_name]</code>. For example, in the following case, the path definition is <code>[A]-[/a]-[C]-[/e]-[E]</code>.</p> <p></p> <p> <p>Info</p> <p>In the above definition, the star time of the latency is publish of the initial node and the end time of the latency is subscription of the last node. When trying to measure a actual system, it is desirable to be able to define various start and end times depending on the implementation. For example, the start time might be more appropriately a stamp value in the sensor message. It's current issue to support for such more precise latency.</p> <p>"},{"location":"design/event_and_latency_definitions/publisher/","title":"Publisher","text":"<p><code>Publisher</code>-based object provides a set of timestamps collected during message publish.</p> <p>A simplified sequence diagram focusing only on the relevant events is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description rclcpp_publish_timestamp System time min(rclcpp_intra_publish_timestamp, rclcpp_publish_timestamp) rclcpp_intra_publish_timestamp System time (Optional) Publish time of intra-process communication rclcpp_publish_timestamp System time (Optional) Publish time of inter-process communication in rclcpp rcl_publish_timestamp System time(Optional) Publish time of inter-process communication in rcl dds_write_timestamp System time(Optional) Publish time of inter-process communication in rmw message_timestamp Message data Time of header.stamp. Zero when header is not defined. source timestamp Depends on DDS (Optional) Timestamp to used for binding with subscription. <p>See also</p> <ul> <li>Trace points | rclcpp_intra_publish</li> <li>Trace points | message_construct</li> <li>Trace points | rclcpp_publish</li> <li>Trace points | rcl_publish</li> <li>Trace points | dds_write</li> <li>Trace points | bind_addr_to_addr</li> <li>Trace points | bind_addr_to_stamp</li> </ul>"},{"location":"design/event_and_latency_definitions/subscription/","title":"Subscription","text":"<p>Topic message is received by subscription via inter-process communication or intra-process one. Then, <code>Subscription</code> object has common data fields, but different value is filled in <code>source_timestamp</code> field.</p>"},{"location":"design/event_and_latency_definitions/subscription/#inter-process-communication","title":"Inter process communication","text":"<p>A simplified sequence diagram focusing only on the relevant events is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS Timestamp to used for binding with subscription. <p>See also</p> <ul> <li>Subscription API</li> <li>Trace points | dispatch_subscription_callback</li> <li>Trace points | callback_start</li> </ul>"},{"location":"design/event_and_latency_definitions/subscription/#intra-process-communication","title":"Intra process communication","text":"<p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description callback_start_timestamp System time Callback start time message_timestamp Message data Time of header.stamp. Zero when header is not defined. source_timestamp Depends on DDS (Optional) NaN. <p>See also</p> <ul> <li>Subscription API</li> <li>Trace points | dispatch_intra_process_subscription_callback</li> <li>Trace points | callback_start</li> </ul>"},{"location":"design/event_and_latency_definitions/timer/","title":"Timer","text":"<p>Timer provides the time at which the Timer callback timeout and related information.</p> <p>A simplified sequence diagram focusing only on the relevant events is shown below.</p> <p></p> <p><code>to_dataframe</code> API returns a table which has the following columns.</p> Column Type Description timer_event_timestamp System time Timer timeout. callback_start_timestamp System time Callback start time callback_end_timestamp System time Callback end time <p>Here, the timer firing time is calculated by the following,</p>  t_{timeout} = t_{init} + n \\times t_{period}  <p>See also</p> <ul> <li>Timer API</li> <li>Trace point | callback_start</li> <li>Trace point | callback_end</li> <li>Trace point | rcl_timer_init</li> </ul>"},{"location":"design/limits_and_constraints/","title":"Limits and constraints","text":""},{"location":"design/limits_and_constraints/#environment","title":"Environment","text":"<p>CARET only supports environments as follows.</p> <ul> <li>Support single host.</li> <li>FastDDS or CycloneDDS.</li> <li>Support for Linux.</li> <li>Support for Galactic and Humble.</li> <li>Require rebuilding of an application.</li> </ul>"},{"location":"design/limits_and_constraints/#ros-2-functions","title":"ROS 2 functions","text":"<p>CARET cannot support functions as follows.</p> <ul> <li>/rosout and /parameter_event topic</li> <li>Services</li> <li>Actions</li> </ul>"},{"location":"design/limits_and_constraints/#implementation","title":"Implementation","text":"<p>CARET cannot support implementations as follows.</p> <ul> <li>There exist several nodes which have the same namespace and node name.</li> <li>wrapper for ROS layers.</li> <li>Reentrant callback group.</li> </ul>"},{"location":"design/processing_trace_data/","title":"Processing trace data","text":"<p>CARET processes Trace Data to provide latency to the user. This section describes the Trace Data processing process.</p> <p>The class that reads TraceData is the Records object.</p> <ul> <li>Records</li> </ul> <p>The following are processing using Records object.</p> <ul> <li>Period</li> <li>Frequency</li> <li>Latency</li> <li>Response time</li> </ul> <p>See also</p> <ul> <li>Event and latency definition</li> <li>caret_analyze</li> <li>Software architecture | caret_analyze</li> </ul>"},{"location":"design/processing_trace_data/records/","title":"Records Object","text":"<p>CARET provides trace data to user. The common format is a table per metric as shown below.</p> callback_start_timestamp callback_end_timestamp 0 0.1 1 1.1 2 2.1 ... ... <p>This table is referred to calculate latency, period, and etc. (See Records Service). The most primitive format is a table per event which picked up by a corresponding tracepoint. Merging multiple event tables makes a new table for metrics. In addition to simple table merging, CARET defines classes which has originally defined merging method for latency calculation.</p> <p>This sections describes the main APIs provided by the record object.</p> <ul> <li>merge</li> <li>merge_sequential</li> <li>merge_sequential_for_addr_track</li> <li>to_dataframe</li> </ul>"},{"location":"design/processing_trace_data/records/#merge","title":"merge","text":"<p>This is an inner join and outer join of general tables. In particular, it is used to join initialization-related trace data that can be bound by address only.</p> <p>See also</p> <ul> <li>API:merge</li> </ul>"},{"location":"design/processing_trace_data/records/#merge_sequential","title":"merge_sequential","text":"<p>This is a chronological merge. It is especially used to merge sequential processing by threads.</p> <p>CARET mainly performs this merging and calculates latency.</p> <p>See also</p> <ul> <li>API:merge</li> <li>Callback Latency Definition</li> </ul>"},{"location":"design/processing_trace_data/records/#merge_sequential_for_addr_track","title":"merge_sequential_for_addr_track","text":"<p>This merge is used when binding is done based on addresses and copying occurs in the middle of the process.</p> <p>See also</p> <ul> <li>API:merge_sequential_for_addr_track</li> </ul> <p> <p>Warning</p> <p>This merge is slow and causes inconsistencies when nodes not using caret-rclcpp are published. As much as possible, trace points should be designed so that merge_sequential is sufficient.</p> <p>"},{"location":"design/processing_trace_data/records/#to_dataframe","title":"to_dataframe","text":"<p>Function to convert to a pandas.DataFrame. This is especially useful for unique visualization and evaluation by developers.</p>"},{"location":"design/processing_trace_data/records_service/","title":"Records service","text":"<p>The Records object holds time-series data such as message flow in a table as shown below.</p> Start timestamp ... End timestamp 0.0 ... 0.1 1.0 ... 1.1 2.0 ... NaN 3.0 ... 2.1 ... ... ... <p>The start timestamp column contains the system time at the starting point. The end timestamp column contains the system time at the end point. Both columns indicate the system time, and if there is no corresponding value for start, the value is NaN.</p> <p>For the intermediate columns, the time at the intermediate point between starting point and end one is represented.</p> <p>This table representation can be used for various measurement targets such as callbacks, nodes, and paths.</p> <p>The rows of the table are visualized as lines in a message flow diagram.</p> <p>The above table is stored by <code>Records</code> object.</p> <ul> <li>Records</li> </ul> <p>The followings are processing using Records object.</p> <ul> <li>Period</li> <li>Frequency</li> <li>Latency</li> <li>Response time</li> </ul> <p>See also</p> <ul> <li>Event and latency definition</li> </ul> <p>See also</p> <ul> <li>Records</li> </ul>"},{"location":"design/processing_trace_data/records_service/#period","title":"Period","text":"<p>Period is metrics defined as the elapsed time between two occurrence of cyclic events. Difference between two neighboring timestamp on the same column is defined as period.</p>      period_n = t_{n} -t_{n-1}"},{"location":"design/processing_trace_data/records_service/#example","title":"Example","text":"<p>Input</p> Start timestamp 0.0 1.0 2.0 3.0 ... <p>Output</p> Timestamp Period 0.0 1.0 1.0 1.0 2.0 1.0 ... ... <p>See also</p> <ul> <li>API Reference | Period</li> </ul>"},{"location":"design/processing_trace_data/records_service/#frequency","title":"Frequency","text":"<p>Frequency is defined as the number of events that occur in one second.</p>"},{"location":"design/processing_trace_data/records_service/#example_1","title":"Example","text":"<p>Input</p> Start timestamp 0.0 0.1 0.5 1.2 1.3 2.3 ... <p>Output</p> Timestamp Period 0.0 3.0 1.0 2.0 ... ..."},{"location":"design/processing_trace_data/records_service/#latency","title":"Latency","text":"<p>Latency is is length of time from preceding event to afterward one. It is defined as difference from preceding timestamp to afterward on the same row.</p>  latency_n = t^{end}_{n} - t^{start}_{n}   latency_n = t^{end}_{n} - t^{start}_{n}"},{"location":"design/processing_trace_data/records_service/#example_2","title":"Example","text":"<p>Input</p> Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.1 ... ... <p>Output</p> Start timestamp Latency 0.0 0.1 1.0 0.1 3.0 0.1 ... ..."},{"location":"design/processing_trace_data/records_service/#response-time","title":"Response Time","text":"<p>Response time is amount of time it takes for a system to respond to an input.</p> <p>As shown above, latency can be calculated if a table is constructed. Latency is defined as delay from input to any output. This calculation is very simple, but it is not used for evaluating response. If multiple output depends on a single input, latency is not regarded as response time. Moreover, for example, if a sensor is driven at 10 Hz, a latency of up to 100 ms should be considered.</p> <p>CARET serves best-case response time and worst-case response time. The former is roughly equal to latency from an input to a corresponding initial output. CARET provides the latter because it also takes into account the latency until times wake up. For example, this latency is equivalent to a sensor operating at 10 Hz taking a 100 ms delay at maximum.</p>"},{"location":"design/processing_trace_data/records_service/#example_3","title":"Example","text":"<p>Input</p> Start timestamp End timestamp 0.0 0.1 1.0 1.1 2.0 NaN 3.0 3.2 4.0 4.3 ... ... <p>Intermediate Create intermediate data for when the interval in Start timestamp [0.0, 4.0] maps to End timestamp.</p> Start timestamp End timestamp [0.0, 1.0) 1.1 [1.0, 3.0) 3.2 [3.0, 4.0) 4.3 <p>Output</p> Start timestamp Best-case response time Worst-case response time 1.0 0.1 (1.1 - 1.0) 1.1 (1.1 - 0.0) 3.0 0.2 (3.2 - 3.0) 2.3 (3.2 - 1.0) ... ... ... <p>Note that best case response time is equal to Latency, except for the cumbersome cases listed later.</p> <p>Worst-case response time also counts as response time in the case of a drop.</p>"},{"location":"design/processing_trace_data/records_service/#visualize-response-time","title":"Visualize response time","text":"<p>Of the pseudo two message flow diagram as shown above, the upper figure shows latency and the lower explains response time. The upper figure includes cumbersome cases as follows;</p> <ul> <li>Cases where multiple latencies are defined for a single output from multiple inputs</li> <li>Message dropping</li> <li>Crossing</li> <li>Branching</li> </ul> <p>Some of these can be pessimistically large when it comes to latency.</p> <p>The diagram above describes the table as follows</p> Start timestamp End timestamp 0.0 2.0 0.5 2.5 2.0 3.5 3.0 3.5 4.0 5.0 4.5 7.0 5.5 6.0 5.5 6.5 <p>After extracting only the best case flows as shown in the lower figure, the best case is calculated as the latency of the flow and the worst-case as the latency is regarded as delay from the previous input to the output.</p> <p>According to those definitions, the response time is calculated as below.</p> Start timestamp Min response time Max response time 0.0 2.0 2.5 0.5 0.5 3.0 3.0 1.0 2.0 4.0 0.5 2.0 <p>See also</p> <ul> <li>FAQ | How response time is calculated?</li> </ul>"},{"location":"design/runtime_processing/","title":"Runtime processing","text":"<p>CARET process followings at runtime.</p> <ul> <li>Adds trace points via hooks</li> <li>Filter unnecessary trace points</li> </ul> <p>Though LTTng provides a variety of functions, CARET specializes ROS-aware functionality.</p> <p>See also</p> <ul> <li>Tracepoint</li> </ul>"},{"location":"design/runtime_processing/hook/","title":"Hook","text":"<p>Hooking is one of the key techniques performed by CARET. This section describes hooks from CARET's point of view.</p> <p>See also</p> <ul> <li>CARET_trace</li> </ul>"},{"location":"design/runtime_processing/hook/#advantage-of-hook","title":"Advantage of Hook","text":"<p>ROS 2 is being developed separately from DDS thanks to RMW. On the other hand, each implementation may be developed for different purposes, which makes it difficult to achieve consistent evaluation of all layers, including DDS. CARET handles these layers across by hooks to add and manage trace points consistently.</p> <p></p> <p>See also</p> <ul> <li>Tracepoints definition</li> </ul> <p> <p>Info</p> <p>If possible, it is better to add tracepoints as built-in rather than hooks for users. However, CARET's priority is to evaluate software running on the current version of ROS rather than to gradually add trace points. For this reason, we have adopted a hook that allows users to add tracepoints in a flexible manner.</p> <p> <p> <p>Info</p> <p>The advantage of being able to handle all layers across the board is not well utilized in the current CARET. In the future, we plan to use thread local memory to reduce trace points.</p> <p>"},{"location":"design/runtime_processing/hook/#ld_preload","title":"LD_PRELOAD","text":""},{"location":"design/runtime_processing/hook/#advantage-of-ld_preload","title":"Advantage of LD_PRELOAD","text":"<p>LD_PRELOAD can be hooked even if the function is not exposed externally as an API.</p> <p>The trace points themselves, which are built into the ROS layer, can also be hooked. This enables trace filtering.</p> <p>Though you might come up with using eBPF to hook, eBPF requires a context switch from user space to kernel space. Hooking with LD_PRELOAD can be completed in user space, reducing the overhead.</p> <p>See also</p> <ul> <li>Tracepoint filtering</li> </ul>"},{"location":"design/runtime_processing/hook/#limits-of-ld_preload","title":"Limits of LD_PRELOAD","text":"<p>There are some cases that cannot or are difficult to hook with LD_PRELOAD.</p> <ul> <li>Functions with many symbols by cpp template</li> <li>Hooks for functions that are expanded as inline code</li> <li>Hooks for functions implemented in headers</li> </ul> <p>Specifically, intra-process publish cannot be hooked by LD_PRELOAD. In CARET, trace points for intra-process communication are added in the forked rclcpp.</p>"},{"location":"design/runtime_processing/tracepoint_filtering/","title":"Tracepoint filtering","text":"<p>When measuring a system composed of many nodes, such as Autoware, the amount of data from tracing can be very large.</p> <p>Trace data discarding occurs during a large amount of recording because Lttng is discard mode to minimize effect to the system.</p> <p>CARET provides the ability to disable trace points associated with specific topics or nodes. This makes it possible to exclude from recording only trace data related to rviz nodes or tf topics, allowing CARET measurements even on large systems.</p> <p>This filtering function looks at the instance addresses (e.g. callback or publisher) to see if they are included in the filter. This check is done in O1 order because it uses std::unordered_map.</p> <pre><code>void ros_trace_callback_start(const void * callback, bool is_intra_process) {\nstatic auto &amp; controller = Singleton&lt;TracingController&gt;::get_instance();\n\n// Record trace data only if current callback is allowed to record\nif (controller.is_allowed_callback(callback)) {\nORIG_FUNC::ros_trace_callback_start(callback, is_intra_process);\n}\n}\n</code></pre> <p>See also</p> <ul> <li>caret_trace</li> <li>Tracepoint</li> <li>Recording trace filtering</li> </ul>"},{"location":"design/software_architecture/","title":"Software architecture","text":"<p>This section explains an overview of software architecture.</p> <p></p> <p>CARET is divided into three phases; recording phase, configuration phase and analyzing phase.</p>"},{"location":"design/software_architecture/#recording-phase","title":"Recording Phase","text":"<p>In the recording phase, CARET records system execution data from tracepoints.</p> <p>In addition to the tracepoints built into ROS2, CARET adds tracepoints by several methods; CARET_trace CARET_rclcpp and TILDE. For flexibility in adding tracepoints, tracepoints are added by hooks as possible. Only if it is not possible to add tracepoints by hooks, tracepoints are added by other methods as a supplementary method.</p> <p>All recorded data is stored as TraceData and used in the analyzing phase.</p> <p>CARET utilizes LTTng as a trace mechanism.</p> <p>In CARET, packages related to recording phase are followings.</p> <ul> <li>caret_trace</li> <li>TILDE</li> </ul> <p>See also</p> <ul> <li>Tracepoints</li> <li>Runtime Processing</li> <li>The LTTng Documentation</li> </ul>"},{"location":"design/software_architecture/#configuration-phase","title":"Configuration Phase","text":"<p>In the configuration phase, CARET needs configurations to calculate latency.</p> <p>Some of the configurations can be defined via the Python API. Configuration can be saved as a YAML file (Architecture file) and edited. The architecture file is used repeatedly in the analyzing phase.</p> <p>In CARET, packages related to configuration phase are followings.</p> <ul> <li>caret_analyze</li> </ul> <p>See also</p> <ul> <li>Configuration</li> </ul>"},{"location":"design/software_architecture/#analyzing-phase","title":"Analyzing Phase","text":"<p>In analyzing phase, CARET analyzes trace data to provide system execution information.</p> <p>CARET_analyze provides a Python class that can access a variety of time series information. Developers can get the necessary information for evaluation from this class and perform evaluation according to their objectives.</p> <p>CARET_analyze also provides visualizations for the evaluation of Jupyter.</p> <p>In CARET, packages related to configuration phase are followings.</p> <ul> <li>caret_analyze</li> </ul> <p>See also</p> <ul> <li>Processing trace data</li> <li>Event and latency definitions</li> <li>Bokeh</li> </ul>"},{"location":"design/software_architecture/#ros-2-packages","title":"ROS 2 Packages","text":"<p>The followings are CARET-related packages.</p> Package Role Repository CARET_trace Add trace points via hooks. Control tracepoints. https://github.com/tier4/CARET_trace/ CARET_rclcpp Add trace points by fork https://github.com/tier4/rclcpp ros2caret Provide CARET CLI https://github.com/tier4/ros2caret/ CARET_analyze Analyze trace data https://github.com/tier4/CARET_analyze/ CARET_analyze_cpp_impl Accelerate CARET_analyze https://github.com/tier4/CARET_analyze_cpp_impl/ TILDE Add tracepoints within the system to be measure https://github.com/tier4/TILDE"},{"location":"design/software_architecture/caret_analyze/","title":"CARET_analyze","text":"<p>caret_analyze is a package that loads trace data and architecture files and provides Python APIs for configuration and evaluation.</p> <p>See CARET analyze API document for the API of each class.</p> <p>The following figure shows data flow in CARET_analyze.</p> <p></p> <p>Trace data is divided into two sections by CARET_analyze after loading trace data; Architecture and Runtime Data.</p> <p>The architecture object includes descriptions of the target application's structure. This object can be reused unless the structure of the target application or names of the components is changed.</p> <p>Runtime Data object has data sampled during the execution of the target application. The sampled data includes timestamps, whose values are different per execution, obtained from tracepoints. Runtime data is combined with architecture and provided to developers via Python-API which is easy to evaluate.</p> <p>Architecture object and Runtime Data object are implemented as Python classes. The structure of their classes is designed based on the structure of ROS applications which are constructed of executors, nodes, callback functions, and topic messages. ROS-based structure makes CARET's API friendly for ROS users.</p> <p>CARET_analyze is composed of several python packages. Each python packages are as follows.</p> python package role architecture Load and configure Architecture runtime Provide execution data value_objects collection of value objects plot Visualization helpers records implement records common common procedure infra import outer files <p>Role for each component is as follows.</p> <p></p> <p>Architecture object provides APIs to search node paths and define node latency as mentioned in configuration chapter. The architecture object is reusable after it is saved as a YAML-based file called \"architecture file\".</p> <p>Runtime Data object provides APIs to retrieve <code>pandas.DataFrame</code>-based objects including callback latency or communication. Users can analyze temporal aspects of their applications, with visualization, as they expect. APIs for visualization are also served by CARET_analyze which plays the main role to analyze trace data.</p> <p>In the following sections, each package will be explained in more detail.</p>"},{"location":"design/software_architecture/caret_analyze/#architecture","title":"architecture","text":"<p>In architecture, an instance is created with the following structure. This allows access to the necessary information from the top-level Architecture class.</p> <p>Purpose of Architecture:</p> <ul> <li>Define static information to be used in Analyze</li> </ul> <p> <p>Info</p> <p>\"Model\" might be more appropriate than the name \"Architecture\".   Architecture describes all the parameters related to scheduling, such as scheduling and core migration.   Therefore, we're thinking that the architecture can be used for design based on scheduling theory.</p> <p> <p></p> <p>All information retrieved from the Architecture file is of type ValueObject, which is suitable for interfacing information between other packages.</p>"},{"location":"design/software_architecture/caret_analyze/#runtime","title":"runtime","text":"<p>The runtime, which also includes trace results, follows the architecture structure and adds a function to calculate the measurement results.</p> <p></p> <p>There are classes that can calculate latency and classes as collections. The following is a list of each class and the classes which can calculate latency.</p> Class API has latency definition? Application API list No Executor API list No Node API list No Path API list Yes (Definitions) NodePath API list Yes (Definitions) Communication API list Yes (Definitions) Timer API list Yes (Definitions) Subscription API list Yes (Definitions) Callback API list Yes (Definitions)"},{"location":"design/software_architecture/caret_analyze/#value_objects","title":"value_objects","text":"<p>ValueObjects define classes with equivalence. The Value class has the information for binding, and the StructValue class has the structure of multiple classes after binding.</p>"},{"location":"design/software_architecture/caret_analyze/#plot","title":"plot","text":"<p>There are classes associated with the display. The visualization provided by CARET_analyze is based on bokeh and graphviz.</p>"},{"location":"design/software_architecture/caret_analyze/#records","title":"records","text":"<p>In CARET, latency is calculated by joining process of tables uniquely defined. The records package defines tables with their own join processing.</p> <p>See also</p> <ul> <li>Records</li> </ul>"},{"location":"design/software_architecture/caret_analyze/#common","title":"common","text":"<p>Common package implements individual processes are described that can be handled as common in each package.</p>"},{"location":"design/software_architecture/caret_analyze/#infra","title":"infra","text":"<p>Infra package implements the process of reading from the outside.</p> <p>It contains YAML and Lttng which implement ArchitectureReader/RuntimeDataProvider respectively.</p>"},{"location":"design/software_architecture/caret_trace/","title":"caret_trace","text":"<p>caret_trace is a package that handles recording such as adding trace points.</p> <p>The role of caret_trace is as follows</p> <ul> <li>Race Point Definition</li> <li>Adding Tracepoints with Hooks</li> <li>trace filtering</li> <li>simtime recording</li> </ul> <p>See also</p> <ul> <li>Tracepoints</li> <li>Hook</li> </ul>"},{"location":"design/software_architecture/caret_trace/#class-structure","title":"Class Structure","text":""},{"location":"design/software_architecture/caret_trace/#hook-function-implementation","title":"Hook function implementation","text":"<p>In addition to hooking and for adding trace points, CARET also hooks trace points built into ROS2.</p> <p>Here is an example of a typical hook implementation.</p> <pre><code>void ros_trace_rcl_node_init(\nconst void * node_handle,\nconst void * rmw_handle,\nconst char * node_name,\nconst char * node_namespace)\n{\nstatic auto &amp; controller = Singleton&lt;TracingController&gt;::get_instance();\n\n// Bind node handle and node name\ncontroller.add_node(node_handle, ns + node_name);\n\n// Record trace data only if current node is allowed to record\nif (controller.is_allowed_node(node_handle)) {\nORIG_FUNC::ros_trace_rcl_node_init)(node_handle, rmw_handle, node_name, node_namespace);\n}\n}\n\nvoid ros_trace_callback_start(const void * callback, bool is_intra_process) {\nstatic auto &amp; controller = Singleton&lt;TracingController&gt;::get_instance();\n\n// Record trace data only if current callback is allowed to record\nif (controller.is_allowed_callback(callback)) {\nORIG_FUNC::ros_trace_callback_start(callback, is_intra_process);\n}\n}\n</code></pre> <p>Here, debugging logs and other information are omitted.</p> <p>Information from callback addresses to node names, etc., can be obtained by binding them to other trace point information. See Initialization trace points for details.</p>"},{"location":"design/software_architecture/caret_trace/#clock-recorder","title":"clock recorder","text":"<p>CARET can select simtime for visualization. The simtime can be recorded by running the simtime_recorder node, which adds trace points for simtime recording.</p> <pre><code>ros2 run caret_trace clock_recorder\n</code></pre> <p>ClockRecorder node wakes up every second and records simtime and system time. The recorded results are used to calculate simtime from system time.</p>"},{"location":"design/software_architecture/tilde/","title":"TILDE, a framework tools to detect deadline overrun","text":"<p>CARET can cooperate with TILDE, a framework tool to detect deadline overrun. TILDE lets CARET trace events in user applications which cannot be traced from ROS/DDS layer.</p> <p> <p>Notice<p>TILDE is now under development.</p> </p> <p> <p>Since ROS nodes can implement arbitrary processing, some nodes are difficult to calculate node latency.</p> <p>Examples of implementations for which node latency is difficult to calculate are as follows.</p> <ul> <li>Message buffering case between subscribe and publish</li> <li>Using message filter case</li> </ul> <p>the latencies can be observed in only application layer, but CARET cannot observe the events.</p> <p>On the other hand, TILDE can trace application-layer events. It is able to trace execution of callback function to consume a certain buffered message since it annotate message consumption per single message.</p> <p>TILDE serves CARET this capability to trace consumption of buffered messages.</p> <p>See also</p> <ul> <li>TILDE official page</li> <li>Node latency definition</li> </ul>"},{"location":"design/trace_points/","title":"Tracepoints definition","text":"<p>This section lists all tracepoints and their definition.</p> <p>Some tracepoints are used for collecting identification of executors, nodes, callbacks, and topics during application's initialization. They are called initialization tracepoints. The other tracepoints are embedded for sampling timestamps after completion of initialization, and called runtime tracepoints.</p> <p>Each tracepoint for CARET is added by followings method.</p> <p></p> <ul> <li>Built-in tracepoints<ul> <li>tracepoints embedded in original ROS 2 middleware which are utilized by ros2-tracing</li> <li>some of tracepoints, for service, action and lifecycle node, are not utilized by current CARET</li> </ul> </li> <li>Hooked tracepoints<ul> <li>CARET-dedicated tracepoints introduced by function hooking with LD_PRELOAD</li> </ul> </li> <li>Extended tracepoints<ul> <li>CARET-dedicated tracepoints added to the fork of rclcpp</li> </ul> </li> </ul> <p>CARET utilizes some of the tracepoints built-in original ROS 2. Some of the tracepoints are added by hooking with LD_PRELOAD, and rest trace points are added to the fork of ROS 2's rclcpp.</p> <p> <p>Info</p> <p>Please read this section if you are interested in CARET-dedicated tracepoints are extended by the forked rclcpp and LD_PRELOAD. CARET would like to add tracepoints by function hooking as possible. LD_PRELOAD is reasonable to hook functions defined in dynamic library, but it cannot be applied to functions by implemented with C++ template. Such template-based implementation is mapped into binary file after it is built or compiled. Builtin rclcpp uses C++ template for some functions like intra-process communication, for example. The forked rclcpp is introduced to add tracepoints to the functions.</p> <p>"},{"location":"design/trace_points/diff/","title":"Differences from original ROS","text":""},{"location":"design/trace_points/diff/#v02-vs-galactic","title":"v0.2 vs galactic","text":"<p>In addition to the caret repository, caret.repos contains the following repositories</p> <ul> <li>https://github.com/ros2/rcl.git</li> <li>https://github.com/tier4/rclcpp/tree/galactic_tracepoint_added</li> <li>https://github.com/tier4/ros2_tracing/tree/galactic_tracepoint_added</li> </ul> <p>This section describes the differences between each repository.</p>"},{"location":"design/trace_points/diff/#rcl","title":"rcl","text":"<p>No source code changes. Cloning this package is for enabling built-in trace points by rebuilding.</p>"},{"location":"design/trace_points/diff/#rclcpp","title":"rclcpp","text":"<p>This cloning is for adding trace point which cannot added by LD_PRELOAD.</p> <p>See also</p> <ul> <li>Tracepoints</li> </ul> <p>It's needed to add include directory of ros2_tracing.</p> <p> <p>Info</p> <p>Reason to add include files of ros2_tracing to rclcpp. LD_PRELOAD allows custom shared libraries to be loaded with priority immediately after the start of execution. On the other hand, tracepoints added to the header as described above require that the tracepoint-added version of the header be loaded first during header searching at build time. An include file is added to ensure that this priority is as expected. When the merging of tracepoints to the ros2 mainframe, the addition of the ros2_tracing include file to rclcpp is not necessary.</p> <p>"},{"location":"design/trace_points/diff/#ros2_tracing","title":"ros2_tracing","text":"<p>This cloning is for defining tracepoints added to rclcpp.</p>"},{"location":"design/trace_points/diff/#v03-vs-humble","title":"v0.3 vs humble","text":"<p>In v0.3, the trace points used in the galactic version of CARET have been ported. Some tracepoints have been added in humble, but they are not currently supported. These tracepoints will be supported in a future version.</p>"},{"location":"design/trace_points/initialization_trace_points/","title":"Initialization trace points","text":"<p>Some tracepoints share same addresses (e.g. node_handle and callback address). By binding these addresses, CARET constructs structures of each trace point relationship.</p>"},{"location":"design/trace_points/initialization_trace_points/#relationships-for-each-initialization-trace-points","title":"Relationships for each initialization trace points","text":"<p>Relationships of each trace point related to a single node are shown as follows.</p> <pre><code>erDiagram\n rcl_init{\n address context_handle\n }\n\n rcl_node_init{\n address node_handle\n address rmw_handle\n string node_name\n string node_namespace\n }\n\n rcl_publisher_init{\n address publisher_handle\n address node_handle\n address rmw_publisher_handle\n string topic_name\n size_t queue_depth\n }\n\n rcl_subscription_init{\n address subscription_handle\n address node_handle\n address rmw_subscription_handle\n string topic_name\n size_t queue_depth\n }\n\n rclcpp_subscription_init{\n address subscription_handle\n address subscription\n }\n\n rclcpp_subscription_callback_added{\n address subscription\n address callback\n }\n\n rcl_service_init{\n address service_handle\n address node_handle\n address rmw_service_handle\n string service_name\n }\n\n rclcpp_service_callback_added{\n address service_hadle\n address callback\n }\n\n rcl_timer_init{\n address timer_handle\n int64_t period\n }\n\n rclcpp_timer_callback_added{\n address timer_handle\n address callback\n }\n\n rclcpp_timer_link_node{\n address timer_handle\n address node_handle\n }\n\n rclcpp_callback_register{\n address callback\n string function_symbol\n }\n\n rmw_implementation{\n string rmw_impl\n }\n\n    rcl_node_init ||--o{ rcl_publisher_init : node_handle\n    rcl_node_init ||--o{ rcl_subscription_init : node_handle\n    rcl_node_init ||--o{ rclcpp_timer_link_node : node_handle\n    rcl_node_init ||--o{ rcl_service_init : node_handle\n\n    rcl_publisher_init ||--|| PUBLISHER_HANDLE : node_handle\n    rcl_subscription_init ||--|| SUBSCRIPTION_HANDLE : node_handle\n    rcl_timer_init ||--|| TIMER_HANDLE : node_handle\n    rcl_service_init ||--|| SERVICE_HANDLE : node_handle\n\n    rcl_subscription_init ||--|| rclcpp_subscription_init : subscription_handle\n    rclcpp_subscription_init ||--|| rclcpp_subscription_callback_added : subscription\n\n    rcl_service_init ||--|| rclcpp_service_callback_added : service_handle\n    rclcpp_service_callback_added ||--|| rclcpp_callback_register : callback\n\n    rclcpp_timer_callback_added ||--|| rclcpp_callback_register : callback\n    rclcpp_subscription_callback_added ||--|| rclcpp_callback_register : callback\n\n    rclcpp_timer_callback_added ||--|| rcl_timer_init : timer_handle\n    rclcpp_timer_link_node ||--|| rcl_timer_init: timer_handle\n</code></pre> <p>Relationships of each trace point related to executors are shown as follows.</p> <pre><code>erDiagram\n construct_executor{\n address executor_addr\n string executor_type_name\n }\n\n construct_static_executor{\n address executor_addr\n address entities_collector_addr\n string executor_type_name\n }\n\n add_callback_group{\n address executor_addr\n address callback_group_addr\n string group_type_name\n }\n\n add_callback_group_static_executor{\n address entities_collector_addr\n address callback_group_addr\n string group_type_name\n }\n\n callback_group_add_timer{\n address callback_group_addr\n address timer_handle\n }\n\n callback_group_add_subscription{\n address callback_group_addr\n address subscription_handle\n }\n\n callback_group_add_service{\n address callback_group_addr\n address service_handle\n }\n\n callback_group_add_client{\n address callback_group_addr\n address client_handle\n }\n\n\n construct_executor ||--o{ add_callback_group : executor_addr\n construct_static_executor ||--o{ add_callback_group_static_executor : entities_collector_addr\n\n    add_callback_group_static_executor ||--o{ callback_group_add_timer : callback_group_addr\n    add_callback_group_static_executor ||--o{ callback_group_add_subscription : callback_group_addr\n    add_callback_group_static_executor ||--o{ callback_group_add_service : callback_group_addr\n    add_callback_group_static_executor ||--o{ callback_group_add_client : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_timer : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_subscription : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_service : callback_group_addr\n    add_callback_group ||--o{ callback_group_add_client : callback_group_addr\n\n    callback_group_add_timer ||--|| TIMER_HANDLE : callback_group_addr\n    callback_group_add_subscription ||--|| SUBSCRIPTION_HANDLE : callback_group_addr\n    callback_group_add_service ||--|| SERVICE_HANDLE : callback_group_addr\n    callback_group_add_client ||--|| CLIENT_HANDLE : callback_group_addr\n\n</code></pre>"},{"location":"design/trace_points/initialization_trace_points/#tracepoints-for-representing-structure-of-executor-and-callback-group","title":"Tracepoints for representing structure of executor and callback group","text":"<p>A handler such as <code>timer_handle</code> and <code>subscription_handle</code> are assigned to a callback group. A callback group belongs to an executor.</p>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_init","title":"ros2:rcl_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * context_handle</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_node_init","title":"ros2:rcl_node_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * node_handle</li> <li>void * rmw_handle</li> <li>char * node_name</li> <li>char * node_namespace</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_publisher_init","title":"ros2:rcl_publisher_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * node_handle</li> <li>void * rmw_publisher_handle</li> <li>char * topic_name</li> <li>size_t queue_depth</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_subscription_init","title":"ros2:rcl_subscription_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * subscription_handle</li> <li>void * node_handle</li> <li>void * rmw_subscription_handle</li> <li>char * topic_name</li> <li>size_t queue_depth</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_subscription_init","title":"ros2:rclcpp_subscription_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * subscription_handle</li> <li>void * subscription</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_subscription_callback_added","title":"ros2:rclcpp_subscription_callback_added","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * subscription</li> <li>void * callback</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_service_init","title":"ros2:rcl_service_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * service_handle</li> <li>void * node_handle</li> <li>void * rmw_service_handle</li> <li>char * service_name</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_service_callback_added","title":"ros2:rclcpp_service_callback_added","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * service_handle</li> <li>void * callback</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rcl_timer_init","title":"ros2:rcl_timer_init","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * timer_handle</li> <li>int64_t period</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_timer_callback_added","title":"ros2:rclcpp_timer_callback_added","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * timer_handle</li> <li>void * callback</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_timer_link_node","title":"ros2:rclcpp_timer_link_node","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * timer_handle</li> <li>void * node_handle</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2rclcpp_callback_register","title":"ros2:rclcpp_callback_register","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback</li> <li>char * function_symbol</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretrmw_implementation","title":"ros2_caret:rmw_implementation","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>char * rmw_impl</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretconstruct_executor","title":"ros2_caret:construct_executor","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * executor_addr</li> <li>char * executor_type_name</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretconstruct_static_executor","title":"ros2_caret:construct_static_executor","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * executor_addr</li> <li>void * entities_collector_addr</li> <li>char * executor_type_name</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretadd_callback_group","title":"ros2_caret:add_callback_group","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * executor_addr</li> <li>void * callback_group_addr</li> <li>char * group_type_name</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretadd_callback_group_static_executor","title":"ros2_caret:add_callback_group_static_executor","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * entities_collector_addr</li> <li>void * callback_group_addr</li> <li>char * group_type_name</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_timer","title":"ros2_caret:callback_group_add_timer","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * timer_handle</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_subscription","title":"ros2_caret:callback_group_add_subscription","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * subscription_handle</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_service","title":"ros2_caret:callback_group_add_service","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * service_handle</li> </ul>"},{"location":"design/trace_points/initialization_trace_points/#ros2_caretcallback_group_add_client","title":"ros2_caret:callback_group_add_client","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback_group_addr</li> <li>void * client_handle</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/","title":"Runtime trace points","text":""},{"location":"design/trace_points/runtime_trace_points/#relationships-for-each-runtime-trace-points","title":"Relationships for each runtime trace points","text":"<pre><code>erDiagram\n\n callback_start{\n address callback\n bool is_intra_process\n }\n\n callback_end{\n address callback\n }\n\n message_construct{\n address original_message\n address constructed_message\n }\n\n dds_bind_addr_to_addr{\n address addr_from\n address addr_to\n }\n\n rclcpp_intra_publish{\n address publisher_handle\n address message\n uint64_t message_timestamp\n }\n\n dispatch_subscription_callback{\n address message\n address callback\n uint64_t source_timestamp\n uint64_t message_timestamp\n }\n\n dispatch_intra_process_subscription_callback{\n address message\n address callback\n uint64_t message_timestamp\n }\n\n rcl_publish{\n address publisher_handle\n address message\n }\n\n rclcpp_publish{\n address publisher_handle\n address message\n uint64_t message_timestamp\n }\n\n dds_write{\n address message\n }\n\n dds_bind_addr_to_stamp{\n address addr\n uint64_t source_stamp\n }\n\n    rclcpp_intra_publish ||--|| dispatch_intra_process_subscription_callback: message_addr\n    rclcpp_publish ||--|| rcl_publish: message_addr\n    rcl_publish ||--|| dds_write: message_addr\n    dds_write ||--|| dds_bind_addr_to_stamp: message_addr\n\n    dds_bind_addr_to_stamp ||--|| dispatch_subscription_callback: source_timestamp\n\n\n    dispatch_intra_process_subscription_callback ||--|| callback_start: callback\n    dispatch_subscription_callback ||--|| callback_start: callback\n    callback_start ||--|| callback_end: callback\n</code></pre> <p>Using addresses, tid and source timestamp, it is possible to uniquely identify and bind from the rclcpp publish to the end of subscription node callback. On the other hand, callback start and publish cannot be automatically bound. This is because the relationship between callback and publish is highly implementation-dependent.</p> <p>message_construct and dds_bind_addr_to_addr are trace points to adapt to copying and converting instances for binding.</p>"},{"location":"design/trace_points/runtime_trace_points/#ros2callback_start","title":"ros2:callback_start","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback</li> <li>bool is_intra_process</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2callback_end","title":"ros2:callback_end","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * callback</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2message_construct","title":"ros2:message_construct","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * original_message</li> <li>void * constructed_message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2rclcpp_intra_publish","title":"ros2:rclcpp_intra_publish","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * message</li> <li>uint64_t message_timestamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2dispatch_subscription_callback","title":"ros2:dispatch_subscription_callback","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * message</li> <li>void * callback</li> <li>uint64_t source_timestamp</li> <li>uint64_t message_timestamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2dispatch_intra_process_subscription_callback","title":"ros2:dispatch_intra_process_subscription_callback","text":"<p>[Extended tracepoints]</p> <p>Sampled items</p> <ul> <li>void * message</li> <li>void * callback</li> <li>uint64_t message_timestamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2rcl_publish","title":"ros2:rcl_publish","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2rclcpp_publish","title":"ros2:rclcpp_publish","text":"<p>[Built-in tracepoints]</p> <p>Sampled items</p> <ul> <li>void * publisher_handle</li> <li>void * message</li> <li>uint64_t message_timestamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_write","title":"ros2_caret:dds_write","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * message</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_bind_addr_to_stamp","title":"ros2_caret:dds_bind_addr_to_stamp","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * addr</li> <li>uint64_t source_stamp</li> </ul>"},{"location":"design/trace_points/runtime_trace_points/#ros2_caretdds_bind_addr_to_addr","title":"ros2_caret:dds_bind_addr_to_addr","text":"<p>[Hooked tracepoints]</p> <p>Sampled items</p> <ul> <li>void * addr_from</li> <li>void * addr_to</li> </ul>"},{"location":"design/visualizations/","title":"Visualizations","text":"<p>CARET is a tool for performance evaluation and analysis.</p> <p>For evaluation, quantification and visualization would be sufficient. For analysis, on the other hand, various factors are involved in behavior and performance, so it is necessary to investigate from multiple perspectives.</p> <p>CARET has multiple visualizations for evaluation and analysis APIs. Also, CARET let you to directly acquire and evaluate the data on your own (see Processing trace data for detail).</p>"},{"location":"design/visualizations/#policy","title":"Policy","text":""},{"location":"design/visualizations/#evaluation-flow","title":"Evaluation flow","text":"<p>CARET handles a large amount of recorded events, which prevents you from investigating performance of your application smoothly. Just displaying recorded events thoughtlessly might waste your time. So, it is important to focus on evaluation targets with appropriate granularity according to the purpose of evaluation.</p> <p>The following diagram shows the evaluation flow and analysis by adjusting the granularity.</p> <p></p> <p>Here, the horizontal axis represents the visualization granularity and the vertical axis represents the processing granularity. Those definitions will be explained subsequent sections.</p> <p>CARET help you to find issues and their causes by changing the processing and visualization granularity, respectively. You can approach an issues and its cause step by step from rough to fine granularity, from right-upper to left-lower in the figure.</p> <ol> <li>Detect issues: Detects performance issues on the target system.</li> <li>Identify issues: Identify the bottleneck that is causing the issue.</li> <li>Identify causes: Identifies the cause of the bottleneck.</li> </ol> <p>Processing granularity on the horizontal axis and visualization granularity on the vertical axis are explained in the following section.</p>"},{"location":"design/visualizations/#visualization-granularity","title":"Visualization granularity","text":"<p>The granularity of visualizations are listed below in order of fine granularity.</p> <ul> <li>Time-series trace data</li> <li>Bar graph / Line graph</li> <li>Heatmap</li> <li>Histogram</li> <li>Statistic</li> </ul> <p>The coarser granularity, the more time information is aggregated to evaluate the measurement as a whole. The most granular statistics are suitable for regression testing.</p> <p>On the other hand, the finer granularity, the more detailed information is expressed, so it is more suitable for analysis. Latency and response time are mainly used metrics to evaluate performance. The most detailed information is a time-series graph of each trace data.</p>"},{"location":"design/visualizations/#processing-granularity","title":"Processing granularity","text":"<p>The processing granularity means granularity of subsystem in an application, it is ordered in coarse order as follows.</p> <ul> <li>path</li> <li>node / communication</li> <li>callback</li> <li>function</li> </ul> <p>Path is suitable for performance evaluation per system , while node and callback are suitable for performance evaluation per component or smaller subsystem.</p> <p> <p>Notice<p>In the present, CARET does not support measurement of arbitrary functions or DDS enqueue/dequeue or system calls.</p> </p> <p> <p>See also</p> <ul> <li>Event and latency definition</li> </ul>"},{"location":"design/visualizations/#metrics-category","title":"Metrics category","text":"<p>We described behavior and metrics in terms of visualization granularity, but there are multiple metrics, such as latency and frequency. Metrics for performance analysis is categorized into two types; time-related metrics and frequency-related metrics. CARET recommends you to be aware two types.</p> <ul> <li>Time Domain Metrics (ex: callback execution time [s])</li> <li>Frequency Domain Metrics (ex: topic frequency [Hz])</li> </ul> <p>Both have their pros and cons.</p> Time Domain Metrics Frequency Domain Metrics Metric Latency, Response time Frequency (, Period) Pros Easy to compare with system requirements No need to define latency or path Cons Need to define latency or path Difficult to compare with system requirements <p>In the table above, period is metrics that expresses the time interval between sequential cyclic events, so it is classified into the frequency-related metrics.</p> <p>See also</p> <ul> <li>Records service</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#installation","title":"Installation","text":""},{"location":"faq/#setup-fails","title":"Setup fails","text":"<ul> <li>In case you encounter errors during setup or build process, please make sure to use an appropriate branch for your environment<ul> <li>ROS 2 Galactic, Ubuntu 20.04: <code>galactic</code> branch</li> <li>ROS 2 Humble, Ubuntu 22.04: main branch</li> </ul> </li> <li>It's also important to delete <code>./build</code> <code>./install</code> and <code>./src</code> directory before rebuilding CARET if you have built CARET using wrong settings</li> </ul>"},{"location":"faq/#cli-tool-doesnt-work","title":"CLI tool doesn't work","text":"<p>In case CLI tool execution fails, please make sure to perform CARET environment settings</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\nros2 caret check_caret_rclcpp --workspace &lt;path-to-workspace&gt;\n</code></pre> <p> <p>Warning</p> <p>CARET CLI tool doesn't work properly in Anaconda environment. Please use pure Python.</p> <p>"},{"location":"faq/#visualization","title":"Visualization","text":""},{"location":"faq/#result-plot-message_flow-etc-is-not-outputted-or-there-seems-something-wrong-with-the-result","title":"Result (plot, message_flow, etc.) is not outputted, or there seems something wrong with the result","text":"<ul> <li>Please use the following commands for verification<ul> <li><code>ros2 caret check_caret_rclcpp</code> to check if a target application is built with CARET/rclcpp</li> <li><code>ros2 caret check_ctf</code> to check if tracing data is recorded properly</li> </ul> </li> <li>Please make sure the followings:<ul> <li>A target application is built with CARET/rclcpp</li> <li>CARET environment is set properly before running a target application<ul> <li><code>export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)</code></li> <li><code>source ~/ros2_caret_ws/install/local_setup.bash</code></li> </ul> </li> <li>LTTng trace is started before running a target application<ul> <li><code>ros2 trace -s e2e_sample -k -u \"ros2*\"</code></li> <li>or consider to use launch file</li> </ul> </li> <li>Trace data is not discarded<ul> <li>In case trace data is discarded, use Trace filter</li> </ul> </li> <li>The size of trace data is proper<ul> <li>If the size of trace data is extremely small (e.g. only few KByte) and a target application has lots of nodes, the maximum number of file descriptors may not be enough. It can be increased by <code>ulimit -n 65536</code></li> </ul> </li> </ul> </li> <li>See Recording for more details</li> </ul>"},{"location":"faq/#parts-of-results-are-not-outputted","title":"Parts of results are not outputted","text":"<ul> <li>If certain nodes are not traced but some nodes are traced, some packages may be built without CARET/rclcpp. Please make sure <code>&lt;depend&gt;rclcpp&lt;/depend&gt;</code> is described in <code>package.xml</code></li> <li>Another possibility is that some nodes can't be analyzed due to CARET's limitations:<ul> <li>CARET cannot analyze a node which has two or more timer callbacks with the same period time setting</li> <li>CARET cannot analyze a node which has two or more subscription callbacks with the same topic name</li> </ul> </li> <li>Callback information in such nodes are not outputted. Also, message flow will be discontinued at such nodes</li> </ul>"},{"location":"faq/#traceresultanalyzeerror-failed-to-find-error-occurs","title":"<code>TraceResultAnalyzeError: Failed to find</code> error occurs","text":"<ul> <li>The error occurs if information in an architecture file and trace data are inconsistent with each other</li> <li>Please modify the architecture file or check recording process</li> <li>e.g.<ul> <li><code>TraceResultAnalyzeError: Failed to find callback_object.node_name: /localization/pose_twist_fusion_filter/ekf_localizer, callback_name: timer_callback_0, period_ns: 19999999, symbol: void (EKFLocalizer::?)()</code></li> </ul> </li> </ul>"},{"location":"faq/#visualization-callback","title":"Visualization (callback)","text":""},{"location":"faq/#callback-frequency-is-smaller-than-expected-value","title":"Callback frequency is smaller than expected value","text":"<ul> <li><code>Plot.create_callback_frequency_plot</code> calculates frequency from one second to one second. It counts how many times a callback function is called for a second, and just uses the count as frequency. Therefore, the frequency on the last term tends to small because the last term is usually shorter than one second</li> <li>Another possibility is that the frequency of a subscription callback will be small if it receives topics not periodically but infrequently. Also, the frequency of a timer callback will be small if the timer dynamically stops/starts</li> </ul>"},{"location":"faq/#callback-latency-is-bigger-than-expected-value","title":"Callback latency is bigger than expected value","text":"<ul> <li>Some nodes may run initialization process. In this case, the latency time calculated by <code>Plot.create_callback_latency_plot</code> is huge on the first execution</li> </ul>"},{"location":"faq/#visualization-message-flow","title":"Visualization (message flow)","text":""},{"location":"faq/#message-flow-is-discontinued","title":"Message flow is discontinued","text":"<ul> <li>If parts of nodes/communications don't run at all during recording, message flow stops on the way and such nodes/communications are not displayed on y-axis<ul> <li>Please make sure that all nodes/communications in a target path run during recording, or modify a target path to analyze actually working path</li> </ul> </li> <li>Another possibility is that a target path includes a node which CARET cannot analyze due to its limitations as explained above</li> </ul>"},{"location":"faq/#what-is-a-gray-color-rectangle-in-a-message-flow-diagram","title":"What is a gray color rectangle in a message flow diagram?","text":"<ul> <li>A rectangle in a message flow diagram indicates a period from the entry to the exit of a callback function, while a line shows a flow of topics</li> <li>Note: a rectangle is not always illustrated</li> </ul>"},{"location":"faq/#huge-delay-between-topic-publication-and-callback-start","title":"Huge delay between topic publication and callback start","text":"<ul> <li>In a message flow diagram, term from <code>ooo/rclcpp_publish</code> to <code>ooo/callback_start</code> means latency from when a topic is published to when the following callback starts</li> <li>It includes the following time:<ul> <li>Communication (topic) latency</li> <li>Wait by ROS scheduler</li> <li>Wait by OS scheduler</li> </ul> </li> <li>In most cases, it doesn't take so much time. In case the time is huge, the followings are possible causes:<ul> <li>There is a problem in communication</li> <li>An executor cannot wake up because other processes occupy CPU</li> <li>A callback cannot wake up because other callbacks in the same callback group occupy the executor</li> <li>Processing time of a callback is longer than topic subscription period</li> </ul> </li> </ul>"},{"location":"faq/#message-flow-looks-split","title":"Message flow looks split","text":"<ul> <li>Take the following system for example;<ul> <li><code>Node_C</code> publishes a topic when it receives a topic from <code>Node_A</code></li> <li><code>Node_A</code> publishes a topic with a rate of 50 Hz, while <code>Node_B</code> publishes a topic at 10 Hz</li> </ul> </li> <li>Message flow (<code>Node_B</code> -&gt; <code>Node_C</code> -&gt; <code>Node_D</code>) looks split at <code>Node_C</code>. It's because <code>Node_C</code> publishes 5 topics while receiving 1 topic from <code>Node_B</code></li> <li>Note: A similar phenomenon will happen even if <code>Callback c0</code> is a timer callback</li> </ul>"},{"location":"faq/#message-flow-looks-dropped","title":"Message flow looks dropped","text":"<ul> <li>Take the following system for example;<ul> <li><code>Node_C</code> publishes a topic when it receives a topic from <code>Node_A</code></li> <li><code>Node_A</code> publishes a topic with a rate of 10 Hz, while <code>Node_B</code> publishes a topic at 50 Hz</li> </ul> </li> <li>Message flow (<code>Node_B</code> -&gt; <code>Node_C</code> -&gt; <code>Node_D</code>) looks disconnected at <code>Node_C</code> four times every five messages. It's because <code>Node_C</code> publishes 1 topic while receiving 5 topics from <code>Node_B</code>. So 4 topics don't have a corresponding topic to be published to <code>Node_D</code></li> <li>Note: A similar phenomenon will happen even if <code>Callback c0</code> is a timer callback</li> </ul>"},{"location":"faq/#how-response-time-is-calculated","title":"How response time is calculated?","text":"<ul> <li>In general, response time is the time a system or functional unit takes to react to a given input (reference). Response time calculated by CARET is the time it takes for input data to arrive at the last node. It doesn't include processing time at the first/last node nor latency of an actuator. It's calculated as the sum of communication latency time (from the time when a node publishes a topic to the time when the following node subscribes the topic) and node latency time (from the time when a node subscribes a topic to the time when it publishes another topic) in a path<ul> <li>In the following diagram, input data at point A is first reflected with output at point X (<code>ResponseTime_Best</code>)</li> <li><code>ResponseTime_Best</code> can be considered as a path (dataflow) latency time</li> <li><code>ResponseTime_Best</code> can be considered as a happy case, which is contrary to the following worst case scenario</li> </ul> </li> <li>Assuming that input information is created by a sensor such as an object detection sensor, delay in a sensor should be considered. For instance, if a new object appears at point B, the time from point B to point A should added to the response time. The worst case scenario is that a new object appears just after the previous flow (point C). Response time for the worst case is shown as <code>ResponseTime_Worst</code></li> <li>CARET can calculate both <code>ResponseTime_Best</code> and <code>ResponseTime_Worst</code> using the following APIs:<ul> <li><code>response_time.to_best_case_timeseries()</code> , <code>response_time.to_best_case_histogram()</code></li> <li><code>response_time.to_worst_case_timeseries()</code> , <code>response_time.to_best_worst_histogram()</code></li> </ul> </li> <li>CARET also provides <code>response_time.to_histogram()</code> API. It creates histogram assuming a new object appears from point C to point A at intervals of histogram bin size</li> </ul>"},{"location":"installation/installation/","title":"Installation","text":""},{"location":"installation/installation/#requirements","title":"Requirements","text":"<p>CARET is confirmed to run on the platforms shown in the following table with supported version.</p> dependent platform supported version ROS Humble Ubuntu 22.04 LTTng stable-2.13 Linux Kernel 5.15.x Python3 3.10.x <p>The recent version, after v0.3.0, of CARET supports only the combination of ROS 2 Humble and Ubuntu 22.04. If you want to run CARET on ROS 2 Galactic and Ubuntu 20.04, please refer to documents for v0.2.3</p>"},{"location":"installation/installation/#installation_1","title":"Installation","text":"<p>Installation using meta repository is the least time-consuming way to install CARET. With meta repository and Ansible, you can skip the laborious manual setup which is explained in manual installation(./manual_installation.md) section (written in Japanese).</p> <p>Please execute the following steps on Ubuntu 20.04. The order is important so that you have to follow the steps in order.</p> <ol> <li> <p>Clone <code>caret</code> and enter the directory.</p> <pre><code>git clone https://github.com/tier4/caret.git ros2_caret_ws\ncd ros2_caret_ws\n</code></pre> <p><code>main</code> branch is dedicated for ROS 2 Humble. If you want to use CARET for ROS 2 Galactic, please execute <code>git checkout galactic</code> in <code>ros2_caret_ws</code> directory.</p> </li> <li> <p>Create the src directory and clone repositories into it.</p> <p>CARET uses vcstool to construct workspaces.</p> <pre><code>mkdir src\nvcs import src &lt; caret.repos\n</code></pre> </li> <li> <p>Run <code>setup_caret.sh</code>.</p> <pre><code>./setup_caret.sh\n</code></pre> </li> <li> <p>Build the workspace.</p> <pre><code>source /opt/ros/humble/setup.bash\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre> </li> <li> <p>Check whether CARET (ros2-tracing) is enabled.</p> <p>CARET inherits some functions from ros2-tracing.</p> <pre><code>source ~/ros2_caret_ws/install/local_setup.bash\nros2 run tracetools status # return Tracing enabled\n</code></pre> </li> </ol> <p>If you see <code>Tracing enabled</code>, you can continue to apply CARET to your application.</p>"},{"location":"installation/manual_installation/","title":"Manual installation","text":""},{"location":"installation/manual_installation/#installation-of-required-packages","title":"Installation of required packages","text":""},{"location":"installation/manual_installation/#install-lttng","title":"Install LTTng","text":"<p>Refer to the official document for LTTng for details</p> <pre><code>sudo apt-add-repository ppa:lttng/stable-2.13\nsudo apt-get update\nsudo apt-get install lttng-tools liblttng-ust-dev\nsudo apt-get install python3-babeltrace python3-lttng\n</code></pre>"},{"location":"installation/manual_installation/#install-packages-to-build-caret","title":"Install packages to build CARET","text":"<p>Install ROS 2 Humble and related packages. See also the official document for ROS 2.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y \\\nbuild-essential \\\ncmake \\\ngit \\\npython3-colcon-common-extensions \\\npython3-flake8 \\\npython3-pip \\\npython3-pytest-cov \\\npython3-rosdep \\\npython3-setuptools \\\npython3-vcstool \\\npython3-bt2 \\\nwget\n\npython3 -m pip install -U \\\nflake8-blind-except \\\nflake8-builtins \\\nflake8-class-newline \\\nflake8-comprehensions \\\nflake8-deprecated \\\nflake8-docstrings \\\nflake8-import-order \\\nflake8-quotes \\\npytest-repeat \\\npytest-rerunfailures \\\npytest \\\nsetuptools \\\ncolorcet\n\nsudo apt install ros-humble-desktop\n</code></pre> <p>Install packages related with <code>ros2_tracing</code></p> <pre><code>sudo apt install -y \\\nros-humble-ros2trace \\\nros-humble-ros2trace-analysis \\\nros-humble-tracetools \\\nros-humble-tracetools-analysis \\\nros-humble-tracetools-launch \\\nros-humble-tracetools-read \\\nros-humble-tracetools-test \\\nros-humble-tracetools-trace\n</code></pre> <p>Install packages for visualization with CARET.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y \\\ngraphviz \\\ngraphviz-dev\n\npython3 -m pip install -U \\\npytest-mock \\\npybind11 \\\n'pandas&gt;=1.4.0' \\\nbokeh \\\npandas-bokeh \\\njupyterlab \\\ngraphviz\n\n# If you see the message, [ImportError: The Jupyter Server requires tornado &gt;=6.1.0] during installing jupyterlab,\n# upgrade tornado with the following command.\n# pip install tornado --upgrade\n</code></pre>"},{"location":"installation/manual_installation/#source-build-of-caret","title":"Source build of CARET","text":"<pre><code>mkdir -p ~/ros2_caret_ws/src\ncd ~/ros2_caret_ws\n\nwget https://raw.githubusercontent.com/tier4/caret/main/caret.repos\nvcs import src &lt; caret.repos\n\nrosdep install \\\n--from-paths src --ignore-src \\\n--rosdistro humble -y \\\n--skip-keys \"console_bridge fastcdr fastrtps rti-connext-dds-5.3.1 urdfdom_headers\"\n\n# If you find the error message, [ERROR: the following packages/stacks could not have their rosdep keys resolved],\n# execute rosdep initialization and update with the following two commands.\n# rosdep init\n# rosdep update\nsource /opt/ros/humble/setup.bash\n\n# Create symbolic link so that the header files, which are provided by the forked packages, should be referred\nln -sf ~/ros2_caret_ws/src/ros-tracing/ros2_tracing/tracetools/include/tracetools ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\nln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_action/include/rclcpp_action ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\nln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_components/include/rclcpp_components/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\nln -sf ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp_lifecycle/include/rclcpp_lifecycle/ ~/ros2_caret_ws/src/ros2/rclcpp/rclcpp/include/\n\n# Build CARET with colcon command\ncolcon build --cmake-args -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTING=off  --symlink-install\n</code></pre> <p>Check whether <code>ros2_tracing</code> is available</p> <pre><code>$ source ~/ros2_caret_ws/install/local_setup.bash\n$ ros2 run tracetools status\nTracing enabled\n</code></pre>"},{"location":"recording/","title":"Recording with CARET","text":""},{"location":"recording/#steps-to-record-trace-data-with-caret","title":"Steps to record trace data with CARET","text":"<ul> <li>Build a target application with CARET and check it (See details)</li> <li>(Optional) Configure trace filter (See details)</li> <li>Record the application (See details)</li> <li>Validate trace data (See details)</li> </ul>"},{"location":"recording/#other-tips","title":"Other tips","text":"<ul> <li>CLI tools</li> <li>ROS time (sim_time) support</li> </ul>"},{"location":"recording/build_check/","title":"Build with CARET","text":""},{"location":"recording/build_check/#build-a-target-application-with-caret","title":"Build a target application with CARET","text":"<p>A target application should be built with CARET/rclcpp to record trace data. If you have already built the application without CARET/rclcpp, you have to build the application with CARET/rclcpp again.</p> <p>For building the application with CARET/rclcpp, CARET's <code>local_setup.bash</code> should be applied along with ROS 2's <code>setup.bash</code> as shown below. Also, <code>-DBUILD_TESTING=OFF</code> should be given to build option.</p> <pre><code>cd &lt;path-to-workspace&gt;\n\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash  # please keep the order after ROS 2's setup.bash\n\ncolcon build --symlink-install --cmake-args -DBUILD_TESTING=OFF\n</code></pre> <p> <p>Reason for building a target application with CARET/rclcpp</p> <p>CARET/rclcpp is a fork of ROS 2-based rclcpp which has some additional tracepoints defined by CARET.   Some tracepoints must be added to template implementation, which is referred by rclcpp header files, for CARET to record a target application.   In order to apply rclcpp which has the additional tracepoints, the application have to be built with CARET/rclcpp again.   Therefore, CARET cannot trace the application provided by Ubuntu's aptitude such as <code>demo_nodes_cpp</code>.   If you want to trace such pre-build packages, please build them again from source code.</p> <p> <p> <p>Reason for giving <code>-DBUILD_TESTING=OFF</code></p> <p>To use CARET, you need to use forked shared libraries and headers such as CARET/rclcpp.   In the test codes, CARET/rclcpp is not available due to loading priority issues for headers.   Depending on the version of CARET, conflicts may occur between the shared libraries of   ros-rclcpp and the headers of CARET/rclcpp, resulting in compile errors.   Therefore, test codes have to be excluded from building.</p> <p>"},{"location":"recording/build_check/#check-whether-caretrclcpp-is-applied-to-each-package","title":"Check whether CARET/rclcpp is applied to each package","text":"<p>You can check whether a target application is successfully built with CARET/rclcpp using <code>ros2 caret check_caret_rclcpp</code> command.</p> <pre><code>ros2 caret check_caret_rclcpp --workspace &lt;path-to-workspace&gt;\n</code></pre> Output Message Description <code>All packages are built using caret-rclcpp</code> There is no problem <code>The following packages have not been built using caret-rclcpp</code> CARET/rclcpp is not applied to the listed packages (Please read the next section to fix it)"},{"location":"recording/build_check/#how-to-fix","title":"How to fix","text":"<p>In case CARET/rclcpp is not applied to the package you want to analyze, you need to fix it. The followings show possible causes and solutions.</p> <ul> <li>Case 1: All packages are listed as CARET/rclcpp is not applied<ul> <li>Make sure you applied CARET's <code>local_setup.bash</code> after ROS2's <code>setup.bash</code> (keep the order)</li> </ul> </li> <li>Case 2: Some, but not all, packages are listed as CARET/rclcpp is not applied<ul> <li>Make sure you have the following line in <code>package.xml</code> in the listed package<ul> <li><code>&lt;depend&gt;rclcpp&lt;/depend&gt;</code></li> </ul> </li> </ul> </li> </ul> <p> <p>Info</p> <p>The listed packages are not traced while other packages built with CARET/rclcpp are properly traced. Therefore, you can ignore this message if you don't need to trace/analyze the listed packages.</p> <p>"},{"location":"recording/cli_tool/","title":"CLI tools for recording","text":"<p>CARET provides CLI tools which can be utilized at recording process.</p> <p> <p>Info</p> <p>CARET environment settings need to be performed to use these CLI tools by the following commands.</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n</code></pre> <p>"},{"location":"recording/cli_tool/#build-results-validation","title":"Build results validation","text":"<p>This command checks whether a target application is successfully built with CARET/rclcpp. (See details)</p> <pre><code>ros2 caret check_caret_rclcpp --workspace &lt;path-to-workspace&gt;\n</code></pre> <pre><code>---Output text as below---\n\nINFO    : 2022-09-29 20:18:43 | All packages are built using caret-rclcpp.\n</code></pre>"},{"location":"recording/cli_tool/#trace-data-validation","title":"Trace data validation","text":"<p>This command checks whether a recording is successful. (See details)</p> <p>If there are problems with the recorded data, warning messages will be displayed</p> <pre><code>ros2 caret check_ctf --trace_dir &lt;path-to-trace-data&gt;\n</code></pre>"},{"location":"recording/cli_tool/#node-summary","title":"Node summary","text":"<p>This command displays the number of events per node.</p> <pre><code>ros2 caret node_summary --trace_dir &lt;path-to-trace-data&gt;\n</code></pre> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\n=============================================\n\nnode_name            |   number_of_trace_points\n----------------------+--------------------------\n /message_driven_node |                     4207\n/timer_driven_node   |                     3630\n/filter_node         |                     2680\n/drive_node          |                     2146\n/sensor_dummy_node   |                     2144\n/actuator_dummy_node |                     1609\n</code></pre>"},{"location":"recording/cli_tool/#topic-summary","title":"Topic summary","text":"<p>This command displays the number of events per topic.</p> <pre><code>ros2 caret topic_summary --trace_dir &lt;path-to-trace-data&gt;\n</code></pre> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\n=============================================\n\ntopic_name        |   number_of_trace_points\n-------------------+--------------------------\n /drive            |                     2668\n/topic1           |                     2668\n/topic2           |                     2668\n/topic4           |                     2658\n/topic3           |                     2478\n/parameter_events |                       66\n/rosout           |                        6\n</code></pre> <p> <p>Info</p> <p>If the number of events is too huge to handle, trace filtering is a reasonable choice to exclude unnecessary nodes/topics based on the output result.</p> <p>"},{"location":"recording/cli_tool/#tracepoint-summary","title":"Tracepoint summary","text":"<p>This command displays all tracepoints included in the trace data and the number of events collected by tracepoints.</p> <pre><code>ros2 caret trace_point_summary --trace_dir &lt;path-to-trace-data&gt;\n</code></pre> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\n=============================================\n\ntrace_point                                       |   number_of_trace_points\n---------------------------------------------------+--------------------------\n ros2:callback_end                                 |                     4216\nros2:callback_start                               |                     4216\nros2_caret:dds_write                              |                     2790\nros2_caret:dds_bind_addr_to_stamp                 |                     2790\nros2:rcl_publish                                  |                     2650\nros2:rclcpp_publish                               |                     2650\nros2:dispatch_subscription_callback               |                     2620\nros2:rclcpp_subscription_callback_added           |                       44\nros2:rclcpp_service_callback_added                |                       44\nros2:rclcpp_callback_register                     |                       44\nros2:rclcpp_timer_callback_added                  |                       44\nros2_caret:callback_group_add_service             |                       36\nros2:rcl_service_init                             |                       36\nros2:rcl_publisher_init                           |                       17\nros2_caret:callback_group_add_subscription        |                       11\nros2:rcl_node_init                                |                        6\nros2_caret:add_callback_group                     |                        6\nros2:rcl_subscription_init                        |                        5\nros2:rclcpp_subscription_init                     |                        5\nros2:rcl_timer_init                               |                        3\nros2:rclcpp_timer_link_node                       |                        3\nros2_caret:callback_group_add_timer               |                        3\nros2_caret:construct_executor                     |                        1\nros2_caret:rmw_implementation                     |                        1\nros2:rcl_init                                     |                        1\nros2:rcl_client_init                              |                        0\nros2:dispatch_intra_process_subscription_callback |                        0\nros2_caret:tilde_subscribe_added                  |                        0\nros2_caret:tilde_subscribe                        |                        0\nros2_caret:tilde_publisher_init                   |                        0\nros2_caret:tilde_publish                          |                        0\nros2_caret:sim_time                               |                        0\nros2_caret:on_data_available                      |                        0\nros2:message_construct                            |                        0\nros2_caret:dds_bind_addr_to_addr                  |                        0\nros2_caret:construct_static_executor              |                        0\nros2:rclcpp_intra_publish                         |                        0\nros2:rcl_lifecycle_transition                     |                        0\nros2:rcl_lifecycle_state_machine_init             |                        0\nros2_caret:callback_group_add_client              |                        0\nros2_caret:add_callback_group_static_executor     |                        0\nros2_caret:tilde_subscription_init                |                        0\n</code></pre>"},{"location":"recording/cli_tool/#filtering-for-summary-commands","title":"Filtering for summary commands","text":"<p>Executing a summary command for huge trace data (e.g., more than 10 minutes) takes time. The following two options allow you to filter the load range of trace data used for summary output. In both options, the argument type is float and the unit of time is second.</p> <pre><code>ros2 caret trace_point_summary --trace_dir &lt;path-to-trace-data&gt; --duration_filter &lt;DURATION&gt; &lt;OFFSET&gt;\nros2 caret trace_point_summary --trace_dir &lt;path-to-trace-data&gt; --strip_filter &lt;LSTRIP&gt; &lt;RSTRIP&gt;\n</code></pre> <ul> <li><code>--duration_filter [DURATION] [OFFSET]</code><ul> <li>Load only this [DURATION] from [OFFSET].</li> </ul> </li> <li><code>--strip_filter [LSTRIP] [RSTRIP]</code><ul> <li>Ignore trace data for specified seconds from start/end.</li> </ul> </li> </ul> <pre><code>---Output text as below---\n\n=============================================\nTrace creation datetime | 2022-07-16 17:34:07\nTrace range             | 17:34:07 ~ 17:35:08\nTrace duration          | 0:01:00\nFiltered trace range    | 17:34:15 ~ 17:34:45\nFiltered trace duration | 0:00:29\n=============================================\n\ntrace_point                                       |   number_of_trace_points\n---------------------------------------------------+--------------------------\n ros2:callback_end                                 |                     2385\nros2:callback_start                               |                     2385\nros2:dispatch_subscription_callback               |                     1485\nros2:rcl_publish                                  |                     1484\nros2_caret:dds_write                              |                     1484\nros2_caret:dds_bind_addr_to_stamp                 |                     1484\nros2:rclcpp_publish                               |                     1484\nros2:rclcpp_subscription_callback_added           |                       44\nros2:rclcpp_service_callback_added                |                       44\nros2:rclcpp_callback_register                     |                       44\nros2:rclcpp_timer_callback_added                  |                       44\nros2_caret:callback_group_add_service             |                       36\nros2:rcl_service_init                             |                       36\nros2:rcl_publisher_init                           |                       17\nros2_caret:callback_group_add_subscription        |                       11\nros2:rcl_node_init                                |                        6\nros2_caret:add_callback_group                     |                        6\nros2:rcl_subscription_init                        |                        5\nros2:rclcpp_subscription_init                     |                        5\nros2:rcl_timer_init                               |                        3\nros2:rclcpp_timer_link_node                       |                        3\nros2_caret:callback_group_add_timer               |                        3\nros2_caret:construct_executor                     |                        1\nros2_caret:rmw_implementation                     |                        1\nros2:rcl_init                                     |                        1\nros2:rcl_client_init                              |                        0\nros2:dispatch_intra_process_subscription_callback |                        0\nros2_caret:tilde_subscribe_added                  |                        0\nros2_caret:tilde_subscribe                        |                        0\nros2_caret:tilde_publisher_init                   |                        0\nros2_caret:tilde_publish                          |                        0\nros2_caret:sim_time                               |                        0\nros2_caret:on_data_available                      |                        0\nros2:message_construct                            |                        0\nros2_caret:dds_bind_addr_to_addr                  |                        0\nros2_caret:construct_static_executor              |                        0\nros2:rclcpp_intra_publish                         |                        0\nros2:rcl_lifecycle_transition                     |                        0\nros2:rcl_lifecycle_state_machine_init             |                        0\nros2_caret:callback_group_add_client              |                        0\nros2_caret:add_callback_group_static_executor     |                        0\nros2_caret:tilde_subscription_init                |                        0\n</code></pre>"},{"location":"recording/recording/","title":"Recording","text":""},{"location":"recording/recording/#recording-with-caret","title":"Recording with CARET","text":"<p>CARET uses LTTng for tracing a target application. A LTTng session has to be started before running the application. This page explains two different ways for it: Starting LTTng session manually and Starting LTTng session using ROS launch system.</p> <p>Explanation in this page assumes CARET is installed to <code>~/ros2_caret_ws</code> and the sample application used in the tutorial section is located in <code>~/ros2_ws</code>.</p>"},{"location":"recording/recording/#starting-lttng-session-manually","title":"Starting LTTng session manually","text":"<p>Two terminals are needed for this method: One for starting a LTTng session, another for running a target application.</p> <ol> <li> <p>Open a terminal and start a LTTng session with the following commands</p> <ul> <li>(Optional) <code>ROS_TRACE_DIR</code> variable is a destination directory where recorded trace data will be stored. Default is <code>~/.ros/tracing</code></li> <li>With \"<code>-s</code>\" option, you can give session name. The recorded trace data will be stored into <code>~/ros_ws/evaluate/e2e_sample</code> in this sample</li> <li>Press \"Enter\" key to start a session</li> </ul> <pre><code>source /opt/ros/humble/setup.bash\n\n# (Optional) Set a destination directory\nmkdir -p ~/ros2_ws/evaluate\nexport ROS_TRACE_DIR=~/ros2_ws/evaluate\n\nros2 trace -s e2e_sample -k -u \"ros2*\"\n# Start session with pressing Enter key\n</code></pre> </li> <li> <p>Open another terminal and launch a target application</p> <ul> <li> <p>Perform environment settings in the same order as below. CARET's <code>local_setup.bash</code> should be applied along with ROS 2's <code>setup.bash</code> as the target application refers to CARET/rclcpp</p> <pre><code># Environment settings (keep the order as below)\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n</code></pre> </li> </ul> <ul> <li> <p>Set <code>LD_PRELOAD</code> to enable tracepoints provided by function hook</p> <pre><code>export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n</code></pre> </li> </ul> <ul> <li> <p>(Optional) Apply trace filtering. With configuration of trace filtering, CARET can ignore unnecessary nodes/topics. This function is useful for a large application</p> <pre><code># Apply filter directly\nexport CARET_IGNORE_NODES=\"/rviz*\"\nexport CARET_IGNORE_TOPICS=\"/clock:/parameter_events\"\n\n# Apply filter using a setting file\nsource ./caret_topic_filter.bash\n</code></pre> </li> </ul> <ul> <li> <p>Launch the target application</p> <pre><code>ros2 run caret_demos end_to_end_sample\n</code></pre> </li> </ul> </li> <li> <p>Stop the target application</p> </li> <li> <p>Press \"Enter\" key to stop the LTTng session in the terminal where the LTTng session runs</p> </li> </ol> <p> <p>Info</p> <p>A LTTng session needs to be started before running a target application. Otherwise, some trace points won't be recorded and analysis will fail later.</p> <p> <p> <p>Info</p> <p>You may find that size of recorded data is strangely smaller than expected after updating LTTng to 2.13 if you apply CARET to a large application like Autoware which has hundreds of nodes. You have to suspect that maximum number of file descriptors is not enough in the case. You can check the number with <code>ulimit -n</code> command. The default maximum number is 1024, but it is not enough for the large application. You can avoid this problem by enlarging the maximum number with executing the command; <code>ulimit -n 65536</code>.</p> <p>"},{"location":"recording/recording/#starting-lttng-session-via-ros-launch","title":"Starting LTTng session via ROS launch","text":"<p>You can start LTTng session using ROS launch system. When you start a LTTng session in one terminal, you have to open another terminal for executing a target application as explained above. Operating multiple terminals is laborious for users. Launching LTTng session along with application by ROS launch is a reasonable way to apply CARET repeatedly.</p> <ol> <li> <p>Create a launch file for a target application in ROS general manner if you haven't made it</p> <pre><code># launch/end_to_end_sample.launch.py\nimport launch\nimport launch_ros.actions\n\n\ndef generate_launch_description():\n    return launch.LaunchDescription([\n        launch_ros.actions.Node(\n            package='caret_demos', executable='end_to_end_sample', output='screen'),\n    ])\n</code></pre> </li> <li> <p>Add description to start a LTTng session</p> <pre><code># launch/end_to_end_sample_with_lttng_session.launch.py\nimport launch\nimport launch_ros.actions\nfrom tracetools_launch.action import Trace\n\n\ndef generate_launch_description():\n    return launch.LaunchDescription([\n        Trace(\n            session_name='e2e_sample',\n            events_kernel=[],\n            events_ust=['ros2*']\n        ),\n        launch_ros.actions.Node(\n            package='caret_demos', executable='end_to_end_sample', output='screen'),\n    ])\n</code></pre> </li> <li> <p>Launch a target application and a LTTng session via the launch file</p> <ul> <li>Environment settings are still needed, but all operations are performed in just one terminal</li> </ul> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n\nexport LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\nsource ./caret_topic_filter.bash\n\nros2 launch caret_demos end_to_end_sample_with_lttng_session.launch.py\n</code></pre> </li> </ol>"},{"location":"recording/recording/#advanced-useful-settings-for-launch-file","title":"Advanced: Useful settings for launch file","text":"<ul> <li>The following script shows advanced settings for a launch file</li> <li><code>caret_session</code> option is used to set a session name. If not assigned, datetime (YYYYMMDD-HHMMSS) is used</li> <li><code>caret_light</code> option is used to add another event filter. Only events specified in <code>caret_event</code> variable are recorded. In this example, high level events, such as ros2:rclcpp layer, are recorded if <code>caret_light</code> is set to \"true\". This setting will be helpful to record a huge application.<ul> <li>Please refer to tracepoint summary to find which events are recorded, and modify <code>caret_event</code> as you want.</li> </ul> </li> </ul> <pre><code># launch/end_to_end_sample_with_lttng_session.launch.py\nimport launch\nimport launch_ros.actions\nfrom tracetools_launch.action import Trace\n\nimport sys\nimport datetime\nfrom distutils.util import strtobool\n\n\ndef generate_launch_description():\n  caret_session = \"\"\n  caret_event = [\"ros2*\"]\n  caret_light = True\n\n  for arg in sys.argv:\n    if arg.startswith(\"caret_session:=\"):\n      caret_session = arg.split(\":=\")[1]\n    elif arg.startswith(\"caret_light:=\"):\n      try:\n        caret_light = strtobool(arg.split(\":=\")[1]) # 0 or 1\n      except:\n        print(\"Invalid arguments 'caret_light'.\")\n        print(\"Start tracing with 'ros2*'.\")\n\n  if caret_light:\n    caret_event = [ \"ros2:*callback*\",\n            \"ros2:dispatch*\",\n            \"ros2:rclcpp*\" ,\n            \"ros2_caret:rmw*\",\n            \"*callback_group*\",\n            \"ros2_caret:*executor\",\n            \"ros2_caret:dds_bind*\",\n            \"ros2:rcl_*init\"]\n\n  if caret_session == \"\":\n    dt_now = datetime.datetime.now()\n    caret_session = \"autoware_launch_trace_\" + dt_now.strftime(\"%Y%m%d-%H%M%S\")\n\n  return launch.LaunchDescription([\n    Trace(\n      session_name=caret_session,\n      events_kernel=[],\n      events_ust=caret_event\n    ),\n    launch_ros.actions.Node(\n        package='caret_demos', executable='end_to_end_sample', output='screen'),\n  ])\n</code></pre>"},{"location":"recording/sim_time/","title":"ROS time (sim_time) support","text":""},{"location":"recording/sim_time/#introduction","title":"Introduction","text":"<p>CARET uses system time to analyze trace data by default. It may be inconvenient, especially when treating trace data recorded with rosbag. These are examples:</p> <ul> <li>The flow of time in analysis results (e.g., time series graph) is different from that of ROS when playing rosbag with <code>[-r RATE]</code> option. For instance, 10 Hz becomes 2 Hz when rosbag was played with <code>[-r 0.2]</code> but analysis uses system time</li> <li>Time becomes different at every recording even if you use the same rosbag file, which makes comparing experimental results difficult</li> </ul> <p>This page explains how to use sim_time.</p>"},{"location":"recording/sim_time/#recording-clock-topic","title":"Recording <code>/clock</code> topic","text":"<p><code>/clock</code> topic needs to be recorded in trace data. <code>/clock</code> topis is recorded as <code>ros2_caret:sim_time</code> event in trace data.</p> <p>Open a new terminal and run the following commands before recording and running a target application.</p> <p> <p>Info</p> <p>Remember to set <code>use_sim_time=true</code> for each node when launching a target application   Remember to add <code>--clock</code> option when playing rosbag</p> <p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\nros2 run caret_trace clock_recorder\n</code></pre> <p>You can check whether <code>/clock</code> is successfully recorded by the following command.</p> <pre><code>babeltrace &lt;path-to-trace-data&gt; | cut -d' ' -f 4 | sort -u | grep sim_time\n</code></pre> <pre><code>---Expected output text as below---\n\nros2_caret:sim_time:\n</code></pre>"},{"location":"recording/sim_time/#visualization-using-sim_time","title":"Visualization using sim_time","text":"<p>By setting <code>use_sim_time=True</code> or <code>xaxis_type='sim_time'</code>, sim_time is used instead of system time for the following APIs.</p> <pre><code>def callback_sched(\n    target: CallbackGroupTypes,\n    lstrip_s: float = 0,\n    rstrip_s: float = 0,\n    coloring_rule: str = 'callback',\n    use_sim_time: bool = False,\n    export_path: Optional[str] = None\n) -&gt; Figure:\n\ndef message_flow(\n    path: Path,\n    export_path: Optional[str] = None,\n    granularity: Optional[str] = None,\n    treat_drop_as_delay=False,\n    lstrip_s: float = 0,\n    rstrip_s: float = 0,\n    use_sim_time: bool = False\n) -&gt; Figure:\n\ndef show(\n    self,\n    xaxis_type: str = 'system_time',\n    ywheel_zoom: bool = True,\n    full_legends: bool = False,\n    export_path: Optional[str] = None\n) -&gt; Figure:\n</code></pre> <p>In case <code>/clock</code> topic is not recorded in trace data, the following error will occur.</p> <pre><code>InvalidArgumentError: Failed to load sim_time. Please measure again with clock_recorder running.\n</code></pre>"},{"location":"recording/sim_time/#sample-to-use-sim_time","title":"Sample to use sim_time","text":"<p>Explanation below assumes CARET is installed to <code>~/ros2_caret_ws</code> and the sample application used in the tutorial section is located in <code>~/ros2_ws</code>.</p>"},{"location":"recording/sim_time/#record-rosbag","title":"Record rosbag","text":"<p>The following steps can be performed either with or without CARET. If you have built a target application without CARET, you don't need to set environment for CARET and LD_PRELOAD.</p> <ol> <li> <p>Open a terminal to run a target application to record rosbag</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\nexport LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\nros2 run caret_demos end_to_end_sample\n</code></pre> </li> <li> <p>Open another terminal to record rosbag</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n\nros2 bag record /topic1 /drive\n</code></pre> <p>Here, <code>/topic1</code> and <code>/drive</code> are source topics of the sample application.  You can check if rosbag is successfully recorded.</p> <pre><code>ros2 bag info rosbag2_2022_09_30-10_57_06\n\nFiles:             rosbag2_2022_09_30-10_57_06_0.db3\nBag size:          29.3 KiB\nStorage id:        sqlite3\nDuration:          9.601s\nStart:             Sep 30 2022 10:57:08.952 (1664503028.952)\nEnd:               Sep 30 2022 10:57:18.554 (1664503038.554)\nMessages:          194\nTopic information: Topic: /drive | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr\n                Topic: /topic1 | Type: sensor_msgs/msg/Image | Count: 97 | Serialization Format: cdr\n</code></pre> </li> </ol>"},{"location":"recording/sim_time/#record-trace-data","title":"Record trace data","text":"<ol> <li> <p>Open another terminal and run the following commands</p> <pre><code>source /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\n\nros2 run caret_trace clock_recorder\n</code></pre> </li> <li> <p>Open another terminal to run a target application to record trace data with CARET</p> <p>In the launch file, <code>use_sim_time</code> is set to true and source nodes are disabled.</p> <pre><code> source /opt/ros/humble/setup.bash\n source ~/ros2_caret_ws/install/local_setup.bash\n source ~/ros2_ws/install/local_setup.bash\n export LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\nros2 launch caret_demos end_to_end_sample_with_lttng_session_use_sim.launch.py use_sim_time:=true use_rosbag:=true\n</code></pre> </li> <li> <p>Open another terminal to play the rosbag</p> <pre><code> source /opt/ros/humble/setup.bash\n source ~/ros2_ws/install/local_setup.bash\n\n ros2 bag play rosbag2_2022_09_30-10_57_06 --clock -r 0.2\n</code></pre> </li> <li> <p>Stop the application and the rosbag</p> </li> <li> <p>Check if <code>/clock</code> topic is recorded in trace data as <code>sim_time</code></p> <pre><code>babeltrace ~/ros2_ws/evaluate/e2e_sample | cut -d' ' -f 4 | sort -u | grep sim_time\nros2_caret:sim_time:\n</code></pre> </li> </ol>"},{"location":"recording/sim_time/#visualize-results-using-sim_time","title":"Visualize results using sim_time","text":"<ol> <li>Launch Jupyter Notebook in <code>~/ros2_ws/evaluate</code> and run the following scripts<ul> <li>Reference: the tutorial</li> </ul> </li> </ol> <pre><code>from bokeh.plotting import output_notebook\noutput_notebook()\nfrom caret_analyze import Architecture, Application, Lttng\nfrom caret_analyze.plot import Plot, message_flow\n\n# Read trace data\narch = Architecture('lttng', './e2e_sample')\nlttng = Lttng('./e2e_sample')\n\n# Search and add path\npaths = arch.search_paths(\n    '/filter_node',\n    '/message_driven_node')\narch.add_path('target_path', paths[0])\napp = Application(arch, lttng)\n\n# Draw message_flow\npath = app.get_path('target_path')\nmessage_flow(path, use_sim_time=True)\n\n# Draw node info\nnode = app.get_node('/filter_node')\nplot = Plot.create_callback_period_plot(node.callbacks)\nplot.show('sim_time')\n</code></pre>"},{"location":"recording/trace_filtering/","title":"Trace filtering","text":""},{"location":"recording/trace_filtering/#trace-filtering_1","title":"Trace filtering","text":"<p>CARET provides a trace filtering function to exclude specific nodes and topics. Trace data may be discarded when recording a large application like Autoware due to too many data to be recorded, and a warning will occur when validating/analyzing the recorded trace data (See validating). By applying trace filter, unconcerned events like <code>/tf</code> are ignored and the size of recorded data decreases.</p>"},{"location":"recording/trace_filtering/#trace-filter-configuration","title":"Trace filter configuration","text":"<ul> <li>Trace filter configuration is performed by setting the following environment variables<ul> <li><code>CARET_SELECT_NODES</code> : node names to be recorded</li> <li><code>CARET_IGNORE_NODES</code> : node names to be ignored</li> <li><code>CARET_SELECT_TOPICS</code> : topic names to be recorded</li> <li><code>CARET_IGNORE_TOPICS</code> : topic names to be ignored</li> </ul> </li> <li>\"SELECT\" settings override \"IGNORE\" settings if both are used</li> <li>Colon \"<code>:</code>\" is used to set more than one nodes/topics</li> <li>Regular expressions are supported</li> <li>These variables need to be set in the same terminal as a target application running</li> <li>In most cases, nodes related to <code>/rviz</code>, <code>/clock</code> topic and <code>/parameter_events</code> topic are unnecessary to analyze an application. It's recommended to ignore these nodes/topics</li> </ul> <p>The following shows sample settings</p> <pre><code>export CARET_IGNORE_NODES=\"/rviz*\"\nexport CARET_IGNORE_TOPICS=\"/clock:/parameter_events\"\n</code></pre> <p> <p>Info</p> <p>Trace filter doesn't exclude all events of the specified nodes/topics. Events in certain layers, especially DDS layer, won't be ignored.It is one of limitations with current implementation.</p> <p>"},{"location":"recording/trace_filtering/#trace-filter-setting-file","title":"Trace filter setting file","text":"<p>It will be handy to prepare a trace filter setting file like the following.</p> <pre><code># caret_topic_filter.bash\n#!/bin/bash\n\nexport CARET_IGNORE_NODES=\\\n\"\\\n/rviz*\\\n\"\n\nexport CARET_IGNORE_TOPICS=\\\n\"\\\n/clock:\\\n/parameter_events\\\n\"\n\n# if you want to select nodes or topics,\n# please remove comment out of the followings.\n# export CARET_SELECT_NODES=\\\n# \"\\\n# /rviz*\\\n# \"\n\n# export CARET_SELECT_TOPICS=\\\n# \"\\\n# /clock:\\\n# /parameter_events\\\n# \"\n</code></pre>"},{"location":"recording/validating/","title":"Validating trace data","text":""},{"location":"recording/validating/#validating-trace-data_1","title":"Validating trace data","text":"<p>You can check whether a recording is successful with <code>ros2 caret check_ctf</code> command.</p> <pre><code>ros2 caret check_ctf -d &lt;path-to-trace-data&gt;\n</code></pre> <p> <p>Info</p> <p>Executing the <code>ros2 caret check_ctf</code> command for long recorded data or recorded data of a large application takes a long time.   Therefore, it is recommended to execute the <code>ros2 caret check_ctf</code> command on a short duration of recorded data before long-time recording.   Also, It's recommended to record and validate trace data when you build a target application, so that you can modify code to avoid the following warnings.</p> <p> <p> <p>Info</p> <p>You can ignore warnings caused by Python and libraries</p> <p>"},{"location":"recording/validating/#warnings-due-to-wrong-procedure","title":"Warnings due to wrong procedure","text":""},{"location":"recording/validating/#failed-to-find-trace-point-added-by-caret-rclcpp","title":"<code>Failed to find trace point added by caret-rclcpp</code>","text":"<ul> <li>Cause<ul> <li>CARET/rclcpp is not applied when you built a target application</li> </ul> </li> <li>Solution<ul> <li>Build the application with CARET (See build section)</li> </ul> </li> </ul>"},{"location":"recording/validating/#failed-to-find-trace-point-added-by-ld_preload","title":"<code>Failed to find trace point added by LD_PRELOAD</code>","text":"<ul> <li>Cause<ul> <li>Hooked tracepoints were not found. <code>LD_PRELOAD</code> may be missed</li> </ul> </li> <li>Solution<ul> <li>Set <code>LD_PRELOAD</code> before running the application (See recording section)</li> </ul> </li> </ul>"},{"location":"recording/validating/#tracer-discarded","title":"<code>Tracer discarded</code>","text":"<ul> <li>Cause<ul> <li>Trace data lost occurred while recording due to too many trace data</li> <li>This warning will be observed in some case, especially when applying CARET to a large application</li> <li>Details<ul> <li>LTTng session collects sampling data generated by tracepoints. Sampling data are stored into ring-buffer as explained LTTng documents. After a piece of ring-buffer is occupied, sampling data is stored into next empty piece while the occupied piece is copied to file. If there is no room to store sampling data in all pieces of ring-buffer, sampling data will be discarded.</li> </ul> </li> </ul> </li> <li>Solution<ul> <li>Apply trace filter, or modify trace filter setting to ignore more topics/nodes (See trace filtering section)<ul> <li>especially, filtering highly-frequent nodes and topics is effective</li> <li>highly-frequent nodes/topics can be identified by checking the summary of trace data</li> </ul> </li> <li>Increase size of ring-buffer in CARET if a target device has enough memory<ul> <li>example</li> </ul> </li> </ul> </li> </ul>"},{"location":"recording/validating/#warnings-due-to-caret-limitations","title":"Warnings due to CARET limitations","text":"<ul> <li>CARET identifies callback functions using the following parameters. In case a node has several callback functions whose parameters are identical, such node is ignored because CARET cannot analyze it.<ul> <li>Timer callback functions: timer period</li> <li>Subscription callback functions: topic name</li> </ul> </li> </ul>"},{"location":"recording/validating/#duplicate-parameter-callback-found","title":"<code>Duplicate parameter callback found</code>","text":"<ul> <li>Cause<ul> <li>Several timer callback functions which have the same timer period exist in a node</li> <li>In other words, <code>rclcpp::create_timer()</code> with the same timer period is called more than once</li> </ul> </li> <li>Solution (workaround)<ul> <li>Modify code to avoid using the same timer period (You can slightly change timer period value)</li> <li>Or, this warning can be ignored unless the node needs to be analyzed</li> </ul> </li> </ul>"},{"location":"recording/validating/#failed-to-identify-subscription-several-candidates-were-found","title":"<code>Failed to identify subscription. Several candidates were found</code>","text":"<ul> <li>Cause<ul> <li>Several subscription callback functions which have the same topic name exist in a node</li> <li>In other words, <code>rclcpp::create_subscription()</code> with the same topic name is called more than once</li> </ul> </li> <li>Solution (workaround)<ul> <li>Modify code to avoid creating more than one subscription callback function with the same topic name</li> </ul> </li> </ul>"},{"location":"recording/validating/#multiple-executors-using-the-same-callback-group-were-detected","title":"<code>Multiple executors using the same callback group were detected</code>","text":"<ul> <li>Cause<ul> <li>A callback group is added to several executors</li> </ul> </li> <li>Solution<ul> <li>There is no solution at the moment. CARET uses the last executor to analyze. This warning can be ignored in most cases</li> </ul> </li> </ul>"},{"location":"recording/validating/#failed-to-find-callback-group","title":"<code>Failed to find callback group</code>","text":"<ul> <li>Cause<ul> <li>CARET failed to bind callback groups, callbacks and executors. It mainly because of ROS 2 \"service\". \"Service\" is not supported by CARET</li> </ul> </li> <li>Solution<ul> <li>There is no solution at the moment. This warning can be ignored in most cases</li> </ul> </li> </ul>"},{"location":"tutorials/configuration/","title":"Configuration","text":"<p>Please download the architecture file and use it for visualization.</p> <pre><code>cd ~/ros2_ws/evaluate\nwget https://raw.githubusercontent.com/tier4/CARET_demos/main/samples/end_to_end_sample/architecture.yaml\n</code></pre> <p>Configuration is an advanced topic for beginners. This section only provides the architecture file for the next section of visualization.</p> <p>Please refer to the chapter of Configuration if you are interested.</p>"},{"location":"tutorials/recording/","title":"Recording with CARET","text":"<p>This page explains usage of CARET with a sample application. The sample application is located on CARET_demos repository.</p> <p>See Recording to find more details.</p>"},{"location":"tutorials/recording/#building-application-with-caret","title":"Building application with CARET","text":"<p>To trace a target application, the target should be built with CARET/rclcpp. If you have already built the target without CARET/rclcpp, you have to build the target with CARET/rclcpp again. For building the application with CARET/rclcpp, CARET's <code>local_setup.bash</code> should be applied along with ROS 2's <code>setup.bash</code> as shown below.</p> <pre><code>mkdir -p ~/ros2_ws/src\ncd ~/ros2_ws\n\ngit clone https://github.com/tier4/CARET_demos.git src/CARET_demos\n\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash # please keep the order after 'source /opt/ros/humble/setup.bash'\n\ncolcon build --symlink-install --packages-up-to caret_demos --cmake-args -DBUILD_TESTING=OFF\n</code></pre> <p>The following command allows you to check whether CARET/rclcpp is applied to each package. If caret/rclcpp is not applied to the package you want to record, please check which rclcpp is used for the target and your workspace's environment variables.</p> <pre><code>ros2 caret check_caret_rclcpp --workspace ~/ros2_ws/\n\n# Expected output. CARET/rclcpp is applied to all packages\nINFO    : 2022-06-12 12:26:49 | All packages are built using caret-rclcpp.\n\n# In case there are packages to which CARET/rclcpp is not applied\n# The following message will be outputted\nWARNING : 2022-06-12 12:25:26 | The following packages have not been built using caret-rclcpp:\n   demo_nodes_cpp\n   caret_demos\n   intra_process_demo\n</code></pre>"},{"location":"tutorials/recording/#tracing-the-sample-application-with-caret","title":"Tracing the sample application with CARET","text":""},{"location":"tutorials/recording/#starting-lttng-session","title":"Starting LTTng session","text":"<p>CARET depends on LTTng for tracing applications. LTTng session has to be started before a target application runs. Note that if you execute the target application before starting LTTng session, it will result in a lack of trace points.</p> <p>You can execute LTTng session, for CARET, with a simple command interface as well as ros2-tracing.</p> <pre><code>source /opt/ros/humble/setup.bash\n\n# set a destination directory. ~/.ros/tracing is default.\nmkdir -p ~/ros2_ws/evaluate\nexport ROS_TRACE_DIR=~/ros2_ws/evaluate\n\nros2 trace -s e2e_sample -k -u \"ros2*\"\n# Start session with pressing Enter key\n</code></pre>"},{"location":"tutorials/recording/#launching-the-target-application","title":"Launching the target application","text":"<p>Open a new terminal and run the target as shown in the following</p> <pre><code># Environment settings (keep the order as below)\nsource /opt/ros/humble/setup.bash\nsource ~/ros2_caret_ws/install/local_setup.bash\nsource ~/ros2_ws/install/local_setup.bash\n\n# Enable tracepoints which are defined hooked functions.\nexport LD_PRELOAD=$(readlink -f ~/ros2_caret_ws/install/caret_trace/lib/libcaret.so)\n\n# (Optional) Exclude nodes and topics which you are not concerned with\nexport CARET_IGNORE_NODES=\"/rviz*\"\nexport CARET_IGNORE_TOPICS=\"/clock:/parameter_events\"\n\n# Launch the target application, demos_end_to_end_sample\nros2 launch caret_demos end_to_end_sample.launch.py\n^C # Finish with Ctrl+C after several seconds\n\n[WARNING] [launch]: user interrupted with ctrl-c (SIGINT)\n[end_to_end_sample-1] [INFO] [1631481246.160958444] [rclcpp]: signal_handler(signal_value=2)\n[INFO] [end_to_end_sample-1]: process has finished cleanly [pid 722356]\n</code></pre> <p>You can finish the target application and LTTng session. LTTng session will be closed if you push <code>Enter</code> key on the terminal where the LTTng session runs.</p>"},{"location":"tutorials/recording/#validating-recorded-data-briefly","title":"Validating recorded data briefly","text":"<p>You can check whether tracing is successful or not with <code>ros2 caret check_ctf</code> command before visualizing recorded data.</p> <pre><code>ros2 caret check_ctf -d ~/ros2_ws/evaluate/e2e_sample/\n\n# If there are problems with the recorded data, warning messages will be displayed.\n</code></pre>"},{"location":"tutorials/visualization/","title":"Performance visualization","text":"<p>CARET serves Python APIs to visualize trace data for users to analyze applications' performance. This section will show basic flow to visualize data with Jupyter notebook.</p>"},{"location":"tutorials/visualization/#how-to-locate-trace-data-on-jupyter-notebook","title":"How to locate trace data on Jupyter notebook","text":"<ol> <li> <p>Launching <code>jupyter-lab</code>    Launch <code>jupyter-lab</code> at first for learning how to visualize recorded data.</p> <pre><code>cd ~/ros2_ws/evaluate\n\nsource ~/ros2_caret_ws/install/setup.bash\njupyter-lab\n</code></pre> <p>CARET uses <code>bokeh</code> for some visualization APIs.  Execute the following code for loading <code>bokeh</code></p> <pre><code>from bokeh.plotting import output_notebook\noutput_notebook()\n</code></pre> </li> <li> <p>Loading trace data onto Jupyter notebook</p> <p>Locate trace data on Jupyter notebook as well as the architecture file.</p> <pre><code>from caret_analyze import Architecture, Application, Lttng\n\n# load the architecture file which is created in the previous page\narch = Architecture('yaml', './architecture.yaml')\n\n# load recorded data by CARET\nlttng = Lttng('./e2e_sample')\n\n# map the application architecture to recorded data\napp = Application(arch, lttng)\n</code></pre> <p>After execution of the code, users will often refer to the <code>app</code> object defined as <code>Application</code> class. The <code>app</code> objects provides users latency of callbacks, communication, and paths. <code>Application</code> class is similar to <code>Architecture</code> class which describes structure of the application and their interfaces are similar. In addition, <code>Application</code> class has interfaces to get latency.</p> </li> </ol>"},{"location":"tutorials/visualization/#basic-api-to-get-latency","title":"Basic API to get latency","text":"<p>This section will explain APIs to get callback latency. The following code is one of examples to get callback latency.</p> <pre><code># Get a callback instance, which has latency information, from app\ncallback = app.get_callback('/timer_driven_node/callback_0')\n\n# Get time-series variation of latency\nt, latency_ns = callback.to_timeseries()\n\n# Get histogram of latency\nbins, latency_ns = callback.to_histogram()\n</code></pre> <p>Though this example shows callback latency, CARET serves API to get communication latency. <code>callback.to_dataframe()</code> will provides <code>pandas.DataFrame</code> based object including raw timestamps which is obtained from tracepoints.</p> <p> <p>Todo<p>Sorry for not providing CARET's API list, but we'll provide it in the near future.</p> </p> <p>"},{"location":"tutorials/visualization/#visualizing-latency-of-node-chain-with-message-flow","title":"Visualizing latency of node chain with message flow","text":"<p>CARET provides some APIs to visualize measured data. With message flow, which is one of effective visualizations, users can understand what happens and where is bottleneck in target applications. Execute the following code for visualization with message flow.</p> <pre><code>from caret_analyze.plot import message_flow\n\npath = app.get_path('target')\nmessage_flow(path)\n</code></pre> <p>The following figure will appear if <code>message_flow</code> method is successful.</p> <p></p> <p>The horizontal axis shows time line. On the other hand, the vertical axis shows elements of the node chain (<code>target_path</code>), which include callback functions and topic messages from input to output. Each colorful line shows how a certain input message is propagated to callback functions and topic communications. Gray rectangles show execution timing of callback functions.</p> <p>If your mouse pointer is put over one of gray rectangles, latency of callback functions will be shown. You can find latency of a target node chain as well if you put the mouse pointer onto one of colorful lines.</p> <p>CARET serves other APIs for visualization. Refer to visualization for more details.</p>"},{"location":"visualization/","title":"Visualization","text":"<p>This section describes APIs to visualize the measurement results. We recommend to read Basic APIs Concept (Visualization) at first.</p>"},{"location":"visualization/#basic-apis-concept","title":"Basic APIs Concept","text":"<ul> <li>Gallery</li> <li>Basic APIs Concept (Visualization)</li> </ul>"},{"location":"visualization/#caret-api-list","title":"CARET API List","text":""},{"location":"visualization/#visualization-apis","title":"Visualization APIs","text":""},{"location":"visualization/#callback","title":"Callback","text":"<ul> <li>callback_sched<ul> <li>Visualize callback scheduling</li> </ul> </li> <li>create_callback_frequency_plot</li> <li>create_callback_period_plot</li> <li>create_callback_latency_plot</li> </ul>"},{"location":"visualization/#communication","title":"Communication","text":"<ul> <li>create_communication_latency_plot</li> <li>create_communication_frequency_plot</li> <li>create_communication_period_plot</li> <li>create_publish_subscription_period_plot</li> <li>create_publish_subscription_frequency_plot</li> </ul>"},{"location":"visualization/#path","title":"Path","text":"<ul> <li>message_flow<ul> <li>Visualize the message flow of the target path</li> </ul> </li> <li>create_response_time_histogram_plot</li> <li>chain_latency</li> </ul>"},{"location":"visualization/#helper-apis","title":"Helper APIs","text":"<p>CARET provides some APIs which can help users to focus on their respective interest.</p> <ul> <li>LTTngEventFilter</li> <li>Wildcards for get_callbacks()</li> </ul> <p> <p>Info</p> <p>CARET analyze API document describes the parameters and returns of APIs.</p> <p>"},{"location":"visualization/basic_api_concept/","title":"Basic APIs Concept","text":""},{"location":"visualization/basic_api_concept/#the-main-basic-design-of-the-plot-class","title":"The main basic design of the Plot class","text":"<p>Visualization is available from the Plot class provided by CARET. The usage of each API in the Plot class is unified as follows:</p> <pre><code>from caret_analyze.plot import Plot\n\n... # Processing input data\n\nplot = Plot.create_[metrics]_[graph_type]_plot(data)\nplot.show()\nplot.to_dataframe()\n</code></pre> <p>The variable <code>plot</code> has two functions, <code>show()</code> and <code>to_dataframe()</code>. The function <code>show()</code> outputs a figure and returns the figure's handler. The function <code>to_dataframe()</code> returns a table summarizing the data. This function is mainly used to analyze based on specific figures.</p> <p> <p>Info</p> <p>For detailed input/output options, see TimeSeriesPlot.</p> <p>"},{"location":"visualization/callback/callback_information/","title":"Callback Information","text":"<p>CARET can visualize the callback frequency, period, and latency. This document describes sample visualization scripts for them. Execute following commands before running commands in each section.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\n</code></pre> <p> <p>Info</p> <p>The <code>output_notebook()</code> is needed to show figures inside Jupyter Notebook.</p> <p>"},{"location":"visualization/callback/callback_information/#frequency","title":"Frequency","text":"<pre><code># get dataframe\nplot = Plot.create_callback_frequency_plot(app.callbacks)\n\nfrequency_df = plot.to_dataframe()\nfrequency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <pre><code># show time-line\nplot = Plot.create_callback_frequency_plot(app.callbacks)\n\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> plotting by 1 second (changeable time-line as <code>xaxis_type=['system_time', 'sim_time', 'index']</code>). The vertical axis means <code>Frequency [Hz]</code> of the callback. This API is used to confirm whether the callback was running at desired frequency.</p>"},{"location":"visualization/callback/callback_information/#period","title":"Period","text":"<pre><code># get dataframe\nplot = Plot.create_callback_period_plot(app.callbacks)\n\nperiod_df = plot.to_dataframe()\nperiod_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <pre><code># show time-line\nplot = Plot.create_callback_period_plot(app.callbacks)\n\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> (changeable in ['system_time', 'sim_time', 'index']). The vertical axis means <code>Period [ms]</code> from one callback starts to the next time that the callback starts.</p>"},{"location":"visualization/callback/callback_information/#latency","title":"Latency","text":"<pre><code># get dataframe\nplot = Plot.create_callback_latency_plot(app.callbacks)\n\nlatency_df = plot.to_dataframe()\nlatency_df\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <pre><code># show time-line\nplot = Plot.create_callback_latency_plot(app.callbacks)\n\nplot.show()\n\n# ---Output in jupyter-notebook as below---\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> (changeable in ['system_time', 'sim_time', 'index']). The vertical axis means <code>Latency [ms]</code> from <code>callback_start</code> to <code>callback_end</code>.</p>"},{"location":"visualization/callback/callback_scheduling_visualization/","title":"Callback Scheduling Visualization","text":"<p>The function <code>callback_sched()</code> visualizes the callback scheduling of targets, such as Node, Path, Executor, and Callbackgroup.</p> <pre><code>from caret_analyze import Architecture, Application, Lttng\nfrom caret_analyze.plot import callback_sched\narch = Architecture('lttng', './e2e_sample')\nlttng = Lttng('./e2e_sample')\napp = Application(arch, lttng)\n# target: node\nnode = app.get_node('node_name') # get node object\ncallback_sched(node)\n# target: executor\nexecutor = app.get_executor('executor_name') # get executor object\ncallback_sched(executor)\n# target: executor\ncbg = app.get_callback_group('cbg_name') # get callback group object\ncallback_sched(cbg)\n</code></pre> <p></p> <ul> <li>Callback Scheduling Visualization<ul> <li>Colored rectangles indicate the callback execution time (callback_start to callback_end)</li> <li>Information about the callback will be displayed by hovering over the translucent colored areas.</li> </ul> </li> <li>Timer Event Visualization<ul> <li>Arrows are the expected start timing of the timer callback</li> <li>If timer callbacks start with delay (5 ms or more), the arrows turn red (if on time, white)</li> </ul> </li> </ul>"},{"location":"visualization/communication/communication_information/","title":"Communication Information","text":"<p>CARET can visualize the communication frequency, period, and latency. This document describes sample visualization scripts for them. Execute following commands before running commands in each section.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\ncomm = app.get_communications('topic_name')\ncomm = comm[0]\n# or comm = app.get_communication('pub_node', 'sub_node', 'topic_name')\n</code></pre> <p> <p>Info</p> <ol> <li>The <code>output_notebook()</code> is needed to show figures inside Jupyter Notebook.</li> <li>The function <code>get_communications</code> returns a List and the function <code>get_communication</code> returns one communication handler.</li> </ol> <p>"},{"location":"visualization/communication/communication_information/#frequency","title":"Frequency","text":"<pre><code>plot = Plot.create_communication_frequency_plot(comm)\nplot.show()\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> plotting by 1 second (changeable time-line as <code>xaxis_type=['system_time', 'sim_time', 'index']</code>). The vertical axis means <code>Frequency [Hz]</code> of the communication. This API is used to confirm whether the communication was running at desired frequency.</p>"},{"location":"visualization/communication/communication_information/#period","title":"Period","text":"<pre><code>plot = Plot.create_communication_period_plot(comm)\nplot.show()\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> (changeable in ['system_time', 'sim_time', 'index']). The vertical axis means <code>Period [ms]</code> from one communication to next communication. from one communication starts to the next time that the communication starts. This API is used to confirm whether the period was stable.</p>"},{"location":"visualization/communication/communication_information/#latency","title":"Latency","text":"<pre><code>plot = Plot.create_communication_latency_plot(comm)\nplot.show()\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> (changeable in ['system_time', 'sim_time', 'index']). The vertical axis means <code>Latency [ms]</code> from one callback publishes a topic to next callback starts. This API is used to confirm the communication time.</p>"},{"location":"visualization/communication/pub_sub_information/","title":"Publish/Subscription Information","text":"<p>CARET can visualize the publish/subscription frequency and period. This document describes sample visualization scripts for them. Execute following commands before running commands in each section.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook() # Info 1\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npub = app.get_publishers('topic_name')\npub = pub[0] # Info 2\n\n# Please use the following commands in the case visualizing subscription.\n# sub = app.get_subscriptions('topic_name')\n# sub = sub[0]\n</code></pre> <p> <p>Info</p> <ol> <li>The <code>output_notebook()</code> is needed to show figures inside Jupyter Notebook.</li> <li>The function <code>get_publishers()</code> and <code>get_subscriptions()</code> return a List of publishers/subscribers involving the given topic name. The sample code uses the first value of the List.</li> </ol> <p>"},{"location":"visualization/communication/pub_sub_information/#frequency","title":"Frequency","text":"<pre><code>plot = Plot.create_publish_subscription_frequency_plot(pub)\nplot.show()\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> plotting by 1 second (changeable time-line as <code>xaxis_type=['system_time', 'sim_time', 'index']</code>). The vertical axis means <code>Frequency [Hz]</code> of the publisher/subscriber. This API is used to confirm whether the publisher/subscriber was running at desired frequency.</p>"},{"location":"visualization/communication/pub_sub_information/#period","title":"Period","text":"<pre><code>plot = Plot.create_publish_subscription_period_plot(pub)\nplot.show()\n</code></pre> <p>The horizontal axis means <code>Time [s]</code> (changeable in ['system_time', 'sim_time', 'index']). The vertical axis means <code>Period [ms]</code> from one publish/subscription to next publish/subscription. This API is used to confirm whether the period was stable.</p>"},{"location":"visualization/filter/lttng_event_filter/","title":"Usage of LTTngEventFilter","text":"<p>CARET can handle measurements and analysis up to several minutes. Memory usage, analysis time, and visualization time, etc., will be issues when leveraging measurement results of longer duration.</p> <p>Therefore, CARET has an API (LTTngEventFilter) to omit unnecessary measurement results when reading LTTng. This section describes how to use the LTTngEventFilter.</p> <p>LTTngEventFilter has the following filters</p> <ul> <li>init_pass_filter</li> <li>duration_filter</li> <li>strip_filter</li> </ul>"},{"location":"visualization/filter/lttng_event_filter/#api-description","title":"API Description","text":"<pre><code>LttngEventFilter.init_pass_filter()\n</code></pre> <ul> <li>Filter the trace points at initialization</li> </ul> <pre><code>LttngEventFilter.duration_filter(duration_s: float, offset_s: float)\n</code></pre> <ul> <li>[duration_s] : Measure duration</li> <li>[offset_s] : Ignore seconds from start</li> </ul> <pre><code>LttngEventFilter.strip_filter(lsplit_s: Optional[float], rsplit_s: Optional[float])\n</code></pre> <ul> <li>Ignore measurement results for [lsplit_s] from the start of the measurement</li> <li>Ignore measurement results for [rsplit_s] seconds before measurement ends</li> </ul>"},{"location":"visualization/filter/lttng_event_filter/#use-cases","title":"Use cases","text":"<pre><code>from caret_analyze import Lttng, LttngEventFilter\n\nlttng = Lttng('/path/to/ctf', event_filters=[\n  LttngEventFilter.duration_filter(10, 5)\n]) # Filtering for 10 from 5 seconds\n</code></pre> <p>Multiple event_filters can be specified.</p>"},{"location":"visualization/path/chain_latency/","title":"Chain latency","text":"<p>Chain latency can show the latency of each node in the end-to-end path and the communication time between nodes.</p> <pre><code>from caret_analyze.plot import chain_latency\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npath = app.get_path('target_path')\n\nchain_latency(path, granularity='node', lstrip_s=1, rstrip_s=1)\n</code></pre> <p></p> <ul> <li><code>granularity</code><ul> <li>Change the granularity of visualization in ['raw', 'node']</li> </ul> </li> <li><code>lstrip_s</code> and <code>rstrip_s</code><ul> <li>Extract the focusing points by removing unnecessary data</li> <li><code>lstrip_s=1</code> means that the data for 1 second from trace start is removed.</li> <li><code>rstrip_s=1</code> means that the data for 1 second from trace end is removed.</li> </ul> </li> </ul>"},{"location":"visualization/path/message_flow/","title":"Message flow","text":"<p>The function <code>message_flow()</code> can visualizes message dependencies throughout the system. You can confirm latency of the target path.</p> <pre><code>from caret_analyze.plot import message_flow\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npath = app.get_path('target_path')\n\nmessage_flow(path, granularity='node', lstrip_s=1, rstrip_s=1)\n</code></pre> <p></p> <p>The horizontal axis means <code>Time [s]</code>. The vertical axis means the target path to measure the latency. Each colored line represents message dependencies for each message. The gray rectangular areas indicate the callback execution time.</p> <p>The function <code>message_flow()</code> has following arguments.</p> <ul> <li><code>granularity</code><ul> <li>Change the granularity of visualization in ['raw', 'node']</li> </ul> </li> <li><code>lstrip_s</code> and <code>rstrip_s</code><ul> <li>Extract the focusing points by removing unnecessary data</li> <li><code>lstrip_s=1</code> means that the data for 1 second from trace start is removed.</li> <li><code>rstrip_s=1</code> means that the data for 1 second from trace end is removed.</li> </ul> </li> <li><code>use_sim_time</code><ul> <li>Bool whether using simulation time (<code>False</code> by default)</li> </ul> </li> </ul> <p>In addition to the basic operations of bokeh, the message flow diagram allows the following operations</p> <ul> <li>Scale adjustment of xaxis/yaxis<ul> <li>Scale adjustments can be made only on the X-axis or only on the Y-axis by operating the wheel on the axis labels.</li> </ul> </li> <li>View detailed information<ul> <li>Move the cursor over the lines in the message flow or the gray rectangular areas can see the detail information of the callback and message.</li> </ul> </li> </ul>"},{"location":"visualization/path/response_time/","title":"Plot Response Time","text":"<p>Response Time is visualized in Histogram and there are 3 cases ([default, best, worst]) as described in Here. This document describes sample visualization scripts for Response Time. In each case, the horizontal axis means <code>Response Time [ms]</code> and the vertical axis means <code>Probability</code>. This API is used to confirm how long the response time is.</p> <pre><code>from caret_analyze.plot import Plot\nfrom caret_analyze import Application, Architecture, Lttng\nfrom bokeh.plotting import output_notebook, figure, show\noutput_notebook()\n\narch = Architecture('yaml', '/path/to/architecture_file')\nlttng = Lttng('/path/to/trace_data')\napp = Application(arch, lttng)\npath = app.get_path('target_path')\n\n# plot default case\nplot = Plot.create_response_time_histogram_plot(path)\nplot.show()\n</code></pre> <p> <p>Info</p> <p>The <code>output_notebook()</code> is needed to show figures inside Jupyter Notebook.</p> <p> <p></p> <pre><code># plot best case\nplot = Plot.create_response_time_histogram_plot(path, case='best')\nplot.show()\n</code></pre> <p></p> <pre><code># plot worst case\nplot = Plot.create_response_time_histogram_plot(path, case='worst')\nplot.show()\n</code></pre> <p></p>"},{"location":"visualization/search/wildcards_for_get_callbacks/","title":"Wildcards for get_callbacks()","text":"<p>The function <code>get_callbacks()</code> gets a list of callbacks that match the argument string and callback names (callback names defined in architecture file). If there is no match callbacks, this function may notify similar callback names. The function <code>get_callbacks()</code> can recognize UNIX filename patterns such as '*' or '?'. If there is no match callbacks even though using these wildcards, a empty list is returned.</p>"},{"location":"visualization/search/wildcards_for_get_callbacks/#usage","title":"Usage","text":"<pre><code>from caret_analyze import Architecture, Application, Lttng\n\ncallback1 = app.get_callbacks('/timer_driven_node/callback_0')\ncallback2 = app.get_callbacks('/timer_driven_node/callback_?')\ncallback3 = app.get_callbacks('/timer_driven_node/*')\n</code></pre>"}]}